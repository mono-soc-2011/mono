%{
//
// Mono.ILAsm.ILParser
// 
// (C) Sergey Chaban (serge@wildwestsoftware.com)
// (C) 2003 Jackson Harper, All rights reserved
// (C) 2011 Alex RÃ¸nne Petersen <xtzgzorex@gmail.com>
//

using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

namespace Mono.ILAsm {
	internal class ILParser {
		static readonly int yacc_verbose_flag = 0;
		readonly CodeGenerator codegen;
		readonly ILTokenizer tokenizer;
		readonly Report report;
		readonly Stack<string> namespace_stack = new Stack<string> ();
		readonly Stack<TypeDefinition> typedef_stack = new Stack<TypeDefinition> ();
		readonly Dictionary<string, Label> labels = new Dictionary<string, Label> ();
		readonly Stack<Scope> scope_stack = new Stack<Scope> ();
		readonly Dictionary<Instruction, object> label_jumps = new Dictionary<Instruction, object> ();
		readonly List<Label> current_labels = new List<Label> ();
		MethodReference dummy_method;
		TypeReference dummy_type;
		bool is_enum_class;
		bool is_value_class;
		bool has_public_key;
		bool has_public_key_token;
		bool is_explicit_call;
		bool is_instance_call;
		bool is_parameter_marshal_notation;
		bool type_attr_visibility_set;
		bool is_inside_scope;
		bool generic_typeref_in_method;
		bool generic_typeref_in_methoddef;
		bool generic_typeref_in_field;
		bool custom_attr_unsigned;
		int custom_attr_blob_seq_length;
		string pinvoke_mod_name;
		ILProcessor il;
		Instruction last_instr;

		public ILParser (Report report, CodeGenerator codegen, ILTokenizer tokenizer)
		{
			this.report = report;
			this.codegen = codegen;
			this.tokenizer = tokenizer;

			scope_stack.Push (null);

			ResetDummyMethod ();
			ResetDummyType ();
		}

		Instruction FindInstruction (int idx)
		{
			if (idx < 0 || idx >= il.Body.Instructions.Count)
				report.WriteError (Error.InvalidLabel,
					"Instruction at index '{0}' not found.", idx);

			return il.Body.Instructions [idx];
		}

		Instruction FindInstruction (string name)
		{
			Label label;

			if (!labels.TryGetValue (name, out label))
				report.WriteError (Error.InvalidLabel,
					"Label '{0}' not found.", name);

			return label.Instruction;
		}

		GenericParameter GetGenericParameter (MethodReference method, string name)
		{
			if (method == null)
				report.WriteError (Error.GenericParameterAccessOutsideMethod,
					"Cannot access a generic parameter outside a method definition.");

			method = method.GetElementMethod ();

			GenericParameter param = null;

			foreach (var genParam in method.GenericParameters)
				if (genParam.Name == name)
					param = genParam;

			if (param == null)
				report.WriteError (Error.GenericParameterNameInvalid,
					"Generic parameter '{0}' not found.", name);

			return param;
		}

		GenericParameter GetGenericParameter (MethodReference method, int idx)
		{
			if (method == null)
				report.WriteError (Error.GenericParameterAccessOutsideMethod,
					"Cannot access a generic parameter outside a method definition.");

			method = method.GetElementMethod ();

			var genParams = method.GenericParameters;

			if (idx < 0 || idx >= genParams.Count)
				report.WriteError (Error.GenericParameterOrdinalOutOfRange,
					"Generic parameter ordinal '{0}' is invalid.", idx);

			return genParams [idx];
		}

		GenericParameter GetGenericParameter (TypeReference type, string name)
		{
			if (type == null)
				report.WriteError (Error.GenericParameterAccessOutsideType,
					"Cannot access a generic parameter outside a type definition.");

			type = type.GetElementType ();

			GenericParameter param = null;

			foreach (var genParam in type.GenericParameters)
				if (genParam.Name == name)
					param = genParam;

			if (param == null)
				report.WriteError (Error.GenericParameterNameInvalid,
					"Generic parameter '{0}' not found.", name);

			return param;
		}

		GenericParameter GetGenericParameter (TypeReference type, int idx)
		{
			if (type == null)
				report.WriteError (Error.GenericParameterAccessOutsideType,
					"Cannot access a generic parameter outside a type definition.");

			type = type.GetElementType ();

			var genParams = type.GenericParameters;

			if (idx < 0 || idx >= genParams.Count)
				report.WriteError (Error.GenericParameterOrdinalOutOfRange,
					"Generic parameter ordinal '{0}' is invalid.", idx);

			return genParams [idx];
		}

		ICustomAttributeProvider ResolveCustomAttributeOwner (object owner)
		{
			ICustomAttributeProvider provider;

			if (owner is TypeReference)
				provider = ((TypeReference) owner).Resolve ();
			else if (owner is FieldReference)
				provider = ((FieldReference) owner).Resolve ();
			else
				provider = ((MethodReference) owner).Resolve ();

			if (provider == null)
				report.WriteError (Error.UndefinedTypeReference,
					"Could not resolve custom attribute owner: {0}", owner);

			return provider;
		}

		void ResetDummyType ()
		{
			dummy_type = new TypeReference (null, null, codegen.CurrentModule, null);
		}

		void ResetDummyMethod ()
		{
			dummy_method = new MethodReference (null,
				new TypeReference (null, null, null, null),
				new TypeReference (null, null, codegen.CurrentModule, null));
		}

%}

%token UNKNOWN
%token EOF
%token ID
%token QSTRING
%token SQSTRING
%token COMP_NAME
%token INT32
%token INT64
%token FLOAT64
%token HEXBYTE

%token DOT "."
%token OPEN_BRACE "{"
%token CLOSE_BRACE "}"
%token OPEN_BRACKET "["
%token CLOSE_BRACKET "]"
%token OPEN_PARENS "("
%token CLOSE_PARENS ")"
%token COMMA ","
%token COLON ":"
%token DOUBLE_COLON "::"
%token SEMICOLON ";"
%token ASSIGN "="
%token STAR "*"
%token AMPERSAND "&"
%token PLUS "+"
%token SLASH "/"
%token BANG "!"
%token ELLIPSIS "..."
%token DASH "-"
%token OPEN_ANGLE_BRACKET "<"
%token CLOSE_ANGLE_BRACKET ">"

%token INSTR_NONE
%token INSTR_VAR
%token INSTR_I
%token INSTR_I8
%token INSTR_R
%token INSTR_BRTARGET
%token INSTR_METHOD
%token INSTR_NEWOBJ
%token INSTR_FIELD
%token INSTR_TYPE
%token INSTR_STRING
%token INSTR_SIG
%token INSTR_RVA
%token INSTR_TOK
%token INSTR_SWITCH
%token INSTR_PHI
%token INSTR_LOCAL
%token INSTR_PARAM

%token D_ASSEMBLY
%token D_CCTOR
%token D_CLASS
%token D_IMAGEBASE
%token D_CORFLAGS
%token D_CTOR
%token D_CUSTOM
%token D_DATA
%token D_EMITBYTE
%token D_ENTRYPOINT
%token D_EVENT
%token D_EXPORT
%token D_FIELD
%token D_FILE
%token D_FIRE
%token D_GET
%token D_HASH
%token D_LANGUAGE
%token D_LINE
%token D_XLINE
%token D_LOCALE
%token D_CULTURE
%token D_LOCALIZED
%token D_LOCALS
%token D_MAXSTACK
%token D_METHOD
%token D_MODULE
%token D_MRESOURCE
%token D_MANIFESTRES
%token D_NAMESPACE
%token D_OTHER
%token D_OVERRIDE
%token D_PACK
%token D_PARAM
%token D_PERMISSION
%token D_PERMISSIONSET
%token D_PROPERTY
%token D_PUBLICKEY
%token D_PUBLICKEYTOKEN
%token D_ADDON
%token D_REMOVEON
%token D_SET
%token D_SIZE
%token D_STACKRESERVE
%token D_SUBSYSTEM
%token D_TRY
%token D_VER
%token D_VTABLE
%token D_VTENTRY
%token D_VTFIXUP
%token D_ZEROINIT
%token D_THIS
%token D_BASE
%token D_NESTER
%token D_TYPELIST
%token D_MSCORLIB
%token D_PDIRECT
%token D_TYPEDEF
%token D_XDEFINE
%token D_XUNDEF
%token D_XIFDEF
%token D_XIFNDEF
%token D_XELSE
%token D_XENDIF
%token D_XINCLUDE

%token K_AT
%token K_AS
%token K_IMPLICITCOM
%token K_IMPLICITRES
%token K_EXTERN
%token K_INSTANCE
%token K_EXPLICIT
%token K_DEFAULT
%token K_VARARG
%token K_UNMANAGED
%token K_CDECL
%token K_STDCALL
%token K_THISCALL
%token K_FASTCALL
%token K_MARSHAL
%token K_IN
%token K_OUT
%token K_OPT
%token K_STATIC
%token K_PUBLIC
%token K_PRIVATE
%token K_FAMILY
%token K_INITONLY
%token K_RTSPECIALNAME
%token K_STRICT
%token K_SPECIALNAME
%token K_ASSEMBLY
%token K_FAMANDASSEM
%token K_FAMORASSEM
%token K_PRIVATESCOPE
%token K_LITERAL
%token K_NOTSERIALIZED
%token K_VALUE
%token K_NOT_IN_GC_HEAP
%token K_INTERFACE
%token K_SEALED
%token K_ABSTRACT
%token K_AUTO
%token K_SEQUENTIAL
%token K_ANSI
%token K_UNICODE
%token K_AUTOCHAR
%token K_BESTFIT
%token K_IMPORT
%token K_SERIALIZABLE
%token K_NESTED
%token K_EXTENDS
%token K_IMPLEMENTS
%token K_FINAL
%token K_VIRTUAL
%token K_HIDEBYSIG
%token K_NEWSLOT
%token K_UNMANAGEDEXP
%token K_PINVOKEIMPL
%token K_NOMANGLE
%token K_LASTERR
%token K_WINAPI
%token K_PLATFORMAPI
%token K_NATIVE
%token K_IL
%token K_CIL
%token K_OPTIL
%token K_MANAGED
%token K_FORWARDREF
%token K_RUNTIME
%token K_INTERNALCALL
%token K_SYNCHRONIZED
%token K_NOINLINING
%token K_NOOPTIMIZATION
%token K_CUSTOM
%token K_FIXED
%token K_SYSSTRING
%token K_ARRAY
%token K_VARIANT
%token K_CURRENCY
%token K_SYSCHAR
%token K_VOID
%token K_BOOL
%token K_INT8
%token K_INT16
%token K_INT32
%token K_INT64
%token K_FLOAT
%token K_FLOAT32
%token K_FLOAT64
%token K_ERROR
%token K_UNSIGNED
%token K_UINT
%token K_UINT8
%token K_UINT16
%token K_UINT32
%token K_UINT64
%token K_DECIMAL
%token K_DATE
%token K_BSTR
%token K_LPSTR
%token K_LPWSTR
%token K_LPTSTR
%token K_OBJECTREF
%token K_IUNKNOWN
%token K_IDISPATCH
%token K_STRUCT
%token K_SAFEARRAY
%token K_INT
%token K_BYVALSTR
%token K_TBSTR
%token K_LPVOID
%token K_ANY
%token K_FLOAT
%token K_LPSTRUCT
%token K_NULL
%token K_PTR
%token K_VECTOR
%token K_HRESULT
%token K_CARRAY
%token K_USERDEFINED
%token K_RECORD
%token K_FILETIME
%token K_BLOB
%token K_STREAM
%token K_STORAGE
%token K_STREAMED_OBJECT
%token K_STORED_OBJECT
%token K_BLOB_OBJECT
%token K_CF
%token K_CLSID
%token K_METHOD
%token K_CLASS
%token K_PINNED
%token K_MODREQ
%token K_MODOPT
%token K_TYPEDREF
%token K_TYPE
%token K_CHAR
%token K_WCHAR
%token K_FROMUNMANAGED
%token K_CALLMOSTDERIVED
%token K_RETAINAPPDOMAIN
%token K_BYTEARRAY
%token K_WITH
%token K_INIT
%token K_TO
%token K_CATCH
%token K_FILTER
%token K_FINALLY
%token K_FAULT
%token K_HANDLER
%token K_TLS
%token K_FIELD
%token K_PROPERTY
%token K_REQUEST
%token K_DEMAND
%token K_ASSERT
%token K_DENY
%token K_PERMITONLY
%token K_LINKCHECK
%token K_INHERITCHECK
%token K_REQMIN
%token K_REQOPT
%token K_REQREFUSE
%token K_PREJITGRANT
%token K_PREJITDENY
%token K_NONCASDEMAND
%token K_NONCASLINKDEMAND
%token K_NONCASINHERITANCE
%token K_NOMETADATA
%token K_ALGORITHM
%token K_RETARGETABLE
%token K_LEGACY
%token K_LIBRARY
%token K_X86
%token K_IA64
%token K_AMD64
%token K_PRESERVESIG
%token K_BEFOREFIELDINIT
%token K_ALIGNMENT
%token K_NULLREF
%token K_VALUETYPE
%token K_COMPILERCONTROLLED
%token K_REQSECOBJ
%token K_ENUM
%token K_OBJECT
%token K_STRING
%token K_TRUE
%token K_FALSE
%token K_ON
%token K_OFF
%token K_CHARMAPERROR
%token K_MDTOKEN
%token K_FLAGS
%token K_CALLCONV
%token K_NOAPPDOMAIN
%token K_NOMACHINE
%token K_NOPROCESS
%token K_ILLEGAL
%token K_UNUSED
%token K_WRAPPER
%token K_FORWARDER

%start il_file

%%

il_file			: decls
			;

decls			:
			| decls decl
			;

decl			: class_all
			| namespace_all
			| method_all
			| field_decl
			| data_decl
			| vtable_decl
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtable is currently unimplemented (directive ignored).");
			}
			| vtfixup_decl
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtfixup is currently unimplemented (directive ignored).");
			}
			| file_decl
			| assembly_all
			| assemblyref_all
			| exptype_all
			| manifestres_all
			| module_head
			| sec_decl
			{
				// TODO: We can't set security attributes on modules with Cecil.
				//codegen.CurrentModule.SecurityDeclarations.Add (codegen.CurrentSecurityDeclaration);
				//codegen.CurrentSecurityDeclaration = null;
			}
			| customattr_decl
			{
				if ($1 != null) {
					codegen.CurrentModule.CustomAttributes.Add ((CustomAttribute) $1);
					codegen.CurrentCustomAttribute = null;
				}
			}
			| D_SUBSYSTEM int32
			{
				codegen.CurrentModule.Kind = (ModuleKind) (int) $2;
			}
			| D_CORFLAGS int32
			{
				codegen.CurrentModule.Attributes = (ModuleAttributes) (int) $2;
			}
			// TODO: Find a way to set these with Cecil.
			| D_FILE K_ALIGNMENT int32
			{
				var fa = (int) $3;

				if (fa < 0x200 || fa > 0x10000 || (fa & (fa - 1)) != 0) {
					report.WriteError (Error.InvalidFileAlignment,
						"Invalid file alignment; must be a power of two between 0x200 and 0x10000.");
				}
			}
			| D_IMAGEBASE int64
			{
				var ib = (long) $2;

				if ((ib & 0xffff) != 0) {
					report.WriteError (Error.InvalidImageBase,
						"Invalid image base; must be 0x10000-aligned.");
				}
			}
			| D_STACKRESERVE int64
			| D_TYPELIST OPEN_BRACE class_refs CLOSE_BRACE // TODO: How can we sort with Cecil?
			| D_MSCORLIB
			{
				// TODO: We need to set the native image base to 0x00510000 here.
				codegen.IsCorlib = true;
			}
			| extsource_spec
			| language_decl
			| typedef_decl
			| comp_control
			;

line_directive		: D_LINE
			| D_XLINE
			;

// TODO: Persist these in MDB.
extsource_spec		: line_directive int32 SQSTRING
			| line_directive int32
			| line_directive int32 COLON int32 SQSTRING
			| line_directive int32 COLON int32
			| line_directive int32 COLON int32 COMMA int32 SQSTRING
			| line_directive int32 COLON int32 COMMA int32
			| line_directive int32 COMMA int32 COLON int32 SQSTRING
			| line_directive int32 COMMA int32 COLON int32
			| line_directive int32 COMMA int32 COLON int32 COMMA int32 SQSTRING
			| line_directive int32 COMMA int32 COLON int32 COMMA int32
			| line_directive int32 QSTRING
			;

// TODO: Persist these in MDB.
language_decl		: D_LANGUAGE SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING COMMA SQSTRING
			;

vtable_decl		: D_VTABLE ASSIGN OPEN_PARENS bytes CLOSE_PARENS
			;

vtfixup_decl		: D_VTFIXUP OPEN_BRACKET int32 CLOSE_BRACKET vtfixup_attr K_AT id
			;

vtfixup_attr		:
			| vtfixup_attr K_INT32
			| vtfixup_attr K_INT64
			| vtfixup_attr K_FROMUNMANAGED
			| vtfixup_attr K_CALLMOSTDERIVED
			| vtfixup_attr K_RETAINAPPDOMAIN
			;

typedef_decl		: D_TYPEDEF type K_AS comp_name
			| D_TYPEDEF class_ref K_AS comp_name
			| D_TYPEDEF member_ref K_AS comp_name
			| D_TYPEDEF customattr K_AS comp_name
			| D_TYPEDEF customattr_owner K_AS comp_name
			;

comp_control		: D_XDEFINE comp_name
			| D_XDEFINE comp_name QSTRING
			| D_XUNDEF comp_name
			| D_XIFDEF comp_name
			| D_XIFNDEF comp_name
			| D_XELSE
			| D_XENDIF
			| D_XINCLUDE QSTRING
			| SEMICOLON
			;

namespace_all		: namespace_head OPEN_BRACE decls CLOSE_BRACE
			{
				report.WriteWarning (Warning.LegacyNamespaceSyntax,
					"Use of legacy namespace syntax.");

				codegen.CurrentNamespace = namespace_stack.Pop ();
			}
			;

namespace_head		: D_NAMESPACE comp_name_str
			{
				namespace_stack.Push (codegen.CurrentNamespace);

				if (codegen.CurrentNamespace != string.Empty)
					codegen.CurrentNamespace += ".";

				codegen.CurrentNamespace += (string) $2;
			}
			;

class_all		: class_head OPEN_BRACE class_decls CLOSE_BRACE
			{
				// We've assembled the System.Object type; register it.
				if (codegen.IsCorlib && codegen.Corlib.Object == null &&
					codegen.CurrentType.FullName == "System.Object")
					codegen.Corlib.Object = codegen.CurrentType;

				codegen.CurrentType = null;
				codegen.CurrentGenericParameterProvider = null;
				codegen.CurrentCustomAttributeProvider = null;

				if (typedef_stack.Count > 0) {
					codegen.CurrentType = typedef_stack.Pop ();
					codegen.CurrentGenericParameterProvider = codegen.CurrentType;
				}
			}
			;

class_head		: D_CLASS class_attr comp_name
			{
				var qn = (QualifiedName) $3;
				var attr = (TypeAttributes) $2;
				var nester = codegen.CurrentType;

				if (nester != null) {
					typedef_stack.Push (nester);

					if (!attr.HasAnyBitFlag (TypeAttributes.NestedPublic) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedPrivate) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedFamily) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedAssembly) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedFamANDAssem) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedFamORAssem)) {
						report.WriteWarning (Warning.NestedTypeMadeNestedVisibility,
							"Nested type set to equivalent nested visibility.");

						if (attr.HasBitFlag (TypeAttributes.Public)) {
							attr &= ~TypeAttributes.Public;
							attr |= TypeAttributes.NestedPublic;
						} else // In the case of NotPublic.
							attr |= TypeAttributes.NestedPrivate;
					}
				}

				codegen.CurrentType = new TypeDefinition (codegen.CurrentNamespace +
					qn.FullNamespace, qn.Name, attr) {
					DeclaringType = nester,
				};

				codegen.CurrentGenericParameterProvider = codegen.CurrentType;
			}
			  formal_typars_clause
			{
				foreach (var arg in (List<GenericParameter>) $5)
					codegen.CurrentType.GenericParameters.Add (arg);
			}
			  extends_clause impl_clause
			{
				TypeReference baseType;

				// if we're assembling mscorlib and defining System.Object,
				// no base type should be defined.
				var isSysObj = codegen.IsCorlib && codegen.Corlib.Object == null &&
					codegen.CurrentType.FullName == "System.Object";

				if ($7 == null) {
					if (is_value_class)
						baseType = codegen.Corlib.ValueType;
					else if (is_enum_class)
						baseType = codegen.Corlib.Enum;
					else if (isSysObj || codegen.NoAutoInherit)
						baseType = null;
					else {
						var obj = codegen.Corlib.Object;

						if (obj == null)
							report.WriteError (Error.SystemObjectUndefined,
								"System.Object has not been defined.");

						baseType = obj;
					}
				} else {
					if (codegen.CurrentType.IsInterface)
						report.WriteError (Error.BaseClassInInterface,
							"Base type specified on an interface.");

					baseType = (TypeReference) $7;
				}

				if (isSysObj && baseType != null) {
					report.WriteWarning (Warning.SystemObjectBaseTypeReset,
						"System.Object should not have a base type; removed.");

					codegen.CurrentType.BaseType = null;
				} else
					codegen.CurrentType.BaseType = baseType;

				foreach (var interf in (List<TypeReference>) $8)
					codegen.CurrentType.Interfaces.Add (interf);

				codegen.CurrentModule.Types.Add (codegen.CurrentType);
			}
			;

class_attr		:
			{
				is_value_class = false;
				is_enum_class = false;
				type_attr_visibility_set = false;
				$$ = TypeAttributes.NotPublic;
			}
			| class_attr K_PUBLIC
			{
				if (!type_attr_visibility_set) {
					type_attr_visibility_set = true;
					$$ = (TypeAttributes) $1 | TypeAttributes.Public;
				}
			}
			| class_attr K_PRIVATE			{ type_attr_visibility_set = true; }
			// TODO: We may need to use type_attr_visibility_set for these too.
			| class_attr K_NESTED K_PRIVATE		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPrivate; }
			| class_attr K_NESTED K_PUBLIC		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPublic; }
			| class_attr K_NESTED K_FAMILY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamily; }
			| class_attr K_NESTED K_ASSEMBLY	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedAssembly;}
			| class_attr K_NESTED K_FAMANDASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamANDAssem; }
			| class_attr K_NESTED K_FAMORASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamORAssem; }
			| class_attr K_VALUE			{ is_value_class = true; }
			| class_attr K_ENUM			{ is_enum_class = true; }
			| class_attr K_INTERFACE		{ $$ = (TypeAttributes) $1 | TypeAttributes.Interface | TypeAttributes.Abstract; }
			| class_attr K_SEALED			{ $$ = (TypeAttributes) $1 | TypeAttributes.Sealed; }
			| class_attr K_ABSTRACT			{ $$ = (TypeAttributes) $1 | TypeAttributes.Abstract; }
			| class_attr K_AUTO
			| class_attr K_SEQUENTIAL		{ $$ = (TypeAttributes) $1 | TypeAttributes.SequentialLayout; }
			| class_attr K_EXPLICIT			{ $$ = (TypeAttributes) $1 | TypeAttributes.ExplicitLayout; }
			| class_attr K_ANSI
			| class_attr K_UNICODE			{ $$ = (TypeAttributes) $1 | TypeAttributes.UnicodeClass; }
			| class_attr K_AUTOCHAR			{ $$ = (TypeAttributes) $1 | TypeAttributes.AutoClass; }
			| class_attr K_IMPORT			{ $$ = (TypeAttributes) $1 | TypeAttributes.Import; }
			| class_attr K_SERIALIZABLE		{ $$ = (TypeAttributes) $1 | TypeAttributes.Serializable; }
			| class_attr K_BEFOREFIELDINIT		{ $$ = (TypeAttributes) $1 | TypeAttributes.BeforeFieldInit; }
			| class_attr K_SPECIALNAME		{ $$ = (TypeAttributes) $1 | TypeAttributes.SpecialName; }
			| class_attr K_RTSPECIALNAME		{ $$ = (TypeAttributes) $1 | TypeAttributes.RTSpecialName; }
			| class_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (TypeAttributes) $1 | (TypeAttributes) (int) $4;
			}
			;

extends_clause		:
			| K_EXTENDS type_spec
			{
				$$ = $2;
			}
			;

impl_clause		:
			{
				$$ = new List<TypeReference> ();
			}
			| impl_class_refs
			;

impl_class_refs		:
			| K_IMPLEMENTS type_spec
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $2,
				};
			}
			| impl_class_refs COMMA type_spec
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

formal_typars_clause	:
			{
				$$ = new List<GenericParameter> ();
			}
			| OPEN_ANGLE_BRACKET formal_typars CLOSE_ANGLE_BRACKET
			{
				$$ = $2;
			}
			;

formal_typars		: formal_typar_gpar
			{
				$$ = new List<GenericParameter> () {
					(GenericParameter) $1,
				};
			}
			| formal_typars COMMA formal_typar_gpar
			{
				((List<GenericParameter>) $1).Add ((GenericParameter) $3);
			}
			;

formal_typar_gpar	: formal_typar_attr constraints_clause formal_typar
			{
				var gp = new GenericParameter ((string) $3,
					codegen.CurrentGenericParameterProvider) {
					Attributes = (GenericParameterAttributes) $1,
				};

				foreach (var constraint in (List<TypeReference>) $2)
					gp.Constraints.Add (constraint);

				$$ = gp;
			}

formal_typar_attr	:
			{
				$$ = GenericParameterAttributes.NonVariant;
			}
			| formal_typar_attr PLUS	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.Covariant; }
			| formal_typar_attr DASH	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.Contravariant; }
			| formal_typar_attr D_CTOR	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.DefaultConstructorConstraint; }
			| formal_typar_attr K_VALUETYPE	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.NotNullableValueTypeConstraint; }
			| formal_typar_attr K_CLASS	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.ReferenceTypeConstraint; }
			;

formal_typar		: comp_name_str
			;

constraints_clause	:
			{
				$$ = new List<TypeReference> ();
			}
			| OPEN_PARENS constraints CLOSE_PARENS
			{
				$$ = $2;
			}
			;

constraints		: type_spec
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| constraints COMMA type_spec
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

class_decls		:
			| class_decls class_decl
			;

class_decl		: method_all
			| class_all
			| event_all
			| prop_all
			| field_decl
			| data_decl
			| sec_decl
			{
				codegen.CurrentType.SecurityDeclarations.Add (codegen.CurrentSecurityDeclaration);
				codegen.CurrentSecurityDeclaration = null;
			}
			| extsource_spec
			| customattr_decl
			{
				if ($1 != null) {
					var provider = codegen.CurrentCustomAttributeProvider != null ?
						codegen.CurrentCustomAttributeProvider : codegen.CurrentType;

					provider.CustomAttributes.Add ((CustomAttribute) $1);
					codegen.CurrentCustomAttribute = null;
				}
			}
			| param_type_decl
			| D_SIZE int32
			{
				var size = (int) $2;

				if (codegen.CurrentType.IsAutoLayout && size != -1)
					report.WriteWarning (Warning.LayoutInfoInAutoLayoutType,
						"Class layout information specified in auto-layout class.");

				codegen.CurrentType.ClassSize = size;
			}
			| D_PACK int32
			{
				if (codegen.CurrentType.IsAutoLayout)
					report.WriteWarning (Warning.LayoutInfoInAutoLayoutType,
						"Class layout information specified in auto-layout class.");

				var p = (int) $2;

				if (p < 1 || p > 128 || (p & (p - 1)) != 0)
					report.WriteError (Error.InvalidPackSize,
						"Class pack size must be a power of two between 1 and 128.");

				codegen.CurrentType.PackingSize = (short) (int) $2;
			}
			| D_OVERRIDE type_spec DOUBLE_COLON method_name K_WITH call_conv type type_spec DOUBLE_COLON method_name OPEN_PARENS sig_args CLOSE_PARENS
			{
				var conv = (MethodCallingConvention) $6;
				var retType = (TypeReference) $7;

				var overridingMethod = new MethodReference ((string) $10, retType, (TypeReference) $8) {
					CallingConvention = conv,
				};

				var baseMethod = new MethodReference ((string) $4, retType, (TypeReference) $2) {
					CallingConvention = conv,
				};

				if (is_instance_call) {
					overridingMethod.HasThis = true;
					baseMethod.HasThis = true;
				}

				if (is_explicit_call) {
					overridingMethod.ExplicitThis = true;
					baseMethod.ExplicitThis = true;
				}

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $12) {
					overridingMethod.Parameters.Add (new ParameterDefinition (arg));
					baseMethod.Parameters.Add (new ParameterDefinition (arg));
				}

				var resolvedMethod = overridingMethod.Resolve ();

				if (resolvedMethod == null)
					report.WriteError (Error.InvalidOverrideMethod,
						"Could not resolve overriding method: {0}",
						overridingMethod);

				resolvedMethod.Overrides.Add ((MethodReference) $2);
			}
			| D_OVERRIDE generic_method_ref K_WITH generic_method_ref
			{
				var overridingMethod = ((MethodReference) $4).Resolve ();

				if (overridingMethod == null)
					report.WriteError (Error.InvalidOverrideMethod,
						"Could not resolve overriding method: {0}",
						overridingMethod);

				overridingMethod.Overrides.Add ((MethodReference) $2);
			}
			| language_decl
			| comp_control
			;

param_type_decl		: D_PARAM K_TYPE id
			{
				var name = (string) $3;
				GenericParameter param = null;

				foreach (var parameter in codegen.CurrentGenericParameterProvider.GenericParameters)
					if (parameter.Name == name)
						param = parameter;

				if (param == null)
					report.WriteError (Error.InvalidGenericParameter,
						"Generic parameter '{0}' not found.", name);

				codegen.CurrentCustomAttributeProvider = param;
			}
			| D_PARAM K_TYPE OPEN_BRACKET int32 CLOSE_BRACKET
			{
				var id = (int) $4; // One-based.
				var genParams = codegen.CurrentGenericParameterProvider.GenericParameters;

				if (id <= 0 || id > genParams.Count)
					report.WriteError (Error.InvalidGenericParameter,
						"Generic parameter number '{0}' not found.", id);

				codegen.CurrentCustomAttributeProvider = genParams [id - 1];
			}
			;

class_refs		: class_ref
			{
				$$ = new List<TypeReference> {
					(TypeReference) $1,
				};
			}
			| class_refs COMMA class_ref
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

class_ref		: OPEN_BRACKET comp_name CLOSE_BRACKET slashed_name
			{
				var name = (QualifiedName) $2;
				var type = (QualifiedName) $4;
				var scope = codegen.GetScope (name.FullName, false);

				$$ = new TypeReference (type.FullNamespace, type.Name, codegen.CurrentModule, scope);
			}
			| OPEN_BRACKET mdtoken CLOSE_BRACKET slashed_name // TODO: How does this work?
			| OPEN_BRACKET STAR CLOSE_BRACKET slashed_name // TODO: How does this work?
			| OPEN_BRACKET D_MODULE comp_name_str CLOSE_BRACKET slashed_name
			{
				var module = (string) $3;
				var type = (QualifiedName) $5;

				if (module == codegen.CurrentModule.Name) {
					var typeRef = new TypeReference (type.FullNamespace,
						type.Name, codegen.CurrentModule, codegen.CurrentModule);

					codegen.ModuleTypeReferences.Add (typeRef);

					$$ = typeRef;
				} else {
					var scope = codegen.GetScope (module, true);

					$$ = new TypeReference (type.FullNamespace,
						type.Name, codegen.CurrentModule, scope);
				}
			}
			| slashed_name
			{
				var qn = (QualifiedName) $1;
				var typeRef = new TypeReference (qn.FullNamespace, qn.Name,
					codegen.CurrentModule, codegen.CurrentModule);

				codegen.ModuleTypeReferences.Add (typeRef);

				$$ = typeRef;
			}
			| mdtoken_type
			| D_THIS
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.RelativeTypeReferenceOutsideTypeDefinition,
						".this directive used outside type definition scope.");

				$$ = codegen.CurrentType;
			}
			| D_BASE
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.RelativeTypeReferenceOutsideTypeDefinition,
						".base directive used outside type definition scope.");

				var baseType = codegen.CurrentType.BaseType;

				if (baseType == null)
					report.WriteError (Error.NoBaseType,
						"Type has no base type.");

				$$ = baseType;
			}
			| D_NESTER
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.RelativeTypeReferenceOutsideTypeDefinition,
						".nester directive used outside type definition scope.");

				var nester = codegen.CurrentType.DeclaringType;

				if (nester == null)
					report.WriteError (Error.NoDeclaringType,
						"Type has no declaring type.");

				$$ = nester;
			}
			;

mdtoken_type		: mdtoken
			{
				$$ = codegen.GetTypeByMetadataToken ((int) $1);
			}
			;

type			: K_CLASS class_ref
			{
				$$ = $2;
			}
			| K_VALUE K_CLASS class_ref
			{
				$$ = $3;
			}
			| K_VALUETYPE class_ref
			{
				$$ = $2;
			}
			| type OPEN_BRACKET CLOSE_BRACKET
			{
				$$ = new ArrayType ((TypeReference) $1);
			}
			| type OPEN_BRACKET bounds CLOSE_BRACKET
			{
				var bounds = (List<ArrayDimension>) $3;
				var type = new ArrayType ((TypeReference) $1, bounds.Count);

				for (var i = 0; i < bounds.Count; i++)
					type.Dimensions [i] = bounds [i];

				$$ = type;
			}
			| type AMPERSAND
			{
				$$ = new ByReferenceType ((TypeReference) $1);
			}
			| type STAR
			{
				$$ = new PointerType ((TypeReference) $1);
			}
			| type K_PINNED
			{
				$$ = new PinnedType ((TypeReference) $1);
			}
			| type K_MODREQ OPEN_PARENS type_spec CLOSE_PARENS
			{
				$$ = new RequiredModifierType ((TypeReference) $4, (TypeReference) $1);
			}
			| type K_MODOPT OPEN_PARENS type_spec CLOSE_PARENS
			{
				$$ = new OptionalModifierType ((TypeReference) $4, (TypeReference) $1);
			}
			| K_METHOD call_conv type STAR OPEN_PARENS sig_args CLOSE_PARENS
			{
				var func = new FunctionPointerType {
					CallingConvention = (MethodCallingConvention) $2,
					ReturnType = (TypeReference) $3,
				};

				if (is_instance_call)
					func.HasThis = true;

				if (is_explicit_call)
					func.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<ParameterDefinition>) $6)
					func.Parameters.Add (arg);

				$$ = func;
			}
			| type typars_clause
			{
				var typeArgs = (List<TypeReference>) $2;

				if (typeArgs.Count > 0) {
					var gti = new GenericInstanceType ((TypeReference) $1);

					foreach (var ga in typeArgs)
						gti.GenericArguments.Add (ga);

					$$ = gti;
				}
			}
			| BANG int32
			{
				var pos = (int) $2;

				if (!generic_typeref_in_field)
					$$ = GetGenericParameter (codegen.CurrentType, pos);
				else {
					GenericParameter cachedGp = null;

					for (var i = 0; i < dummy_type.GenericParameters.Count; i++)
						if (i == pos)
							if ((cachedGp = dummy_type.GenericParameters [i]) != null)
								break;

					if (cachedGp == null) {
						if (pos >= dummy_type.GenericParameters.Count)
							dummy_type.GenericParameters.NullResize (pos + 1);

						var gp = new GenericParameter (dummy_type);
						dummy_type.GenericParameters [pos] = gp;

						$$ = gp;
					} else
						$$ = cachedGp;
				}
			}
			| BANG id
			{
				$$ = GetGenericParameter (codegen.CurrentType, (string) $2);
			}
			| BANG BANG int32
			{
				var pos = (int) $3;

				if (!generic_typeref_in_method)
					$$ = GetGenericParameter (codegen.CurrentMethod, pos);
				else {
					GenericParameter cachedGp = null;

					for (var i = 0; i < dummy_method.GenericParameters.Count; i++)
						if (i == pos)
							if ((cachedGp = dummy_method.GenericParameters [i]) != null)
								break;

					if (cachedGp == null) {
						if (pos >= dummy_method.GenericParameters.Count)
							dummy_method.GenericParameters.NullResize (pos + 1);

						var gp = new GenericParameter (dummy_method);
						dummy_method.GenericParameters [pos] = gp;

						$$ = gp;
					} else
						$$ = cachedGp;
				}
			}
			| BANG BANG id
			{
				var name = (string) $3;

				if (!generic_typeref_in_methoddef)
					$$ = GetGenericParameter (codegen.CurrentMethod, name);
				else {
					GenericParameter cachedGp = null;

					foreach (var genParam in dummy_method.GenericParameters)
						if (genParam.Name == name)
							if ((cachedGp = genParam) != null)
								break;

					if (cachedGp == null) {
						var gp = new GenericParameter (name, dummy_method);
						dummy_method.GenericParameters.Add (gp);

						$$ = gp;
					} else
						$$ = cachedGp;
				}
			}
			| K_OBJECT
			{
				var obj = codegen.Corlib.Object;

				if (obj == null)
					report.WriteError (Error.SystemObjectUndefined,
						"System.Object has not been defined.");

				$$ = obj;
			}
			| K_VOID			{ $$ = codegen.Corlib.Void; }
			| K_TYPEDREF			{ $$ = codegen.Corlib.TypedReference; }
			| K_NATIVE K_INT		{ $$ = codegen.Corlib.IntPtr; }
			| K_NATIVE K_UNSIGNED K_INT	{ $$ = codegen.Corlib.UIntPtr; }
			| K_NATIVE K_UINT		{ $$ = codegen.Corlib.UIntPtr; }
			| K_NATIVE K_FLOAT		{ $$ = codegen.Corlib.Single; }
			| simple_type
			| ELLIPSIS type
			{
				$$ = new SentinelType ((TypeReference) $2);
			}
			;

unsigned_int8		: K_UINT8
			| K_UNSIGNED K_INT8
			;

unsigned_int16		: K_UINT16
			| K_UNSIGNED K_INT16
			;

unsigned_int32		: K_UINT32
			| K_UNSIGNED K_INT32
			;

unsigned_int64		: K_UINT64
			| K_UNSIGNED K_INT64
			;

int_type		: K_INT8			{ $$ = codegen.Corlib.SByte; }
			| K_INT16			{ $$ = codegen.Corlib.Int16; }
			| K_INT32			{ $$ = codegen.Corlib.Int32; }
			| K_INT64			{ $$ = codegen.Corlib.Int64; }
			| unsigned_int8			{ $$ = codegen.Corlib.Byte; }
			| unsigned_int16		{ $$ = codegen.Corlib.UInt16; }
			| unsigned_int32		{ $$ = codegen.Corlib.UInt32; }
			| unsigned_int64		{ $$ = codegen.Corlib.UInt64; }

simple_type		: K_FLOAT32			{ $$ = codegen.Corlib.Single; }
			| K_FLOAT64			{ $$ = codegen.Corlib.Double; }
			| K_CHAR			{ $$ = codegen.Corlib.Char; }
			| K_BOOL			{ $$ = codegen.Corlib.Boolean; }
			| K_STRING			{ $$ = codegen.Corlib.String; }
			| int_type
			;

typars_clause_opt	:
			| typars_clause
			;

typars_clause		: OPEN_ANGLE_BRACKET typars CLOSE_ANGLE_BRACKET
			{
				$$ = $2;
			}
			;

typars			: type
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| typars COMMA type
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

type_spec		: class_ref
			| OPEN_BRACKET comp_name CLOSE_BRACKET // TODO: What do we do with this?
			| OPEN_BRACKET D_MODULE comp_name_str CLOSE_BRACKET
			{
				var module = (string) $3;

				if (module == codegen.CurrentModule.Name)
					$$ = codegen.CurrentModule.GetModuleType ();
				else {
					var mod = codegen.GetModuleReference (module);

					if (mod == null)
						report.WriteError (Error.UndeclaredModuleReference,
							"Use of undeclared module: {0}", module);

					$$ = new TypeReference (string.Empty, "<Module>",
						codegen.CurrentModule, mod);
				}
			}
			| type
			;

bounds			: bound
			{
				$$ = new List<ArrayDimension> {
					(ArrayDimension) $1,
				};
			}
			| bounds COMMA bound
			{
				((List<ArrayDimension>) $1).Add ((ArrayDimension) $3);
			}
			;

bound			:
			{
				$$ = new ArrayDimension (null, null);
			}
			| ELLIPSIS
			{
				$$ = new ArrayDimension (null, null);
			}
			| int32
			{
				var size = (int) $1;

				if (size < 0) {
					report.WriteWarning (Warning.NegativeArraySize,
						"Negative array size '{0}' set to 0.", size);

					$$ = new ArrayDimension (0, 0);
				} else
					$$ = new ArrayDimension (0, size);
			}
			| int32 ELLIPSIS int32
			{
				var lower = (int) $1;
				var upper = (int) $3;

				$$ = new ArrayDimension (lower, upper);
			}
			| int32 ELLIPSIS
			{
				$$ = new ArrayDimension ((int) $1, null);
			}
			;

call_conv		: K_INSTANCE call_conv { is_instance_call = true; $$ = $2 ?? MethodCallingConvention.Default; }
			| K_EXPLICIT call_conv { is_explicit_call = true; $$ = $2 ?? MethodCallingConvention.Default; }
			| call_kind
			| K_CALLCONV OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (MethodCallingConvention) $3;
			}
			;

call_kind		:
			{
				$$ = MethodCallingConvention.Default;
			}
			| K_DEFAULT			{ $$ = MethodCallingConvention.Default; }
			| K_VARARG			{ $$ = MethodCallingConvention.VarArg; }
			| K_UNMANAGED K_CDECL		{ $$ = MethodCallingConvention.C; }
			| K_UNMANAGED K_STDCALL		{ $$ = MethodCallingConvention.StdCall; }
			| K_UNMANAGED K_THISCALL	{ $$ = MethodCallingConvention.ThisCall; }
			| K_UNMANAGED K_FASTCALL	{ $$ = MethodCallingConvention.FastCall; }
			;

marshal_info		:
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring CLOSE_PARENS
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring COMMA comp_qstring COMMA comp_qstring CLOSE_PARENS
			| K_FIXED K_SYSSTRING OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new FixedSysStringMarshalInfo {
					Size = (int) $4,
				};
			}
			| K_FIXED K_ARRAY OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new FixedArrayMarshalInfo {
					Size = (int) $4,
				};
			}
			| marshal_type STAR
			{
				report.WriteWarning (Warning.DeprecatedNativeType,
					"Pointer syntax for native types is deprecated.");

				// Emit an invalid native type. Don't ask me how this works;
				// blame Microsoft's ILAsm.
				$$ = new MarshalInfo ((NativeType) 0);
			}
			| marshal_type OPEN_BRACKET CLOSE_BRACKET
			{
				// This is not Microsoft-compatible. I have no idea how they
				// calculate the values they emit for jagged arrays.
				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
				};
			}
			| marshal_type OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					Size = (int) $3,
				};
			}
			| marshal_type OPEN_BRACKET int32 PLUS int32 CLOSE_BRACKET
			{
				is_parameter_marshal_notation = true;

				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					Size = (int) $3,
					SizeParameterMultiplier = (int) $5,
				};
			}
			| marshal_type OPEN_BRACKET PLUS int32 CLOSE_BRACKET
			{
				is_parameter_marshal_notation = true;

				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					SizeParameterMultiplier = (int) $4,
				};
			}
			| K_SAFEARRAY variant_type
			{
				$$ = new SafeArrayMarshalInfo {
					ElementType = (VariantType) $2,
				};
			}
			| marshal_type
			{
				$$ = new MarshalInfo ((NativeType) $1);
			}
			;

unsigned_int		: K_UINT
			| K_UNSIGNED K_INT
			;

marshal_type		: K_CURRENCY				{ $$ = NativeType.Currency; }
			| K_BOOL				{ $$ = NativeType.Boolean; }
			| K_INT8				{ $$ = NativeType.I1; }
			| K_INT16				{ $$ = NativeType.I2; }
			| K_INT32				{ $$ = NativeType.I4; }
			| K_INT64				{ $$ = NativeType.I8; }
			| K_FLOAT32				{ $$ = NativeType.R4; }
			| K_FLOAT64				{ $$ = NativeType.R8; }
			| K_ERROR				{ $$ = NativeType.Error; }
			| unsigned_int8				{ $$ = NativeType.U1; }
			| unsigned_int16			{ $$ = NativeType.U2; }
			| unsigned_int32			{ $$ = NativeType.U4; }
			| unsigned_int64			{ $$ = NativeType.U8; }
			| K_BSTR				{ $$ = NativeType.BStr; }
			| K_LPSTR				{ $$ = NativeType.LPStr; }
			| K_LPWSTR				{ $$ = NativeType.LPWStr; }
			| K_LPTSTR				{ $$ = NativeType.LPTStr; }
			| K_IUNKNOWN				{ $$ = NativeType.IUnknown; }
			| K_IDISPATCH				{ $$ = NativeType.IDispatch; }
			| K_STRUCT				{ $$ = NativeType.Struct; }
			| K_INTERFACE				{ $$ = NativeType.IntF; }
			| K_INT					{ $$ = NativeType.Int; }
			| unsigned_int				{ $$ = NativeType.UInt; }
			| K_BYVALSTR				{ $$ = NativeType.ByValStr; }
			| K_ANSI K_BSTR				{ $$ = NativeType.ANSIBStr; }
			| K_TBSTR				{ $$ = NativeType.TBStr; }
			| K_VARIANT K_BOOL			{ $$ = NativeType.VariantBool; }
			| K_METHOD				{ $$ = NativeType.Func; }
			| K_AS K_ANY				{ $$ = NativeType.ASAny; }
			| K_LPSTRUCT				{ $$ = NativeType.LPStruct; }
			| native_type
			{
				// The grammar supports these types, but we can't
				// actually use them.
				report.WriteError(Error.UnsupportedNativeType,
					"Unsupported native type used in marshaling signature.");
			}
			;

native_type		: K_VARIANT
			| K_VOID
			| K_SYSCHAR
			| K_DECIMAL
			| K_DATE
			| K_OBJECTREF
			| K_NESTED K_STRUCT
			;

safearray_type		: K_VARIANT		{ $$ = VariantType.Variant; }
			| K_CURRENCY		{ $$ = VariantType.CY; }
			| K_BOOL		{ $$ = VariantType.Bool; }
			| K_INT8		{ $$ = VariantType.I1; }
			| K_INT16		{ $$ = VariantType.I2; }
			| K_INT32		{ $$ = VariantType.I4; }
			| K_FLOAT32		{ $$ = VariantType.R4; }
			| K_FLOAT64		{ $$ = VariantType.R8; }
			| unsigned_int8		{ $$ = VariantType.UI1; }
			| unsigned_int16	{ $$ = VariantType.UI2; }
			| unsigned_int32	{ $$ = VariantType.UI4; }
			| K_DECIMAL		{ $$ = VariantType.Decimal; }
			| K_DATE		{ $$ = VariantType.Date; }
			| K_BSTR		{ $$ = VariantType.BStr; }
			| K_IUNKNOWN		{ $$ = VariantType.Unknown; }
			| K_IDISPATCH		{ $$ = VariantType.Dispatch; }
			| K_INT 		{ $$ = VariantType.Int; }
			| unsigned_int		{ $$ = VariantType.UInt; }
			| K_ERROR		{ $$ = VariantType.Error; }
			| variant_type
			{
				// The grammar supports these types, but we can't
				// actually use them.
				report.WriteError(Error.UnsupportedVariantType,
					"Unsupported variant type used in safe array signature.");
			}
			;

variant_type		: K_NULL
			| K_VOID
			| K_INT64
			| unsigned_int64
			| STAR
			| variant_type OPEN_BRACKET CLOSE_BRACKET
			| variant_type K_VECTOR
			| variant_type AMPERSAND
			| K_LPSTR
			| K_LPWSTR
			| K_SAFEARRAY
			| K_HRESULT
			| K_CARRAY
			| K_USERDEFINED
			| K_RECORD
			| K_FILETIME
			| K_BLOB
			| K_STREAM
			| K_STORAGE
			| K_STREAMED_OBJECT
			| K_STORED_OBJECT
			| K_BLOB_OBJECT
			| K_CF
			| K_CLSID
			;

field_decl		: D_FIELD repeat_opt field_attr marshal_spec type id at_opt init_opt
			{
				var isGlobal = codegen.CurrentType == null;
				var attrs = (FieldAttributes) $3;
				var isStatic = attrs.HasBitFlag(FieldAttributes.Static);

				if (isGlobal && !isStatic)
				{
					attrs |= FieldAttributes.Static;

					report.WriteWarning (Warning.GlobalFieldMadeStatic,
						"Global field made static.");
				}

				var field = new FieldDefinition((string) $6, attrs, (TypeReference) $5);

				if ($2 != null) {
					if (!isGlobal)
						field.Offset = (int) $2;
					else
						report.WriteWarning (Warning.GlobalFieldOffsetIgnored,
							"Offset for global field ignored.");
				}

				if ($4 != null) {
					if (is_parameter_marshal_notation) {
						// TODO: This warning should be emitted more closely to the relevant code.
						report.WriteWarning (Warning.ParameterMarshalNotationOnField,
							"Invalid use of parameter array marshal notation on a field.");

						is_parameter_marshal_notation = false;
					}

					field.MarshalInfo = (MarshalInfo) $4;
				}

				if ($7 != null) {
					if (!isStatic)
						report.WriteError (Error.InstanceFieldWithDataLocation,
							"Instance fields cannot have an associated data location.");

					var dataLoc = (string) $7;
					var mapping = codegen.GetFieldDataMapping (codegen.CurrentType ?? codegen.CurrentModule.GetModuleType ());
					mapping.Add (field, dataLoc);
				}

				if ($8 != null)
					field.Constant = $8 is Null ? null : $8;

				if (isGlobal)
					codegen.CurrentModule.GetModuleType ().Fields.Add (field);
				else
					codegen.CurrentType.Fields.Add (field);
			}
			;

repeat_opt		:
			| OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = $2;
			}
			;

field_attr		:
			{
				$$ = FieldAttributes.CompilerControlled;
			}
			| field_attr K_PUBLIC		{ $$ = (FieldAttributes) $1 | FieldAttributes.Public; }
			| field_attr K_PRIVATE		{ $$ = (FieldAttributes) $1 | FieldAttributes.Private; }
			| field_attr K_FAMILY		{ $$ = (FieldAttributes) $1 | FieldAttributes.Family; }
			| field_attr K_ASSEMBLY		{ $$ = (FieldAttributes) $1 | FieldAttributes.Assembly; }
			| field_attr K_FAMANDASSEM	{ $$ = (FieldAttributes) $1 | FieldAttributes.FamANDAssem; }
			| field_attr K_FAMORASSEM	{ $$ = (FieldAttributes) $1 | FieldAttributes.FamORAssem; }
			| field_attr K_PRIVATESCOPE
			| field_attr K_STATIC		{ $$ = (FieldAttributes) $1 | FieldAttributes.Static; }
			| field_attr K_INITONLY		{ $$ = (FieldAttributes) $1 | FieldAttributes.InitOnly; }
			| field_attr K_RTSPECIALNAME	{ $$ = (FieldAttributes) $1 | FieldAttributes.RTSpecialName; }
			| field_attr K_SPECIALNAME	{ $$ = (FieldAttributes) $1 | FieldAttributes.SpecialName; }
			| field_attr K_LITERAL		{ $$ = (FieldAttributes) $1 | FieldAttributes.Literal; }
			| field_attr K_NOTSERIALIZED	{ $$ = (FieldAttributes) $1 | FieldAttributes.NotSerialized; }
			;

marshal_spec		:
			| K_MARSHAL OPEN_PARENS marshal_info CLOSE_PARENS
			{
				$$ = $3;
			}
			;

at_opt			:
			| K_AT id
			{
				$$ = $2;
			}
			;

init_opt		:
			| ASSIGN field_init
			{
				$$ = $2;
			}
			;

field_init_primitive	: K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = (float) (double) $3;
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_FLOAT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = BitConverter.ToSingle (BitConverter.GetBytes ((long) $3), BitConverter.IsLittleEndian ? 0 : 4);
			}
			| K_FLOAT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = BitConverter.Int64BitsToDouble ((long) $3);
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = $3;
			}
			| unsigned_int64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (ulong) (long) $3;
			}
			| K_INT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (int) (long) $3;
			}
			| unsigned_int32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (uint) (long) $3;
			}
			| K_INT16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (short) (long) $3;
			}
			| unsigned_int16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (ushort) (long) $3;
			}
			| K_INT8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (sbyte) (long) $3;
			}
			| unsigned_int8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (byte) (long) $3;
			}
			| K_CHAR OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (char) (long) $3;
			}
			| K_BOOL OPEN_PARENS truefalse CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			;

field_init		: field_init_primitive
			| comp_qstring
			| K_NULLREF
			{
				$$ = new Null ();
			}
			;

data_decl		: data_head data_body
			{
				if ($1 != null)
				{
					foreach (var item in (List<object>) $2)
						codegen.DataConstants.Add ((string) $1, item);

					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Data constants are currently just copied to static fields.");
				}
				else
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Unlabeled data constants currently have no effect.");
			}
			;

data_name		:
			| id ASSIGN
			;

data_head		: D_DATA tls cil data_name
			{
				if ((bool) $2)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"TLS data constants are not currently supported.");

				if ((bool) $3)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"CIL data constants are not currently supported.");

				$$ = $4;
			}
			;

tls			:
			{
				$$ = false;
			}
			| K_TLS
			{
				$$ = true;
			}
			;

cil			:
			{
				$$ = false;
			}
			| K_CIL
			{
				$$ = true;
			}
			;

data_body		: OPEN_BRACE dataitem_list CLOSE_BRACE
			{
				$$ = $2;
			}
			| dataitem
			{
				$$ = new List<object> {
					$1,
				};
			}
			;

dataitem_list		: dataitem
			{
				$$ = new List<object> {
					$1,
				};
			}
			| dataitem_list COMMA dataitem
			{
				((List<object>) $1).Add ($3);
			}
			;

data_repeat_opt		: repeat_opt
			{
				if ($1 != null)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Repeated data constants currently have no effect.");
			}
			;

dataitem		: K_CHAR STAR OPEN_PARENS comp_qstring CLOSE_PARENS
			{
				$$ = $4;
			}
			| AMPERSAND OPEN_PARENS id CLOSE_PARENS
			{
				$$ = IntPtr.Zero;
			}
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			| K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS data_repeat_opt
			{
				$$ = (float) (double) $3;
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_INT32 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_INT16 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = (short) (int) $3;
			}
			| K_INT8 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = (byte) (int) $3;
			}
			| K_FLOAT32 data_repeat_opt
			{
				$$ = 0.0f;
			}
			| K_FLOAT64 data_repeat_opt
			{
				$$ = 0.0d;
			}
			| K_INT64 data_repeat_opt
			{
				$$ = (long) 0;
			}
			| K_INT32 data_repeat_opt
			{
				$$ = (int) 0;
			}
			| K_INT16 data_repeat_opt
			{
				$$ = (short) 0;
			}
			| K_INT8 data_repeat_opt
			{
				$$ = (byte) 0;
			}
			;

method_all		: method_head OPEN_BRACE method_decls CLOSE_BRACE
			{
				// If the method has no code, we emit a ret.
				if (il.Body.Instructions.Count == 0 &&
					!codegen.CurrentMethod.IsAbstract) {
					report.WriteWarning (Warning.DefaultReturnEmitted,
						"Method has no body; ret emitted.");

					il.Emit (OpCodes.Ret);
				} else {
					// We need to adjust the end instruction of exception
					// handlers and their protected regions.
					foreach (var handler in il.Body.ExceptionHandlers) {
						if (handler.TryEnd != null)
							handler.TryEnd = handler.TryEnd.Next;

						if (handler.HandlerEnd != null)
							handler.HandlerEnd = handler.HandlerEnd.Next;
					}

					// Go over all branching instructions and attempt to map
					// them to a label. If we can't find a label, we error.
					foreach (var jump in label_jumps) {
						if (jump.Value is List<object>) {
							var jumpLabels = new List<Instruction> ();

							foreach (var obj in (List<object>) jump.Value) {
								if (obj is int)
									jumpLabels.Add (FindInstruction ((int) obj));
								else
									jumpLabels.Add (FindInstruction ((string) obj));
							}

							jump.Key.Operand = jumpLabels.ToArray ();
						} else {
							Instruction target;

							if (jump.Value is int)
								target = FindInstruction ((int) jump.Value);
							else
								target = FindInstruction ((string) jump.Value);

							jump.Key.Operand = target;
						}
					}
				}

				codegen.CurrentMethod = null;
				codegen.CurrentScope = null;
				codegen.CurrentCustomAttributeProvider = null;
				codegen.CurrentGenericParameterProvider = codegen.CurrentType;
				il = null;

				current_labels.Clear ();
				labels.Clear ();
				label_jumps.Clear ();
			}
			;

method_head		: D_METHOD
			{
				// This is some dirty hackery because we can't verify the
				// validity of the generic parameter (!!T syntax) for the
				// return type until we get further into the method def.
				generic_typeref_in_methoddef = true;
			}
			  meth_attr call_conv param_attr type sig_marshal_clause method_name
			{
				generic_typeref_in_methoddef = false;

				var name = (string) $8;
				var attr = (MethodAttributes) $3;
				var isClassMember = codegen.CurrentType != null;

				if (isClassMember) {
					if (!codegen.CurrentType.IsAbstract &&
						attr.HasBitFlag (MethodAttributes.Abstract))
						report.WriteError (Error.AbstractMethodInNonAbstractClass,
							"Abstract method in non-abstract class.");

					if (codegen.CurrentType.IsInterface &&
						!attr.HasBitFlag (MethodAttributes.Public))
						report.WriteError (Error.NonPublicMethodInInterface,
							"Non-public method in interface.");

					if (codegen.CurrentType.IsInterface &&
						!attr.HasBitFlag (MethodAttributes.Abstract) &&
						!attr.HasBitFlag (MethodAttributes.Virtual) &&
						!attr.HasBitFlag (MethodAttributes.Static)) {
						report.WriteWarning (Warning.NonVirtualMethodInInterface,
							"Non-abstract/non-virtual method in interface; set to such.");

						attr |= MethodAttributes.Abstract | MethodAttributes.Virtual;
					}
				}

				var method = new MethodDefinition (name, attr, (TypeReference) $6) {
					CallingConvention = (MethodCallingConvention) $4,
				};

				// Even though this doesn't make much sense, we have to
				// do it in order to be compatible.
				if (!method.HasBody)
					method.Body = new MethodBody (method);

				method.Body.Scope = new Scope ();

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				if (isClassMember)
					method.DeclaringType = codegen.CurrentType;

				if (codegen.CurrentPInvokeInfo != null) {
					if (codegen.GetModuleReference (pinvoke_mod_name) != null) {
						var module = codegen.GetModuleReference (pinvoke_mod_name);

						if (module == null) {
							module = new ModuleReference (pinvoke_mod_name);
							codegen.CurrentModule.ModuleReferences.Add (module);
						}

						codegen.CurrentPInvokeInfo.Module = module;
						pinvoke_mod_name = null;
					}

					if (codegen.CurrentPInvokeInfo.EntryPoint == null)
						codegen.CurrentPInvokeInfo.EntryPoint = name;

					method.PInvokeInfo = codegen.CurrentPInvokeInfo;
					codegen.CurrentPInvokeInfo = null;
				}

				// TODO: We can't do this with Cecil currently.
				//method.MethodReturnType.Attributes = (ParameterAttributes) $5;

				method.MethodReturnType.MarshalInfo = $7 != null ? (MarshalInfo) $7 : null;

				codegen.CurrentMethod = method;
				codegen.CurrentGenericParameterProvider = method;
			}
			  formal_typars_clause
			{
				foreach (var arg in (List<GenericParameter>) $10)
					codegen.CurrentMethod.GenericParameters.Add (arg);

				generic_typeref_in_methoddef = true;
			}
			  OPEN_PARENS sig_args CLOSE_PARENS impl_attr
			{
				generic_typeref_in_methoddef = false;

				foreach (var arg in (List<ParameterDefinition>) $13)
					codegen.CurrentMethod.Parameters.Add (arg);

				for (var i = 0; i < dummy_method.GenericParameters.Count; i++) {
					var genParam = dummy_method.GenericParameters [i];
					GetGenericParameter (codegen.CurrentMethod, genParam.Name);

					codegen.CurrentMethod.GenericParameters [i] = genParam;
				}

				ResetDummyMethod ();

				codegen.CurrentMethod.ImplAttributes = (MethodImplAttributes) $15;

				codegen.CurrentScope = codegen.CurrentMethod.Body.Scope;

				il = codegen.CurrentMethod.Body.GetILProcessor ();

				if (codegen.CurrentType != null)
					codegen.CurrentType.Methods.Add (codegen.CurrentMethod);
				else
					codegen.CurrentModule.GetModuleType ().Methods.Add (codegen.CurrentMethod);
			}
			;

meth_attr		:
			{
				$$ = MethodAttributes.CompilerControlled;
			}
			| meth_attr K_STATIC			{ $$ = (MethodAttributes) $1 | MethodAttributes.Static; }
			| meth_attr K_PUBLIC			{ $$ = (MethodAttributes) $1 | MethodAttributes.Public; }
			| meth_attr K_PRIVATE			{ $$ = (MethodAttributes) $1 | MethodAttributes.Private; }
			| meth_attr K_FAMILY			{ $$ = (MethodAttributes) $1 | MethodAttributes.Family; }
			| meth_attr K_ASSEMBLY			{ $$ = (MethodAttributes) $1 | MethodAttributes.Assembly; }
			| meth_attr K_FAMANDASSEM		{ $$ = (MethodAttributes) $1 | MethodAttributes.FamANDAssem; } 
			| meth_attr K_FAMORASSEM		{ $$ = (MethodAttributes) $1 | MethodAttributes.FamORAssem; } 
			| meth_attr K_PRIVATESCOPE
			| meth_attr K_FINAL			{ $$ = (MethodAttributes) $1 | MethodAttributes.Final; } 
			| meth_attr K_VIRTUAL			{ $$ = (MethodAttributes) $1 | MethodAttributes.Virtual; }
			| meth_attr K_ABSTRACT			{ $$ = (MethodAttributes) $1 | MethodAttributes.Abstract; }
			| meth_attr K_HIDEBYSIG			{ $$ = (MethodAttributes) $1 | MethodAttributes.HideBySig; }
			| meth_attr K_NEWSLOT			{ $$ = (MethodAttributes) $1 | MethodAttributes.NewSlot; }
			| meth_attr K_REQSECOBJ			{ $$ = (MethodAttributes) $1 | MethodAttributes.RequireSecObject; }
			| meth_attr K_SPECIALNAME		{ $$ = (MethodAttributes) $1 | MethodAttributes.SpecialName; }
			| meth_attr K_RTSPECIALNAME		{ $$ = (MethodAttributes) $1 | MethodAttributes.RTSpecialName; }
			| meth_attr K_STRICT			{ $$ = (MethodAttributes) $1 | MethodAttributes.CheckAccessOnOverride; }
			| meth_attr K_COMPILERCONTROLLED
			| meth_attr K_UNMANAGEDEXP
			| meth_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (MethodAttributes) $1 | (MethodAttributes) (int) $4;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring K_AS comp_qstring pinv_attr CLOSE_PARENS
			{
				codegen.CurrentPInvokeInfo = new PInvokeInfo ((PInvokeAttributes) $7, (string) $6, null);
				pinvoke_mod_name = (string) $4;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring pinv_attr CLOSE_PARENS
			{
				codegen.CurrentPInvokeInfo = new PInvokeInfo ((PInvokeAttributes) $5, null, null);
				pinvoke_mod_name = (string) $4;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS pinv_attr CLOSE_PARENS
			{
				report.WriteError (Error.NativeCodeUnsupported,
					"Cannot compile embedded native code.");
			}
			;

pinv_attr		:
			{
				$$ = PInvokeAttributes.CharSetNotSpec;
			}
			| pinv_attr K_NOMANGLE			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.NoMangle; }
			| pinv_attr K_ANSI			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CharSetAnsi; }
			| pinv_attr K_UNICODE			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CharSetUnicode; }
			| pinv_attr K_AUTOCHAR			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CharSetAuto; }
			| pinv_attr K_LASTERR			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.SupportsLastError; }
			| pinv_attr K_WINAPI			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvWinapi; }
			| pinv_attr K_PLATFORMAPI		{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvWinapi; }
			| pinv_attr K_CDECL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvCdecl; }
			| pinv_attr K_STDCALL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvStdCall; }
			| pinv_attr K_THISCALL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvThiscall; }
			| pinv_attr K_FASTCALL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvFastcall; }
			| pinv_attr K_BESTFIT COLON K_ON	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.BestFitEnabled; }
			| pinv_attr K_BESTFIT COLON K_OFF	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.BestFitDisabled; }
			| pinv_attr K_CHARMAPERROR COLON K_ON	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.ThrowOnUnmappableCharEnabled; }
			| pinv_attr K_CHARMAPERROR COLON K_OFF	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.ThrowOnUnmappableCharDisabled; }
			| pinv_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (PInvokeAttributes) $1 | (PInvokeAttributes) (int) $4;
			}
			;

impl_attr		:
			{
				$$ = MethodImplAttributes.Managed;
			}
			| impl_attr K_NATIVE
			{
				report.WriteError (Error.NativeCodeUnsupported,
					"Cannot compile native code.");
			}
			| impl_attr K_CIL		{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.IL; }
			| impl_attr K_IL		{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.IL; }
			| impl_attr K_OPTIL		{ /*$$ = (MethodImplAttributes) $1 | MethodImplAttributes.OPTIL;*/ }
			| impl_attr K_MANAGED
			| impl_attr K_UNMANAGED
			{
				report.WriteError (Error.NativeCodeUnsupported,
					"Cannot compile unmanaged code.");
			}
			| impl_attr K_FORWARDREF	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.ForwardRef; }
			| impl_attr K_PRESERVESIG	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.PreserveSig; }
			| impl_attr K_RUNTIME		{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.Runtime; }
			| impl_attr K_INTERNALCALL	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.InternalCall; }
			| impl_attr K_SYNCHRONIZED	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.Synchronized; }
			| impl_attr K_NOINLINING	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.NoInlining; }
			| impl_attr K_NOOPTIMIZATION	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.NoOptimization; }
			;

param_attr		:
			{
				$$ = ParameterAttributes.None;
			}
			| param_attr OPEN_BRACKET K_IN CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.In; }
			| param_attr OPEN_BRACKET K_OUT CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.Out; }
			| param_attr OPEN_BRACKET K_OPT CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.Optional; }
			| param_attr OPEN_BRACKET int32 CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | (ParameterAttributes) (int) $3; }
			;

sig_args		:
			{
				$$ = new List<ParameterDefinition> ();
			}
			| sig_arg_list
			;

sig_arg_list 		: sig_arg
			{
				$$ = new List<ParameterDefinition> {
					(ParameterDefinition) $1,
				};
			}
			| sig_arg_list COMMA sig_arg
			{
				((List<ParameterDefinition>) $1).Add ((ParameterDefinition) $3);
			}
			;

sig_marshal_clause	:
			| K_MARSHAL OPEN_PARENS marshal_type CLOSE_PARENS
			{
				$$ = new MarshalInfo ((NativeType) $3);
			}
			;

sig_arg			: ELLIPSIS // TODO: Construct the sentinel type...
			| param_attr type sig_marshal_clause
			{
				$$ = new ParameterDefinition ((TypeReference) $2) {
					Attributes = (ParameterAttributes) $1,
					MarshalInfo = $3 != null ? (MarshalInfo) $3 : null,
				};
			}
			| param_attr type sig_marshal_clause id
			{
				$$ = new ParameterDefinition ((string) $4, (ParameterAttributes) $1,
					(TypeReference) $2) {
					MarshalInfo = $3 != null ? (MarshalInfo) $3 : null,
				};
			}
			;

method_decls		:
			| method_decls method_decl
			;

method_decl		: D_EMITBYTE int32 // TODO: Cecil doesn't support this.
			| D_MAXSTACK int32
			{
				il.Body.MaxStackSize = (int) $2;
			}
			| D_LOCALS OPEN_PARENS sig_args CLOSE_PARENS
			{
				foreach (var param in (List<ParameterDefinition>) $3) {
					var variable = new VariableDefinition (param.Name, param.ParameterType);

					il.Body.Variables.Add (variable);
					codegen.CurrentScope.Variables.Add (variable);
				}
			}
			| D_LOCALS K_INIT OPEN_PARENS sig_args CLOSE_PARENS
			{
				foreach (var param in (List<ParameterDefinition>) $4) {
					var variable = new VariableDefinition (param.Name, param.ParameterType);

					il.Body.Variables.Add (variable);
					codegen.CurrentScope.Variables.Add (variable);
				}

				il.Body.InitLocals = true;
			}
			| D_ENTRYPOINT
			{
				if (codegen.CurrentModule.EntryPoint != null)
					report.WriteError (Error.MultipleEntryPoints,
						"Multiple .entrypoint directives.");

				// FIXME: Cecil doesn't preserve the entry point if the
				// module is not compiled as an executable.
				codegen.CurrentModule.EntryPoint = codegen.CurrentMethod;
			}
			| D_ZEROINIT
			{
				il.Body.InitLocals = true;
			}
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET // TODO: How do we deal with this?
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET K_AS id
			| D_VTENTRY int32 COLON int32
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtentry is currently unimplemented (directive ignored).");
			}
			| D_OVERRIDE type_spec DOUBLE_COLON method_name
			{
				var overridenMethod = new MethodReference ((string) $4,
					codegen.CurrentMethod.ReturnType, (TypeReference) $2);

				codegen.CurrentMethod.Overrides.Add (overridenMethod);
			}
			| D_OVERRIDE generic_method_ref
			{
				codegen.CurrentMethod.Overrides.Add ((MethodReference) $2);
			}
			| scope_block
			| D_PARAM OPEN_BRACKET int32 CLOSE_BRACKET init_opt
			{
				var idx = (int) $3;

				if (idx <= 0 || idx > codegen.CurrentMethod.Parameters.Count)
					report.WriteWarning (Warning.OutOfRangeParameterIndex,
						"Parameter at index '{0}' not found.", idx);

				var param = codegen.CurrentMethod.Parameters [idx - 1];
				codegen.CurrentCustomAttributeProvider = param;

				if ($5 != null)
					param.Constant = $5 is Null ? null : $5;
			}
			| param_type_decl
			| id COLON
			{
				var name = (string) $1;

				if (labels.ContainsKey (name))
					report.WriteError (Error.DuplicateLabel,
						"Duplicate label: {0}", name);

				var label = new Label (name);

				current_labels.Add (label);
				labels.Add (name, label);
			}
			| seh_block
			| instr
			{
				var instr = (Instruction) $1;

				is_inside_scope = false;

				foreach (var label in current_labels)
					label.Instruction = instr;

				current_labels.Clear ();

				last_instr = instr;
			}
			| sec_decl
			{
				codegen.CurrentMethod.SecurityDeclarations.Add (codegen.CurrentSecurityDeclaration);
				codegen.CurrentSecurityDeclaration = null;
			}
			| extsource_spec
			| language_decl
			| customattr_decl
			{
				if ($1 != null) {
					var provider = codegen.CurrentCustomAttributeProvider != null ?
						codegen.CurrentCustomAttributeProvider : codegen.CurrentType;

					provider.CustomAttributes.Add ((CustomAttribute) $1);
					codegen.CurrentCustomAttribute = null;
				}
			}
			| data_decl
			| comp_control
			;

scope_block		: OPEN_BRACE
			{
				var scope = new Scope ();

				var instr = il.Create (OpCodes.Nop);
				il.Append (instr);
				scope.Start = instr;

				is_inside_scope = true;
				scope_stack.Push (codegen.CurrentScope);

				codegen.CurrentScope.Scopes.Add (scope);
				codegen.CurrentScope = scope;
			}
			  method_decls CLOSE_BRACE
			{
				var scope = codegen.CurrentScope;

				if (!is_inside_scope)
					scope.End = last_instr;

				is_inside_scope = false;

				$$ = scope;

				codegen.CurrentScope = scope_stack.Pop ();
			}
			;

seh_block		: try_block seh_clauses
			{
				var area = (Tuple<Instruction, Instruction>) $1;

				foreach (var handler in (List<ExceptionHandler>) $2) {
					handler.TryStart = area.X;
					handler.TryEnd = area.Y;

					il.Body.ExceptionHandlers.Add (handler);
				}
			}
			;

try_block		: D_TRY scope_block
			{
				var scope = (Scope) $2;

				$$ = new Tuple<Instruction, Instruction> (scope.Start,
					scope.End);
			}
			| D_TRY id K_TO id
			{
				var label1 = FindInstruction ((string) $2);
				var label2 = FindInstruction ((string) $4);

				$$ = new Tuple<Instruction, Instruction> (label1, label2);
			}
			| D_TRY int32 K_TO int32
			{
				var label1 = FindInstruction ((int) $2);
				var label2 = FindInstruction ((int) $4);

				$$ = new Tuple<Instruction, Instruction> (label1, label2);
			}
			;

seh_clauses		: seh_clause
			{
				$$ = new List<ExceptionHandler> {
					(ExceptionHandler) $1,
				};
			}
			| seh_clauses seh_clause
			{
				((List<ExceptionHandler>) $1).Add ((ExceptionHandler) $2);
			}
			;

seh_clause		: K_CATCH type_spec handler_block
			{
				var clause = (Tuple<Instruction, Instruction>) $3;

				$$ = new ExceptionHandler (ExceptionHandlerType.Catch) {
					CatchType = (TypeReference) $2,
					HandlerStart = clause.X,
					HandlerEnd = clause.Y,
				};
			}
			| filter_clause handler_block
			{
				var clause = (Tuple<Instruction, Instruction>) $2;

				$$ = new ExceptionHandler (ExceptionHandlerType.Filter) {
					FilterStart = (Instruction) $1,
					HandlerStart = clause.X,
					HandlerEnd = clause.Y,
				};
			}
			| K_FINALLY handler_block
			{
				var clause = (Tuple<Instruction, Instruction>) $2;

				$$ = new ExceptionHandler (ExceptionHandlerType.Finally) {
					HandlerStart = clause.X,
					HandlerEnd = clause.Y,
				};
			}
			| K_FAULT handler_block
			{
				var clause = (Tuple<Instruction, Instruction>) $2;

				$$ = new ExceptionHandler (ExceptionHandlerType.Fault) {
					HandlerStart = clause.X,
					HandlerEnd = clause.Y,
				};
			}
			;

filter_clause		: K_FILTER scope_block
			{
				$$ = ((Scope) $2).Start;
			}
			| K_FILTER id
			{
				$$ = FindInstruction ((string) $2);
			}
			| K_FILTER int32
			{
				$$ = FindInstruction ((int) $2);
			}
			;

handler_block		: scope_block
			{
				var scope = (Scope) $1;

				$$ = new Tuple<Instruction, Instruction> (scope.Start,
					scope.End);
			}
			| K_HANDLER id K_TO id
			{
				var label1 = FindInstruction ((string) $2);
				var label2 = FindInstruction ((string) $4);

				$$ = new Tuple<Instruction, Instruction> (label1, label2);
			}
			| K_HANDLER int32 K_TO int32
			{
				var label1 = FindInstruction ((int) $2);
				var label2 = FindInstruction ((int) $4);

				$$ = new Tuple<Instruction, Instruction> (label1, label2);
			}
			;

instr			: INSTR_NONE
			{
				if ($1 == null)
					report.WriteError (Error.InvalidOpCode,
						"Invalid (illegal/reserved) opcode encountered.");

				var instr = il.Create ((OpCode) $1);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_LOCAL int32
			{
				var idx = (int) $2;

				if (idx < 0 || idx >= il.Body.Variables.Count)
					report.WriteError (Error.InvalidLocal,
						"Local variable at index '{0}' not found.", idx);

				var variable = il.Body.Variables [idx];
				var instr = il.Create ((OpCode) $1, variable);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_LOCAL id
			{
				var name = (string) $2;
				VariableDefinition variable = null;

				foreach (var local in codegen.CurrentScope.Variables)
					if (local.Name == name)
						variable = local;

				if (variable == null)
					foreach (var scope in scope_stack.QueueReverse ())
						if (scope != null)
							foreach (var local in scope.Variables)
								if (local.Name == name)
									variable = local;

				if (variable == null)
					report.WriteError (Error.InvalidLocal,
						"Local variable '{0}' not found.", name);

				var instr = il.Create ((OpCode) $1, variable);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_PARAM int32
			{
				var idx = (int) $2;

				if (idx < 0 || idx >= codegen.CurrentMethod.Parameters.Count)
					report.WriteError (Error.InvalidParameter,
						"Parameter at index '{0}' not found.", idx);

				var param = codegen.CurrentMethod.Parameters [idx];
				var instr = il.Create ((OpCode) $1, param);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_PARAM id
			{
				var name = (string) $2;
				ParameterDefinition param = null;

				foreach (var parameter in codegen.CurrentMethod.Parameters)
					if (parameter.Name == name)
						param = parameter;

				if (param == null)
					report.WriteError (Error.InvalidParameter,
						"Parameter '{0}' not found.", name);

				var instr = il.Create ((OpCode) $1, param);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_I int32
			{
				var op = (OpCode) $1;
				Instruction instr;

				if (op.OperandType == OperandType.ShortInlineI) {
					if (op == OpCodes.Ldc_I4_S)
						instr = il.Create (op, (sbyte) (int) $2);
					else
						instr = il.Create (op, (byte) (int) $2);
				}
				else
					instr = il.Create (op, (int) $2);

				il.Append (instr);

				$$ = instr;
			}
			| INSTR_I8 int64
			{
				var instr = il.Create ((OpCode) $1, (long) $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_R float64
			{
				var op = (OpCode) $1;
				Instruction instr;

				if (op == OpCodes.Ldc_R4)
					instr = il.Create (op, (float) (double) $2);
				else
					instr = il.Create (op, (double) $2);

				il.Append (instr);

				$$ = instr;
			}
			| INSTR_R int64
			{
				var op = (OpCode) $1;
				Instruction instr;

				if (op == OpCodes.Ldc_R4) {
					var val = BitConverter.ToSingle (BitConverter.GetBytes ((int) (long) $2),
						BitConverter.IsLittleEndian ? 0 : 4);

					instr = il.Create (op, val);
				} else {
					var val = BitConverter.Int64BitsToDouble ((long) $2);

					instr = il.Create (op, val);
				}

				il.Append (instr);

				$$ = instr;
			}
			| INSTR_R bytes_list
			{
				var op = (OpCode) $1;
				Instruction instr;

				if (op == OpCodes.Ldc_R4) {
					var val = BitConverter.ToSingle ((byte[]) $2,
						BitConverter.IsLittleEndian ? 0 : 4);

					instr = il.Create (op, val);
				} else {
					var val = BitConverter.ToDouble ((byte[]) $2,
						BitConverter.IsLittleEndian ? 0 : 8);

					instr = il.Create (op, val);
				}

				il.Append (instr);

				$$ = instr;
			}
			| INSTR_BRTARGET label
			{
				// Some hackery so we can jump to not-yet-created labels.
				var instr = il.Create (OpCodes.Nop);
				instr.OpCode = (OpCode) $1;

				label_jumps.Add (instr, $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_METHOD method_ref
			{
				var instr = il.Create ((OpCode) $1, (MethodReference) $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_FIELD field_ref
			{
				var instr = il.Create ((OpCode) $1, (FieldReference) $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_TYPE type_spec
			{
				var instr = il.Create ((OpCode) $1, (TypeReference) $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_STRING comp_qstring
			{
				var instr = il.Create ((OpCode) $1, (string) $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_STRING K_ANSI comp_qstring
			{
				// TODO: Do we reencode the string or something?
				var instr = il.Create ((OpCode) $1, (string) $2);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_STRING K_BYTEARRAY ASSIGN bytes_list
			{
				var text = Encoding.Unicode.GetString ((byte[]) $4);
				var instr = il.Create ((OpCode) $1, text);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_SIG call_conv type OPEN_PARENS sig_args CLOSE_PARENS
			{
				var call = new CallSite ((TypeReference) $3);

				if (is_instance_call)
					call.HasThis = true;

				if (is_explicit_call)
					call.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var param in (List<ParameterDefinition>) $5)
					call.Parameters.Add (param);

				var instr = il.Create ((OpCode) $1, call);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_TOK owner_type
			{
				Instruction instr;

				if ($2 is TypeReference)
					instr = il.Create ((OpCode) $1, (TypeReference) $2);
				else if ($2 is FieldReference)
					instr = il.Create ((OpCode) $1, (FieldReference) $2);
				else
					instr = il.Create ((OpCode) $1, (MethodReference) $2);

				il.Append (instr);

				$$ = instr;
			}
			| INSTR_SWITCH OPEN_PARENS labels CLOSE_PARENS
			{
				// See the note in INSTR_BRTARGET.
				var instr = il.Create (OpCodes.Nop);
				instr.OpCode = (OpCode) $1;

				label_jumps.Add (instr, $3);
				il.Append (instr);

				$$ = instr;
			}
			| INSTR_PHI int16_seq // Not actually used.
			;

label			: id
			| int32
			;

labels			:
			{
				$$ = new List<object> ();
			}
			| label
			{
				$$ = new List<object> {
					$1,
				};
			}
			| label COMMA labels
			{
				((List<object>) $3).Add ((object) $1);

				$$ = $3;
			}
			;

member_ref		: K_METHOD method_ref
			{
				$$ = $2;
			}
			| K_FIELD field_ref
			{
				$$ = $2;
			}
			;

field_ref		:
			{
				generic_typeref_in_field = true;
			}
			  type declaring_type comp_name_str
			{
				generic_typeref_in_field = false;

				var declType = (TypeReference) $3;

				if (dummy_type.GenericParameters.Count > 0 &&
					!(declType is GenericInstanceType))
					report.WriteError (Error.GenericParameterOrdinalOutOfRange,
						"Declaring type is not generic.");

				for (var i = 0; i < dummy_type.GenericParameters.Count; i++) {
					var genParam = dummy_type.GenericParameters [i];

					if (genParam == null) {
						var gp = new GenericParameter (declType.GetElementType ());

						dummy_type.GenericParameters [i] = gp;
						declType.GenericParameters.Add (gp);

						continue;
					}

					var pos = genParam.Position;

					if (pos >= ((GenericInstanceType) declType).GenericArguments.Count)
						report.WriteError (Error.GenericParameterOrdinalOutOfRange,
							"Generic argument '{0}' not found.", pos);

					declType.GetElementType ().GenericParameters.Add (genParam);
				}

				ResetDummyType ();

				var field = new FieldReference ((string) $4,
					(TypeReference) $2, declType);

				if (declType == codegen.CurrentModule.GetModuleType () &&
					field.Resolve () == null)
					report.WriteError (Error.UnresolvedModuleField,
						"Could not resolve module field: {0}", field);

				$$ = field;
			}
			| mdtoken
			{
				$$ = codegen.GetFieldByMetadataToken ((int) $1);
			}
			;

declaring_type		:
			{
				// The spec says that this syntax can refer to a method
				// in the current class. However, Microsoft's ILAsm does
				// not agree, and insists that this syntax can only refer
				// to module-global methods. We maintain compatibility in
				// this case.
				$$ = codegen.CurrentModule.GetModuleType ();
			}
			| type_spec DOUBLE_COLON
			;

method_ref		: call_conv
			{
				// See the note in method_head.
				generic_typeref_in_field = true;
				generic_typeref_in_method = true;
			}
			  type declaring_type method_name
			{
				generic_typeref_in_method = false;
				generic_typeref_in_field = false;

				var method = new MethodReference ((string) $5,
					(TypeReference) $3, (TypeReference) $4) {
					CallingConvention = (MethodCallingConvention) $1,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				codegen.CurrentMethodReference = method;
			}
			  typars_clause_opt
			{
				generic_typeref_in_method = true;
				generic_typeref_in_field = true;
			}
			  OPEN_PARENS sig_args CLOSE_PARENS
			{
				generic_typeref_in_method = false;
				generic_typeref_in_field = false;

				var method = codegen.CurrentMethodReference;

				foreach (var arg in (List<ParameterDefinition>) $10)
					method.Parameters.Add (arg);

				var declType = method.DeclaringType;

				if (dummy_type.GenericParameters.Count > 0 &&
					!(declType is GenericInstanceType))
					report.WriteError (Error.GenericParameterOrdinalOutOfRange,
						"Declaring type is not generic.");

				for (var i = 0; i < dummy_type.GenericParameters.Count; i++) {
					var genParam = dummy_type.GenericParameters [i];

					if (genParam == null) {
						var gp = new GenericParameter (declType.GetElementType ());

						dummy_type.GenericParameters [i] = gp;
						declType.GenericParameters.Add (gp);

						continue;
					}

					var pos = genParam.Position;

					if (pos >= ((GenericInstanceType) declType).GenericArguments.Count)
						report.WriteError (Error.GenericParameterOrdinalOutOfRange,
							"Generic argument '{0}' not found.", pos);

					declType.GetElementType ().GenericParameters.Add (genParam);
				}

				ResetDummyType ();

				if ($7 != null) {
					var genMethod = new GenericInstanceMethod (method);

					foreach (var typeArg in (List<TypeReference>) $7)
						genMethod.GenericArguments.Add (typeArg);

					method = genMethod;
				}

				for (var i = 0; i < dummy_method.GenericParameters.Count; i++) {
					var genParam = dummy_method.GenericParameters [i];

					if (genParam == null) {
						var gp = new GenericParameter (method.GetElementMethod ());

						dummy_method.GenericParameters [i] = gp;
						method.GetElementMethod ().GenericParameters.Add (gp);

						continue;
					}

					var pos = genParam.Position;

					if (pos >= ((GenericInstanceMethod) method).GenericArguments.Count)
						report.WriteError (Error.GenericParameterOrdinalOutOfRange,
							"Generic argument '{0}' not found.", pos);

					method.GetElementMethod ().GenericParameters.Add (genParam);
				}

				ResetDummyMethod ();

				if (method.DeclaringType == codegen.CurrentModule.GetModuleType () &&
					method.Resolve () == null)
					report.WriteError (Error.UnresolvedModuleMethod,
						"Could not resolve module method: {0}", method);

				codegen.CurrentMethodReference = null;

				$$ = method;
			}
			| mdtoken
			{
				$$ = codegen.GetMethodByMetadataToken ((int) $1);
			}
			;

method_name		: D_CTOR
			| D_CCTOR
			| comp_name_str
			;

generic_method_ref	: K_METHOD call_conv type type_spec DOUBLE_COLON method_name generic_arity OPEN_PARENS sig_args CLOSE_PARENS
			{
				var method = new MethodReference ((string) $6, (TypeReference) $3, (TypeReference) $4) {
					CallingConvention = (MethodCallingConvention) $2,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var param in (List<ParameterDefinition>) $9)
					method.Parameters.Add (param);

				if ($7 != null)
					for (var i = 0; i < (int) $7; i++)
						method.GenericParameters.Add (new GenericParameter (method));

				$$ = method;
			}
			;

generic_arity		:
			| OPEN_BRACKET OPEN_ANGLE_BRACKET int32 CLOSE_ANGLE_BRACKET CLOSE_BRACKET
			{
				$$ = $3;
			}
			;

owner_type		: type_spec
			| member_ref
			;

event_all		: event_head OPEN_BRACE event_decls CLOSE_BRACE
			{
				if (codegen.CurrentEvent.AddMethod == null ||
					codegen.CurrentEvent.RemoveMethod == null)
					report.WriteError (Error.MissingEventAccessors,
						"Event '{0}' is missing add/remove accessors.",
						codegen.CurrentEvent);

				codegen.CurrentType.Events.Add (codegen.CurrentEvent);
				codegen.CurrentEvent = null;
			}
			;

event_head		: D_EVENT event_attr type_spec comp_name_str
			{
				codegen.CurrentEvent = new EventDefinition ((string) $4,
					(EventAttributes) $2, (TypeReference) $3);
			}
			| D_EVENT event_attr id // TODO: What do we do here? Infer some type?
			;

event_attr		:
			{
				$$ = EventAttributes.None;
			}
			| event_attr K_RTSPECIALNAME	{ $$ = (EventAttributes) $1 & EventAttributes.RTSpecialName; }
			| event_attr K_SPECIALNAME	{ $$ = (EventAttributes) $1 & EventAttributes.SpecialName; }
			;

event_decls		:
			| event_decls event_decl
			;

event_decl		: D_ADDON method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve add method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.AddMethod = method;
			}
			| D_REMOVEON method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve remove method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.RemoveMethod = method;
			}
			| D_FIRE method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve fire method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.InvokeMethod = method;
			}
			| D_OTHER method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve other method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.OtherMethods.Add (method);
			}
			| customattr_decl
			{
				if ($1 != null) {
					codegen.CurrentEvent.CustomAttributes.Add ((CustomAttribute) $1);
					codegen.CurrentCustomAttribute = null;
				}
			}
			| extsource_spec
			| language_decl
			| comp_control
			;

prop_all		: prop_head OPEN_BRACE prop_decls CLOSE_BRACE
			{
				codegen.CurrentType.Properties.Add (codegen.CurrentProperty);
				codegen.CurrentProperty = null;
			}
			;

prop_head		: D_PROPERTY call_conv prop_attr type comp_name_str OPEN_PARENS sig_args CLOSE_PARENS init_opt
			{
				// TODO: We can't set calling convention with Cecil.
				codegen.CurrentProperty = new PropertyDefinition ((string) $5,
					(PropertyAttributes) $3, (TypeReference) $4);

				// FIXME: When no getter/setter is defined (i.e. right at
				// this point), Cecil just returns a dummy collection that's
				// useful for just about nothing, and our parameters end up
				// going nowhere.
				foreach (var param in (List<ParameterDefinition>) $7)
					codegen.CurrentProperty.Parameters.Add (param);

				if ($9 != null)
					codegen.CurrentProperty.Constant = $9 is Null ? null : $9;
			}
			;

prop_attr 		:
			{
				$$ = PropertyAttributes.None;
			}
			| prop_attr K_RTSPECIALNAME	{ $$ = (PropertyAttributes) $1 | PropertyAttributes.RTSpecialName; }
			| prop_attr K_SPECIALNAME	{ $$ = (PropertyAttributes) $1 | PropertyAttributes.SpecialName; }
			;

prop_decls		:
			| prop_decls prop_decl
			;

prop_decl		: D_SET method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve set method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidPropertyMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentProperty.SetMethod = method;
			}
			| D_GET method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve get method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidPropertyMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentProperty.GetMethod = method;
			}
			| D_OTHER method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve other method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidPropertyMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentProperty.OtherMethods.Add (method);
			}
			| customattr_decl
			{
				if ($1 != null) {
					codegen.CurrentProperty.CustomAttributes.Add ((CustomAttribute) $1);
					codegen.CurrentCustomAttribute = null;
				}
			}
			| extsource_spec
			| language_decl
			| comp_control
			;

customattr_decl		: customattr
			| customattr_owner
			{
				((ICustomAttributeProvider) $1).CustomAttributes.Add (codegen.CurrentCustomAttribute);
				codegen.CurrentCustomAttribute = null;

				$$ = null;
			}
			;

customattr		: D_CUSTOM method_ref
			{
				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2);
			}
			| D_CUSTOM method_ref ASSIGN comp_qstring
			{
				var bytes = Encoding.Unicode.GetBytes ((string) $4);

				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2, bytes);
			}
			| D_CUSTOM method_ref ASSIGN bytes_list
			{
				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2, (byte[]) $4);
			}
			| D_CUSTOM method_ref ASSIGN OPEN_BRACE
			{
				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2);
			}
			  customattr_blob CLOSE_BRACE
			;

customattr_owner	: D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref
			{
				codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $5);

				$$ = ResolveCustomAttributeOwner ($3);
			}
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref ASSIGN comp_qstring
			{
				var bytes = Encoding.Unicode.GetBytes ((string) $7);

				codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $5, bytes);

				$$ = ResolveCustomAttributeOwner ($3);
			}
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref ASSIGN bytes_list
			{
				codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $5, (byte[]) $7);

				$$ = ResolveCustomAttributeOwner ($3);
			}
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref ASSIGN OPEN_BRACE
			{
				codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $5);

				$$ = ResolveCustomAttributeOwner ($3);
			}
			  customattr_blob CLOSE_BRACE
			;

customattr_blob		: customattr_blob_args
			  customattr_blob_nvp
			{
				foreach (var pair in (List<Tuple<TokenType, CustomAttributeNamedArgument>>) $1) {
					if (pair.X == TokenType.Field)
						codegen.CurrentCustomAttribute.Fields.Add (pair.Y);
					else
						codegen.CurrentCustomAttribute.Properties.Add (pair.Y);
				}
			}
			;

customattr_blob_args	:
			| customattr_blob_args customattr_blob_init
			{
				codegen.CurrentCustomAttribute.ConstructorArguments.Add ((CustomAttributeArgument) $2);
			}
			| customattr_blob_args comp_control
			;

customattr_blob_nvp	:
			{
				$$ = new List<Tuple<TokenType, CustomAttributeNamedArgument>> ();
			}
			| customattr_blob_nvp prop_or_field customattr_blob_type comp_name_str ASSIGN customattr_blob_init
			{
				var namedArg = new CustomAttributeNamedArgument ((string) $4,
					(CustomAttributeArgument) $6);
				var tuple = new Tuple<TokenType, CustomAttributeNamedArgument> ((TokenType) $2, namedArg);

				((List<Tuple<TokenType, CustomAttributeNamedArgument>>) $1).Add (tuple);
			}
			| customattr_blob_nvp comp_control
			;

customattr_blob_type	: simple_type
			| K_TYPE
			{
				$$ = codegen.Corlib.Type;
			}
			| K_OBJECT
			{
				$$ = codegen.Corlib.Object;
			}
			| K_ENUM K_CLASS SQSTRING // TODO: We need an S.R.E notation parser.
			| K_ENUM class_ref
			{
				$$ = $2;
			}
			| customattr_blob_type OPEN_BRACKET CLOSE_BRACKET
			{
				$$ = new ArrayType ((TypeReference) $1);
			}
			;

customattr_blob_init	: K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Single,
					(float) (double) $3);
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Double, $3);
			}
			| K_FLOAT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Single,
					BitConverter.ToSingle (BitConverter.GetBytes ((long) $3),
						BitConverter.IsLittleEndian ? 0 : 4));
			}
			| K_FLOAT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Double,
					BitConverter.Int64BitsToDouble ((long) $3));
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Int64, $3);
			}
			| unsigned_int64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.UInt64,
					(ulong) (long) $3);
			}
			| K_INT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Int32,
					(int) (long) $3);
			}
			| unsigned_int32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.UInt32,
					(uint) (long) $3);
			}
			| K_INT16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Int16,
					(short) (long) $3);
			}
			| unsigned_int16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.UInt16,
					(ushort) (long) $3);
			}
			| K_INT8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.SByte,
					(sbyte) (long) $3);
			}
			| unsigned_int8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Byte,
					(byte) (long) $3);
			}
			| K_CHAR OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Char,
					(char) (long) $3);
			}
			| K_BOOL OPEN_PARENS truefalse CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Boolean, $3);
			}
			| K_BYTEARRAY bytes_list
			{
				var bytes = (byte[]) $2;
				var cas = new List<CustomAttributeArgument> (bytes.Length);

				foreach (var b in bytes)
					cas.Add (new CustomAttributeArgument (codegen.Corlib.Byte, b));

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Byte),
					cas.ToArray ());
			}
			| K_STRING OPEN_PARENS K_NULLREF CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.String, null);
			}
			| K_STRING OPEN_PARENS SQSTRING CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.String, $3);
			}
			| K_TYPE OPEN_PARENS K_CLASS SQSTRING CLOSE_PARENS // TODO: We need an S.R.E notation parser.
			| K_TYPE OPEN_PARENS class_ref CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Type, $3);
			}
			| K_TYPE OPEN_PARENS K_NULLREF CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Type, null);
			}
			| K_OBJECT OPEN_PARENS customattr_blob_init CLOSE_PARENS
			{
				$$ = new CustomAttributeArgument (codegen.Corlib.Object, $3);
			}
			| K_FLOAT32 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS float32_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Single),
					$6);
			}
			| K_FLOAT64 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS float64_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Double),
					$6);
			}
			| K_INT8 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = false;
			}
			  int8_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.SByte),
					$6);
			}
			| K_INT16 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = false;
			}
			  int16_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Int16),
					$6);
			}
			| K_INT32 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = false;
			}
			  int32_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Int32),
					$6);
			}
			| K_INT64 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = false;
			}
			  int64_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Int64),
					$6);
			}
			| unsigned_int8 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = true;
			}
			  int8_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Byte),
					$6);
			}
			| unsigned_int16 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = true;
			}
			  int16_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.UInt16),
					$6);
			}
			| unsigned_int32 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = true;
			}
			  int32_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.UInt32),
					$6);
			}
			| unsigned_int64 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS
			{
				custom_attr_unsigned = true;
			}
			  int64_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.UInt64),
					$6);
			}
			| K_CHAR OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int16_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Char),
					$6);
			}
			| K_BOOL OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS bool_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Boolean),
					$6);
			}
			| K_STRING OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS string_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.String),
					$6);
			}
			| K_TYPE OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS class_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Type),
					$6);
			}
			| K_OBJECT OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS obj_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = new CustomAttributeArgument (new ArrayType (codegen.Corlib.Object),
					$6);
			}
			;

float32_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| float32_seq float64
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Single,
						(float) (double) $2);
				}
			}
			| float32_seq int32
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Single,
						BitConverter.ToSingle (BitConverter.GetBytes ((int) $2),
							BitConverter.IsLittleEndian ? 0 : 4));
				}
			}
			;

float64_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| float64_seq float64
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Double,
						$2);
				}
			}
			| float64_seq int64
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Double,
						BitConverter.Int64BitsToDouble ((long) $2));
				}
			}
			;

int8_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| int8_seq int32
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (custom_attr_unsigned ?
						codegen.Corlib.Byte : codegen.Corlib.SByte,
						custom_attr_unsigned ? (object) (byte) (int) $2 :
							(object) (sbyte) (int) $2);
				}
			}
			;

int16_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| int16_seq int32
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (custom_attr_unsigned ?
						codegen.Corlib.UInt16 : codegen.Corlib.Int16,
						custom_attr_unsigned ? (object) (ushort) (int) $2 :
							(object) (short) (int) $2);
				}
			}
			;

int32_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| int32_seq int32
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (custom_attr_unsigned ?
						codegen.Corlib.UInt32 : codegen.Corlib.Int32,
						custom_attr_unsigned ? (object) (uint) (int) $2 : $2);
				}
			}
			;

int64_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| int64_seq int64
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (custom_attr_unsigned ?
						codegen.Corlib.UInt64 : codegen.Corlib.Int64,
						custom_attr_unsigned ? (object) (ulong) (long) $2 : $2);
				}
			}
			;

bool_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| bool_seq truefalse
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Boolean,
						$2);
				}
			}
			;

string_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| string_seq K_NULLREF
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.String,
						null);
				}
			}
			| string_seq SQSTRING
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.String,
						$2);
				}
			}
			;

class_seq		:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| class_seq K_NULLREF
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Type,
						null);
				}
			}
			| class_seq K_CLASS SQSTRING // TODO: We need an S.R.E notation parser.
			| class_seq class_ref
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Type,
						$2);
				}
			}
			;

obj_seq			:
			{
				$$ = new CustomAttributeArgument [0];
			}
			| obj_seq customattr_blob_init
			{
				var arr = (CustomAttributeArgument[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = new CustomAttributeArgument (codegen.Corlib.Object,
						$2);
				}
			}
			;

sec_bytearray		: ASSIGN bytes_list
			{
				$$ = $2;
			}
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			;

sec_decl		: D_PERMISSION sec_action type_spec OPEN_PARENS nameval_pairs CLOSE_PARENS
			{
				if (codegen.CurrentSecurityDeclaration == null)
					codegen.CurrentSecurityDeclaration = new SecurityDeclaration ((SecurityAction) $2);

				var attr = new SecurityAttribute ((TypeReference) $3);

				foreach (var obj in (List<Tuple<string, object>>) $5) {
					TypeReference type;

					if (obj.Y is bool)
						type = codegen.Corlib.Boolean;
					else if (obj.Y is int)
						type = codegen.Corlib.Int32;
					else
						type = codegen.Corlib.String;

					attr.Properties.Add (new CustomAttributeNamedArgument (obj.X,
						new CustomAttributeArgument (type, obj.Y)));
				}

				codegen.CurrentSecurityDeclaration.SecurityAttributes.Add (attr);
			}
			| D_PERMISSION sec_action type_spec ASSIGN OPEN_PARENS customattr_blob CLOSE_PARENS
			{
				if (codegen.CurrentSecurityDeclaration == null)
					codegen.CurrentSecurityDeclaration = new SecurityDeclaration ((SecurityAction) $2);

				// TODO: We can't pass security attribute constructor args with Cecil.
			}
			| D_PERMISSION sec_action type_spec
			{
				if (codegen.CurrentSecurityDeclaration == null)
					codegen.CurrentSecurityDeclaration = new SecurityDeclaration ((SecurityAction) $2);

				codegen.CurrentSecurityDeclaration.SecurityAttributes.Add (new SecurityAttribute ((TypeReference) $3));
			}
			| D_PERMISSIONSET sec_action sec_bytearray
			{
				if (codegen.CurrentSecurityDeclaration == null)
					codegen.CurrentSecurityDeclaration = new SecurityDeclaration ((SecurityAction) $2);

				// TODO: We need a way to set the blob.
			}
			| D_PERMISSIONSET sec_action comp_qstring
			{
				if (codegen.CurrentSecurityDeclaration == null)
					codegen.CurrentSecurityDeclaration = new SecurityDeclaration ((SecurityAction) $2);

				// TODO: We need a way to set the XML.
			}
			| D_PERMISSIONSET sec_action ASSIGN OPEN_BRACE permissions CLOSE_BRACE
			{
				if (codegen.CurrentSecurityDeclaration == null)
					codegen.CurrentSecurityDeclaration = new SecurityDeclaration ((SecurityAction) $2);

				foreach (var attr in (List<SecurityAttribute>) $5)
					codegen.CurrentSecurityDeclaration.SecurityAttributes.Add (attr);
			}
			;

sec_action		: K_REQUEST		{ $$ = SecurityAction.Request; }
			| K_DEMAND		{ $$ = SecurityAction.Demand; }
			| K_ASSERT		{ $$ = SecurityAction.Assert; }
			| K_DENY		{ $$ = SecurityAction.Deny; }
			| K_PERMITONLY		{ $$ = SecurityAction.PermitOnly; }
			| K_LINKCHECK		{ $$ = SecurityAction.LinkDemand; }
			| K_INHERITCHECK	{ $$ = SecurityAction.InheritDemand; }
			| K_REQMIN		{ $$ = SecurityAction.RequestMinimum; }
			| K_REQOPT		{ $$ = SecurityAction.RequestOptional; }
			| K_REQREFUSE		{ $$ = SecurityAction.RequestRefuse; }
			| K_PREJITGRANT		{ $$ = SecurityAction.PreJitGrant; }
			| K_PREJITDENY		{ $$ = SecurityAction.PreJitDeny; }
			| K_NONCASDEMAND	{ $$ = SecurityAction.NonCasDemand; }
			| K_NONCASLINKDEMAND	{ $$ = SecurityAction.NonCasLinkDemand; }
			| K_NONCASINHERITANCE	{ $$ = SecurityAction.NonCasInheritance; }
			;

permissions		: permission
			{
				$$ = new List<SecurityAttribute> ();
			}
			| permissions COMMA permission
			{
				((List<SecurityAttribute>) $1).Add ((SecurityAttribute) $3);
			}
			;

permission		: class_ref ASSIGN OPEN_BRACE customattr_blob_nvp CLOSE_BRACE
			{
				var attr = new SecurityAttribute ((TypeReference) $1);

				foreach (var arg in (List<Tuple<TokenType, CustomAttributeNamedArgument>>) $4) {
					if (arg.X == TokenType.Field)
						attr.Fields.Add (arg.Y);
					else
						attr.Properties.Add (arg.Y);
				}

				$$ = attr;
			}
			| K_CLASS SQSTRING ASSIGN OPEN_BRACE customattr_blob_nvp CLOSE_BRACE // TODO: We need an S.R.E notation parser.
			;

nameval_pairs		: nameval_pair
			{
				$$ = new List<Tuple<string, object>> ();
			}
			| nameval_pairs COMMA nameval_pair
			{
				((List<Tuple<string, object>>) $1).Add ((Tuple<string, object>) $3);
			}
			;

nameval_pair		: comp_qstring ASSIGN cavalue
			{
				$$ = new Tuple<string, object> ((string) $1, $3);
			}
			;

cavalue 		: truefalse
			| int32
			| K_INT32 OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = $3;
			}
			| comp_qstring
			// TODO: No idea how these work. They're not standard.
			| class_ref OPEN_PARENS K_INT8 COLON int32 CLOSE_PARENS
			| class_ref OPEN_PARENS K_INT16 COLON int32 CLOSE_PARENS
			| class_ref OPEN_PARENS K_INT32 COLON int32 CLOSE_PARENS
			| class_ref OPEN_PARENS int32 CLOSE_PARENS
			;

prop_or_field		: K_PROPERTY
			{
				$$ = TokenType.Property;
			}
			| K_FIELD
			{
				$$ = TokenType.Field;
			}
			;

module_head		: D_MODULE
			| D_MODULE comp_name_str
			{
				var name = (string) $2;

				if (!codegen.HasModuleDirective) {
					// Microsoft's ILAsm only takes into account the
					// first .module directive
					codegen.CurrentModule.Name = name;
					codegen.HasModuleDirective = true;
				}
				else if (name != codegen.CurrentModule.Name)
					report.WriteWarning (Warning.ModuleDirectiveIgnored,
						".module directive with different name ignored.");
			}
			| D_MODULE K_EXTERN comp_name_str
			{
				var name = (string) $3;

				if (codegen.GetModuleReference (name) != null)
					report.WriteWarning (Warning.ModuleReferenceIgnored,
						"Ignoring duplicate module reference: {0}", name);

				var module = new ModuleReference (name);
				codegen.CurrentModule.ModuleReferences.Add (module);
			}
			;

file_decl		: D_FILE file_attr comp_name file_entry D_HASH ASSIGN bytes_list file_entry
			| D_FILE file_attr comp_name file_entry
			;

file_attr 		:
			{
				$$ = true;
			}
			| file_attr K_NOMETADATA
			{
				$$ = false;
			}
			;

file_entry		:
			{
				$$ = false;
			}
			| D_ENTRYPOINT
			{
				$$ = true;
			}
			;

assembly_all		: assembly_head OPEN_BRACE assembly_decls CLOSE_BRACE
			;

assembly_head		: D_ASSEMBLY asm_attr comp_name_str
			{
				var name = (string) $3;
				var asmName = codegen.CurrentModule.Assembly.Name;

				if (codegen.HasAssemblyDirective && name != asmName.Name)
					report.WriteError (Error.MultipleAssemblyDirectives,
						"Multiple .assembly directives.");

				asmName.Attributes = (AssemblyAttributes) $2;
				asmName.Name = name;
				codegen.HasAssemblyDirective = true;
			}
			;

asm_attr		:
			{
				$$ = AssemblyAttributes.SideBySideCompatible;
			}
			| asm_attr K_RETARGETABLE
			{
				$$ = ((AssemblyAttributes) $1) | AssemblyAttributes.Retargetable;
			}
			// TODO: What on earth do we do with these?! Some look like corflags, others
			// look more like target architectures... They also aren't documented...
			| asm_attr K_LEGACY K_LIBRARY
			| asm_attr K_CIL
			| asm_attr K_X86
			| asm_attr K_IA64
			| asm_attr K_AMD64
			| asm_attr K_NOAPPDOMAIN
			| asm_attr K_NOPROCESS
			| asm_attr K_NOMACHINE
			;

assembly_decls		:
			| assembly_decls assembly_decl
			;

locale_or_culture	: D_LOCALE
			| D_CULTURE
			;

assembly_decl		: D_PUBLICKEY ASSIGN bytes_list
			{
				codegen.CurrentModule.Assembly.Name.PublicKey = (byte[]) $3;
			}
			| D_VER int32 COLON int32 COLON int32 COLON int32
			{
				codegen.CurrentModule.Assembly.Name.Version =
					new Version ((int) $2, (int) $4, (int) $6, (int) $8);
			}
			| locale_or_culture comp_qstring
			{
				codegen.CurrentModule.Assembly.Name.Culture = (string) $2;
			}
			| locale_or_culture ASSIGN bytes_list
			{
				// I assume this is UTF-16. I really have no clue, though,
				// and it isn't documented...
				var text = Encoding.Unicode.GetString ((byte[]) $3);
				codegen.CurrentModule.Assembly.Name.Culture = text;
			}
			| D_HASH K_ALGORITHM int32
			{
				var algo = (AssemblyHashAlgorithm) (int) $3;

				if (algo != AssemblyHashAlgorithm.SHA1)
					report.WriteWarning (Warning.UnknownHashAlgorithm,
						"Unknown hash algorithm; suggest using {0}.",
						((int) AssemblyHashAlgorithm.SHA1).ToString ("X8"));

				codegen.CurrentModule.Assembly.Name.HashAlgorithm = algo;
			}
			| customattr_decl
			{
				if ($1 != null) {
					codegen.CurrentModule.Assembly.CustomAttributes.Add ((CustomAttribute) $1);
					codegen.CurrentCustomAttribute = null;
				}
			}
			| sec_decl
			{
				codegen.CurrentModule.Assembly.SecurityDeclarations.Add (codegen.CurrentSecurityDeclaration);
				codegen.CurrentSecurityDeclaration = null;
			}
			| comp_control
			;

assemblyref_all		: assemblyref_head OPEN_BRACE assemblyref_decls CLOSE_BRACE
			{
				var asmRef = codegen.CurrentAssemblyReference;
				var asmRefAlias = asmRef as AliasedAssemblyNameReference;
				var name = asmRefAlias != null ? asmRefAlias.Alias : asmRef.Name;

				// If we already have a reference with this name, we
				// ignore the one we just built.
				if (codegen.GetAliasedAssemblyReference (name) == null) {
					// If we have a public key and a token, we prefer the
					// token. Cecil prefers the public key, so we have to
					// do this ourselves.
					if (has_public_key && has_public_key_token) {
						var token = asmRef.PublicKeyToken;
						asmRef.PublicKey = null;
						asmRef.PublicKeyToken = token;
					}

					if (asmRefAlias != null)
						codegen.AliasedAssemblyReferences.Add (asmRefAlias.Alias, asmRefAlias);

					codegen.CurrentModule.AssemblyReferences.Add (asmRef);
				}
				else
					report.WriteWarning (Warning.AssemblyReferenceIgnored,
						"Redeclaration of assembly '{0}' ignored.", name);

				codegen.CurrentAssemblyReference = null;
				has_public_key = false;
				has_public_key_token = false;
			}
			;

assemblyref_head	: D_ASSEMBLY K_EXTERN asm_attr comp_name_str
			{
				codegen.CurrentAssemblyReference = new AssemblyNameReference ((string) $4,
					new Version (0, 0, 0, 0)) {
					Attributes = (AssemblyAttributes) $3,
				};
			}
			| D_ASSEMBLY K_EXTERN asm_attr comp_name_str K_AS comp_name_str
			{

				codegen.CurrentAssemblyReference = new AliasedAssemblyNameReference ((string) $4,
					new Version (0, 0, 0, 0)) {
					Alias = (string) $6,
					Attributes = (AssemblyAttributes) $3,
				};
			}
			;

assemblyref_decls	:
			| assemblyref_decls assemblyref_decl
			;

assemblyref_decl	: D_VER int32 COLON int32 COLON int32 COLON int32
			{
				codegen.CurrentAssemblyReference.Version =
					new Version ((int) $2, (int) $4, (int) $6, (int) $8);
			}
			| D_PUBLICKEY ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.PublicKey = (byte[]) $3;
				has_public_key = true;
			}
			| D_PUBLICKEYTOKEN ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.PublicKeyToken = (byte[]) $3;
				has_public_key_token = true;
			}
			| locale_or_culture comp_qstring
			{
				codegen.CurrentAssemblyReference.Culture = (string) $2;
			}
			| locale_or_culture ASSIGN bytes_list
			{
				// See the note in assembly_decl -> D_LOCALE.
				var text = Encoding.Unicode.GetString ((byte[]) $3);
				codegen.CurrentAssemblyReference.Culture = text;
			}
			| D_HASH ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.Hash = (byte[]) $3;
			}
			| K_AUTO // TODO: Implement this.
			| customattr_decl // TODO: How do we set CAs on assembly name refs?
			| comp_control
			;

// TODO: Finish exported types.
exptype_all		: exptype_head OPEN_BRACE exptype_decls CLOSE_BRACE
			;

exptype_directive	: D_CLASS K_EXTERN
			| D_EXPORT
			;

exptype_head		: exptype_directive expt_attr comp_name
			{
				var qn = (QualifiedName) $3;

				$$ = new Tuple<QualifiedName, TypeAttributes> (qn, (TypeAttributes) $2);
			}
			;

expt_attr 		:
			{
				$$ = TypeAttributes.NotPublic;
			}
			| expt_attr K_PRIVATE			{ $$ = (TypeAttributes) $1 | TypeAttributes.NotPublic; }
			| expt_attr K_PUBLIC			{ $$ = (TypeAttributes) $1 | TypeAttributes.Public; }
			| expt_attr K_FORWARDER			{ $$ = (TypeAttributes) $1 | TypeAttributes.Forwarder; }
			| expt_attr K_NESTED K_PUBLIC		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPublic; }
			| expt_attr K_NESTED K_PRIVATE		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPrivate; }
			| expt_attr K_NESTED K_FAMILY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamily; }
			| expt_attr K_NESTED K_ASSEMBLY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedAssembly; }
			| expt_attr K_NESTED K_FAMANDASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamANDAssem; }
			| expt_attr K_NESTED K_FAMORASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamORAssem; }
			;

exptype_decls		:
			| exptype_decls exptype_decl
			{
				// Just use the last declaration.
				$$ = $2;
			}
			;

exptype_decl		: D_FILE comp_name // TODO: Handle this case.
			| D_CLASS K_EXTERN comp_name
			{
				$$ = codegen.GetTypeByName ((QualifiedName) $3);
			}
			| D_ASSEMBLY K_EXTERN comp_name_str
			{
				$$ = codegen.GetAssemblyReference ((string) $3);
			}
			| mdtoken_type
			| D_CLASS int32
			{
				$$ = $2;
			}
			| customattr_decl
			| comp_control
			;

manifestres_all		: manifestres_head OPEN_BRACE manifestres_decls CLOSE_BRACE
			{
				var head = $1 as Tuple<ManifestResourceAttributes, string>;
				var aliasedHead = $1 as Tuple<ManifestResourceAttributes, string, string>;

				string resName;
				string fileName;
				ManifestResourceAttributes attr;

				if (aliasedHead != null) {
					attr = aliasedHead.X;
					resName = aliasedHead.Y;
					fileName = aliasedHead.Z;
				} else {
					attr = head.X;
					resName = head.Y;
					fileName = head.Y;
				}

				Resource rsc;

				object resourceArg = null;
				var decls = (List<object>) $3;

				for (var i = 0; i < decls.Count; i++) {
					var decl = decls [i];

					if (!(decl is CustomAttribute)) {
						decls.Remove (decl);
						resourceArg = decl;
					}
				}

				if (resourceArg != null) {
					var asmDecl = resourceArg as string;

					if (asmDecl != null) {
						var asmRef = codegen.GetAssemblyReference (asmDecl);
						rsc = new AssemblyLinkedResource (resName, attr, asmRef);
					} else {
						// TODO: Propagate nometadata/.entrypoint/offset.
						// TODO: Error if the file was not declared with .file.
						var fileDecl = resourceArg as Tuple<string, int>;
						rsc = new LinkedResource (resName, attr, fileDecl.X);
					}
				} else {
					byte[] bytes = null;

					try
					{
						bytes = File.ReadAllBytes (fileName);
					}
					catch (IOException ex)
					{
						report.WriteError (Error.ResourceFileError,
							"Could not read embedded resource file '{0}': {1}",
								fileName, ex.Message);
					}

					rsc = new EmbeddedResource (resName, attr, bytes);
				}

				// TODO: Cecil doesn't support CAs on resources yet.
				//foreach (var cattr in decls)
				//	rsc.CustomAttributes.Add ((CustomAttribute) cattr);

				codegen.CurrentModule.Resources.Add (rsc);
			}
			;

manifestres_head	: D_MRESOURCE manres_attr comp_name_str
			{
				$$ = new Tuple<ManifestResourceAttributes, string> ((ManifestResourceAttributes) $2,
					(string) $3);
			}
			| D_MRESOURCE manres_attr comp_name_str K_AS comp_name_str
			{
				$$ = new Tuple<ManifestResourceAttributes, string, string> ((ManifestResourceAttributes) $2,
					(string) $3, (string) $5);
			}
			;

manres_attr		:
			{
				$$ = (ManifestResourceAttributes) 0;
			}
			| manres_attr K_PUBLIC
			{
				// Blame Microsoft for this madness.
				$$ = ((ManifestResourceAttributes) $1 != 0 && (ManifestResourceAttributes) $1 !=
					ManifestResourceAttributes.Public) ? 0 : ManifestResourceAttributes.Public;
			}
			| manres_attr K_PRIVATE
			{
				$$ = ((ManifestResourceAttributes) $1 != 0 && (ManifestResourceAttributes) $1 !=
					ManifestResourceAttributes.Private) ? 0 : ManifestResourceAttributes.Private;
			} 
			;

manifestres_decls	:
			{
				$$ = new List<object> ();
			}
			| manifestres_decl
			{
				$$ = new List<object> {
					$1,
				};
			}
			| manifestres_decls manifestres_decl
			{
				((List<object>) $1).Add ($2);
			}
			;

manifestres_decl	: D_FILE comp_name_str K_AT int32
			{
				$$ = new Tuple<string, int> ((string) $2,
					(int) $4);
			}
			| D_ASSEMBLY K_EXTERN comp_name_str
			{
				$$ = (string) $3;
			}
			| customattr_decl
			| comp_control
			;

slashed_name		: comp_name
			| slashed_name SLASH comp_name
			{
				var sl = (QualifiedName) $1;

				var qn = new QualifiedName {
					Name = ((QualifiedName) $3).FullName, // TODO: Verify this.
				};

				foreach (var ns in sl.Namespaces)
					qn.Namespaces.Add (ns);

				foreach (var nesting in sl.Nestings)
					qn.Nestings.Add (nesting);

				qn.Nestings.Add (sl.Name);

				$$ = qn;
			}
			;

mdtoken			: K_MDTOKEN OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = $3;
			}
			;

comp_qstring		: QSTRING
			| comp_qstring PLUS QSTRING
			{
				$$ = string.Format ("{0}{1}", $1, $3);
			}
			;

int32			: INT64
			{
				$$ = BitConverter.ToInt32 (BitConverter.GetBytes ((long) $1),
					BitConverter.IsLittleEndian ? 0 : 4);
			}
			;

int64			: INT64
			;

float64			: FLOAT64
			| K_FLOAT32 OPEN_PARENS INT32 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((int) $3), 0);
			}
			| K_FLOAT32 OPEN_PARENS INT64 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((long) $3),
					BitConverter.IsLittleEndian ? 0 : 4);
			}
			| K_FLOAT64 OPEN_PARENS INT64 CLOSE_PARENS
			{
				$$ = BitConverter.ToDouble (BitConverter.GetBytes ((long) $3), 0);
			}
			| K_FLOAT64 OPEN_PARENS INT32 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((int) $3), 0);
			}
			;

hexbyte			: HEXBYTE
			;

bytes_list		: OPEN_PARENS
			{
				tokenizer.InByteArray  = true;
			}
			  bytes CLOSE_PARENS
			{
				tokenizer.InByteArray  = false;

				$$ = $3;
			}
			;

bytes			:
			{
				$$ = new byte [0];
			}
			| hexbytes
			{
				$$ = ((List<byte>) $1).ToArray ();
			}
			;

hexbytes		: hexbyte
			{
				$$ = new List<byte> {
					Convert.ToByte ($1),
				};
			}
			| hexbytes hexbyte
			{
				((List<byte>) $1).Add (Convert.ToByte ($2));
			}
			;

truefalse		: K_TRUE
			{
				$$ = true;
			}
			| K_FALSE
			{
				$$ = false;
			}
			;

opt_id			:
			| id
			;

id			: ID
			| SQSTRING
			;

comp_name_str		: comp_name
			{
				$$ = ((QualifiedName) $1).FullName;
			}
			;

comp_name		: id
			{
				// HACK: A bug exists in the tokenizer, which causes it
				// to feed us an ID token with dots. We work around this
				// for now.
				var str = (string) $1;
				var nspaces = str.Split ('.');

				var qn = new QualifiedName {
					Name = nspaces [nspaces.Length - 1],
				};

				for (var i = 0; i < nspaces.Length; i++)
					if (i != nspaces.Length - 1)
						qn.Namespaces.Add (nspaces [i]);

				$$ = qn;
			}
			| COMP_NAME
			{
				var strings = ((string) $1).Split ('.');

				var qn = new QualifiedName {
					Name = strings [1],
				};
				qn.Namespaces.Add (strings [0]);

				$$ = qn;
			}
			| comp_name DOT comp_name
			{
				var n1 = (QualifiedName) $1;
				var n2 = (QualifiedName) $3;

				var qn = new QualifiedName {
					Name = n2.Name,
				};

				foreach (var ns in n1.Namespaces)
					qn.Namespaces.Add (ns);

				qn.Namespaces.Add (n1.Name);

				foreach (var ns in n2.Namespaces)
					qn.Namespaces.Add (ns);

				$$ = qn;
			}
			;

%%

}
