%{
//
// Mono.ILAsm.ILParser
// 
// (C) Sergey Chaban (serge@wildwestsoftware.com)
// (C) 2003 Jackson Harper, All rights reserved
// (C) 2011 Alex RÃ¸nne Petersen <xtzgzorex@gmail.com>
//

using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Mono.Cecil;

namespace Mono.ILAsm {
	internal class ILParser {
		static readonly int yacc_verbose_flag = 0;
		readonly CodeGenerator codegen;
		readonly ILTokenizer tokenizer;
		readonly Report report;
		readonly Stack<string> namespace_stack = new Stack<string> ();
		bool is_enum_class;
		bool is_value_class;
		bool has_public_key;
		bool has_public_key_token;
		bool is_explicit_call;
		bool is_instance_call;
		bool is_parameter_marshal_notation;

		public ILParser (Report report, CodeGenerator codegen, ILTokenizer tokenizer)
		{
			this.report = report;
			this.codegen = codegen;
			this.tokenizer = tokenizer;
		}

%}

%token UNKNOWN
%token EOF
%token ID
%token QSTRING
%token SQSTRING
%token COMP_NAME
%token INT32
%token INT64
%token FLOAT64
%token HEXBYTE

%token DOT "."
%token OPEN_BRACE "{"
%token CLOSE_BRACE "}"
%token OPEN_BRACKET "["
%token CLOSE_BRACKET "]"
%token OPEN_PARENS "("
%token CLOSE_PARENS ")"
%token COMMA ","
%token COLON ":"
%token DOUBLE_COLON "::"
%token SEMICOLON ";"
%token ASSIGN "="
%token STAR "*"
%token AMPERSAND "&"
%token PLUS "+"
%token SLASH "/"
%token BANG "!"
%token ELLIPSIS "..."
%token DASH "-"
%token OPEN_ANGLE_BRACKET "<"
%token CLOSE_ANGLE_BRACKET ">"

%token INSTR_NONE
%token INSTR_VAR
%token INSTR_I
%token INSTR_I8
%token INSTR_R
%token INSTR_BRTARGET
%token INSTR_METHOD
%token INSTR_NEWOBJ
%token INSTR_FIELD
%token INSTR_TYPE
%token INSTR_STRING
%token INSTR_SIG
%token INSTR_RVA
%token INSTR_TOK
%token INSTR_SWITCH
%token INSTR_PHI
%token INSTR_LOCAL
%token INSTR_PARAM

%token D_ASSEMBLY
%token D_CCTOR
%token D_CLASS
%token D_IMAGEBASE
%token D_CORFLAGS
%token D_CTOR
%token D_CUSTOM
%token D_DATA
%token D_EMITBYTE
%token D_ENTRYPOINT
%token D_EVENT
%token D_EXPORT
%token D_FIELD
%token D_FILE
%token D_FIRE
%token D_GET
%token D_HASH
%token D_LANGUAGE
%token D_LINE
%token D_XLINE
%token D_LOCALE
%token D_CULTURE
%token D_LOCALIZED
%token D_LOCALS
%token D_MAXSTACK
%token D_METHOD
%token D_MODULE
%token D_MRESOURCE
%token D_MANIFESTRES
%token D_NAMESPACE
%token D_OTHER
%token D_OVERRIDE
%token D_PACK
%token D_PARAM
%token D_PERMISSION
%token D_PERMISSIONSET
%token D_PROPERTY
%token D_PUBLICKEY
%token D_PUBLICKEYTOKEN
%token D_ADDON
%token D_REMOVEON
%token D_SET
%token D_SIZE
%token D_STACKRESERVE
%token D_SUBSYSTEM
%token D_TRY
%token D_VER
%token D_VTABLE
%token D_VTENTRY
%token D_VTFIXUP
%token D_ZEROINIT
%token D_THIS
%token D_BASE
%token D_NESTER
%token D_TYPELIST
%token D_MSCORLIB
%token D_PDIRECT

%token K_AT
%token K_AS
%token K_IMPLICITCOM
%token K_IMPLICITRES
%token K_EXTERN
%token K_INSTANCE
%token K_EXPLICIT
%token K_DEFAULT
%token K_VARARG
%token K_UNMANAGED
%token K_CDECL
%token K_STDCALL
%token K_THISCALL
%token K_FASTCALL
%token K_MARSHAL
%token K_IN
%token K_OUT
%token K_OPT
%token K_STATIC
%token K_PUBLIC
%token K_PRIVATE
%token K_FAMILY
%token K_INITONLY
%token K_RTSPECIALNAME
%token K_STRICT
%token K_SPECIALNAME
%token K_ASSEMBLY
%token K_FAMANDASSEM
%token K_FAMORASSEM
%token K_PRIVATESCOPE
%token K_LITERAL
%token K_NOTSERIALIZED
%token K_VALUE
%token K_NOT_IN_GC_HEAP
%token K_INTERFACE
%token K_SEALED
%token K_ABSTRACT
%token K_AUTO
%token K_SEQUENTIAL
%token K_ANSI
%token K_UNICODE
%token K_AUTOCHAR
%token K_BESTFIT
%token K_IMPORT
%token K_SERIALIZABLE
%token K_NESTED
%token K_EXTENDS
%token K_IMPLEMENTS
%token K_FINAL
%token K_VIRTUAL
%token K_HIDEBYSIG
%token K_NEWSLOT
%token K_UNMANAGEDEXP
%token K_PINVOKEIMPL
%token K_NOMANGLE
%token K_LASTERR
%token K_WINAPI
%token K_PLATFORMAPI
%token K_NATIVE
%token K_IL
%token K_CIL
%token K_OPTIL
%token K_MANAGED
%token K_FORWARDREF
%token K_RUNTIME
%token K_INTERNALCALL
%token K_SYNCHRONIZED
%token K_NOINLINING
%token K_CUSTOM
%token K_FIXED
%token K_SYSSTRING
%token K_ARRAY
%token K_VARIANT
%token K_CURRENCY
%token K_SYSCHAR
%token K_VOID
%token K_BOOL
%token K_INT8
%token K_INT16
%token K_INT32
%token K_INT64
%token K_FLOAT
%token K_FLOAT32
%token K_FLOAT64
%token K_ERROR
%token K_UNSIGNED
%token K_UINT
%token K_UINT8
%token K_UINT16
%token K_UINT32
%token K_UINT64
%token K_DECIMAL
%token K_DATE
%token K_BSTR
%token K_LPSTR
%token K_LPWSTR
%token K_LPTSTR
%token K_OBJECTREF
%token K_IUNKNOWN
%token K_IDISPATCH
%token K_STRUCT
%token K_SAFEARRAY
%token K_INT
%token K_BYVALSTR
%token K_TBSTR
%token K_LPVOID
%token K_ANY
%token K_FLOAT
%token K_LPSTRUCT
%token K_NULL
%token K_PTR
%token K_VECTOR
%token K_HRESULT
%token K_CARRAY
%token K_USERDEFINED
%token K_RECORD
%token K_FILETIME
%token K_BLOB
%token K_STREAM
%token K_STORAGE
%token K_STREAMED_OBJECT
%token K_STORED_OBJECT
%token K_BLOB_OBJECT
%token K_CF
%token K_CLSID
%token K_METHOD
%token K_CLASS
%token K_PINNED
%token K_MODREQ
%token K_MODOPT
%token K_TYPEDREF
%token K_TYPE
%token K_CHAR
%token K_WCHAR
%token K_FROMUNMANAGED
%token K_CALLMOSTDERIVED
%token K_BYTEARRAY
%token K_WITH
%token K_INIT
%token K_TO
%token K_CATCH
%token K_FILTER
%token K_FINALLY
%token K_FAULT
%token K_HANDLER
%token K_TLS
%token K_FIELD
%token K_PROPERTY
%token K_REQUEST
%token K_DEMAND
%token K_ASSERT
%token K_DENY
%token K_PERMITONLY
%token K_LINKCHECK
%token K_INHERITCHECK
%token K_REQMIN
%token K_REQOPT
%token K_REQREFUSE
%token K_PREJITGRANT
%token K_PREJITDENY
%token K_NONCASDEMAND
%token K_NONCASLINKDEMAND
%token K_NONCASINHERITANCE
%token K_NOMETADATA
%token K_ALGORITHM
%token K_RETARGETABLE
%token K_LEGACY
%token K_LIBRARY
%token K_X86
%token K_IA64
%token K_AMD64
%token K_PRESERVESIG
%token K_BEFOREFIELDINIT
%token K_ALIGNMENT
%token K_NULLREF
%token K_VALUETYPE
%token K_COMPILERCONTROLLED
%token K_REQSECOBJ
%token K_ENUM
%token K_OBJECT
%token K_STRING
%token K_TRUE
%token K_FALSE
%token K_ON
%token K_OFF
%token K_CHARMAPERROR
%token K_MDTOKEN
%token K_FLAGS
%token K_CALLCONV
%token K_NOAPPDOMAIN
%token K_NOMACHINE
%token K_NOPROCESS
%token K_ILLEGAL
%token K_UNUSED
%token K_WRAPPER
%token K_FORWARDER

%start il_file

%%

il_file			: decls
			;

decls			:
			| decls decl
			;

decl			:
			class_all
			| namespace_all
			/*
			| method_all
			*/
			| field_decl
			| data_decl
			| vtable_decl
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtable is currently unimplemented (directive ignored).");
			}
			| vtfixup_decl
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtfixup is currently unimplemented (directive ignored).");
			}
			| file_decl
			| assembly_all
			| assemblyref_all
			| exptype_all
			| manifestres_all
			| module_head
			/*
			| sec_decl
			| customattr_decl
			*/
			| D_SUBSYSTEM int32
			{
				codegen.CurrentModule.Kind = (ModuleKind) $2;
			}
			| D_CORFLAGS int32
			{
				codegen.CurrentModule.Attributes = (ModuleAttributes) $2;
			}
			// TODO: Find a way to set these with Cecil.
			| D_FILE K_ALIGNMENT int32
			{
				var fa = (int) $3;

				if (fa < 0x200 || fa > 0x10000 || (fa & (fa - 1)) != 0) {
					report.WriteError (Error.InvalidFileAlignment,
						"Invalid file alignment; must be a power of two between 0x200 and 0x10000.");
				}
			}
			| D_IMAGEBASE int64
			{
				var ib = (long) $2;

				if ((ib & 0xffff) != 0) {
					report.WriteError (Error.InvalidImageBase,
						"Invalid image base; must be 0x10000-aligned.");
				}
			}
			| D_STACKRESERVE int64
			| D_TYPELIST OPEN_BRACE class_refs CLOSE_BRACE // TODO: How can we sort with Cecil?
			| D_MSCORLIB
			{
				// TODO: We need to set image base to 0x00510000 here.
				codegen.IsCorlib = true;
			}
			| extsource_spec
			| language_decl
			;

// TODO: Persist these in MDB.
extsource_spec		: D_LINE int32 SQSTRING
			| D_LINE int32
			| D_LINE int32 COLON int32 SQSTRING
			| D_LINE int32 COLON int32
			;

// TODO: Persist these in MDB.
language_decl		: D_LANGUAGE SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING COMMA SQSTRING
			;

vtable_decl		: D_VTABLE ASSIGN OPEN_PARENS bytes CLOSE_PARENS
			;

vtfixup_decl		: D_VTFIXUP OPEN_BRACKET int32 CLOSE_BRACKET vtfixup_attr K_AT id
			;

vtfixup_attr		:
			| vtfixup_attr K_INT32
			| vtfixup_attr K_INT64
			| vtfixup_attr K_FROMUNMANAGED
			| vtfixup_attr K_CALLMOSTDERIVED
			;

namespace_all		: namespace_head OPEN_BRACE decls CLOSE_BRACE
			{
				report.WriteWarning (Warning.LegacyNamespaceSyntax,
					"Use of legacy namespace syntax.");

				codegen.CurrentNamespace = namespace_stack.Pop ();
			}
			;

namespace_head		: D_NAMESPACE comp_name
			{
				namespace_stack.Push (codegen.CurrentNamespace);

				if (codegen.CurrentNamespace != string.Empty)
					codegen.CurrentNamespace += ".";

				codegen.CurrentNamespace += ((QualifiedName) $2).FullName;
			}
			;

class_all		: class_head OPEN_BRACE class_decls CLOSE_BRACE
			{
				codegen.CurrentModule.Types.Add (codegen.CurrentType);
				codegen.CurrentType = null;
			}
			;

class_head		: D_CLASS class_attr comp_name
			{
				var qn = (QualifiedName) $3;

				codegen.CurrentType = new TypeDefinition (codegen.CurrentNamespace +
					qn.FullNamespace, qn.Name, (TypeAttributes) $2);

				codegen.CurrentGenericParameterProvider = codegen.CurrentType;
			}
			  formal_typars_clause extends_clause impl_clause
			{
				foreach (var arg in (List<GenericParameter>) $5)
					codegen.CurrentType.GenericParameters.Add (arg);

				codegen.CurrentGenericParameterProvider = null;

				if ($6 == null) {
					if (is_value_class)
						codegen.CurrentType.BaseType = codegen.Corlib.ValueType;
					else if (is_enum_class)
						codegen.CurrentType.BaseType = codegen.Corlib.Enum;
					else
						codegen.CurrentType.BaseType = codegen.Corlib.Object;
				} else
					codegen.CurrentType.BaseType = (TypeReference) $6;

				if ($7 != null)
					foreach (var interf in (List<TypeReference>) $7)
						codegen.CurrentType.Interfaces.Add (interf);
			}
			;

class_attr		:
			{
				is_value_class = false;
				is_enum_class = false;
				$$ = TypeAttributes.NotPublic;
			}
			| class_attr K_PUBLIC			{ $$ = (TypeAttributes) $1 | TypeAttributes.Public; }
			| class_attr K_PRIVATE
			| class_attr K_NESTED K_PRIVATE		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPrivate; }
			| class_attr K_NESTED K_PUBLIC		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPublic; }
			| class_attr K_NESTED K_FAMILY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamily; }
			| class_attr K_NESTED K_ASSEMBLY	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedAssembly;}
			| class_attr K_NESTED K_FAMANDASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamANDAssem; }
			| class_attr K_NESTED K_FAMORASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamORAssem; }
			| class_attr K_VALUE			{ is_value_class = true; }
			| class_attr K_ENUM			{ is_enum_class = true; }
			| class_attr K_INTERFACE		{ $$ = (TypeAttributes) $1 | TypeAttributes.Interface; }
			| class_attr K_SEALED			{ $$ = (TypeAttributes) $1 | TypeAttributes.Sealed; }
			| class_attr K_ABSTRACT			{ $$ = (TypeAttributes) $1 | TypeAttributes.Abstract; }
			| class_attr K_AUTO
			| class_attr K_SEQUENTIAL		{ $$ = (TypeAttributes) $1 | TypeAttributes.SequentialLayout; }
			| class_attr K_EXPLICIT			{ $$ = (TypeAttributes) $1 | TypeAttributes.ExplicitLayout; }
			| class_attr K_ANSI
			| class_attr K_UNICODE			{ $$ = (TypeAttributes) $1 | TypeAttributes.UnicodeClass; }
			| class_attr K_AUTOCHAR			{ $$ = (TypeAttributes) $1 | TypeAttributes.AutoClass; }
			| class_attr K_IMPORT			{ $$ = (TypeAttributes) $1 | TypeAttributes.Import; }
			| class_attr K_SERIALIZABLE		{ $$ = (TypeAttributes) $1 | TypeAttributes.Serializable; }
			| class_attr K_BEFOREFIELDINIT		{ $$ = (TypeAttributes) $1 | TypeAttributes.BeforeFieldInit; }
			| class_attr K_SPECIALNAME		{ $$ = (TypeAttributes) $1 | TypeAttributes.SpecialName; }
			| class_attr K_RTSPECIALNAME		{ $$ = (TypeAttributes) $1 | TypeAttributes.RTSpecialName; }
			| class_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (TypeAttributes) $1 | (TypeAttributes) (int) $4;
			}
			;

extends_clause		:
			| K_EXTENDS type_spec
			{
				$$ = $2;
			}
			;

impl_clause		:
			| impl_class_refs
			;

impl_class_refs		: K_IMPLEMENTS type_spec
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $2,
				};
			}
			| impl_class_refs COMMA type_spec
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

formal_typars_clause	:
			{
				$$ = new List<GenericParameter> ();
			}
			| OPEN_ANGLE_BRACKET formal_typars CLOSE_ANGLE_BRACKET
			{
				$$ = $2;
			}
			;

formal_typars		: formal_typar_attr constraints_clause formal_typar
			{
				var gp = new GenericParameter (((QualifiedName) $3).FullName,
					codegen.CurrentGenericParameterProvider) {
					Attributes = (GenericParameterAttributes) $1,
				};

				if ($2 != null)
					foreach (var constraint in (List<TypeReference>) $2)
						gp.Constraints.Add (constraint);

				$$ = new List<GenericParameter> () {
					gp,
				};
			}
			| formal_typars COMMA formal_typar_attr constraints_clause formal_typar
			{
				var colln = (List<GenericParameter>) $1;

				var gp = new GenericParameter (((QualifiedName) $5).FullName,
					codegen.CurrentGenericParameterProvider) {
					Attributes = (GenericParameterAttributes) $3,
				};

				if ($4 != null)
					foreach (var constraint in (List<TypeReference>) $4)
						gp.Constraints.Add (constraint);

				colln.Add (gp);
			}
			;

formal_typar_attr	:
			{
				$$ = GenericParameterAttributes.NonVariant;
			}
			| formal_typar_attr PLUS { $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.Covariant; }
			| formal_typar_attr DASH { $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.Contravariant; }
			| formal_typar_attr D_CTOR { $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.DefaultConstructorConstraint; }
			| formal_typar_attr K_VALUETYPE { $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.NotNullableValueTypeConstraint; }
			| formal_typar_attr K_CLASS { $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.ReferenceTypeConstraint; }
			;

formal_typar		: comp_name
			{
				$$ = $1;
			}
			;

constraints_clause	:
			| OPEN_PARENS constraints CLOSE_PARENS
			{
				$$ = $2;
			}
			;

constraints		: type_spec
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| constraints COMMA type_spec
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

class_decls		:
			| class_decls class_decl
			;

class_decl		: /*method_all
			| class_all
			| event_all
			*/
			| prop_all
			| field_decl
			| data_decl
			/*
			| sec_decl
			*/
			| extsource_spec
			/*
			| customattr_decl
			| param_type_decl
			*/
			| D_SIZE int32
			{
				codegen.CurrentType.ClassSize = (int) $2;
			}
			| D_PACK int32
			{
				codegen.CurrentType.PackingSize = (short) (int) $2;
			}
			/*
			| D_OVERRIDE type_spec DOUBLE_COLON method_name K_WITH call_conv type type_spec DOUBLE_COLON method_name type_list
			{
				BaseTypeRef owner = (BaseTypeRef) $2;
				ArrayList arg_list = (ArrayList) $11;
				BaseTypeRef[] param_list;
				BaseMethodRef decl;

				if (arg_list != null)
					param_list = (BaseTypeRef[]) arg_list.ToArray (typeof (BaseTypeRef));
				else
					param_list = new BaseTypeRef[0];

				decl = owner.GetMethodRef ((BaseTypeRef) $7,
					(CallConv) $6, (string) $4, param_list, 0);

				string sig = MethodDef.CreateSignature (owner,
					(CallConv) $6, (string) $10, param_list, 0, false);

				codegen.CurrentTypeDef.AddOverride (sig, decl);
			}
			  OPEN_PARENS sig_args CLOSE_PARENS
			*/
			| language_decl
			;

/*
param_type_decl		: D_PARAM K_TYPE id
			{
				if (codegen.CurrentMethodDef != null)
					codegen.CurrentCustomAttrTarget = codegen.CurrentMethodDef.GetGenericParam ((string) $3);
				else
					codegen.CurrentCustomAttrTarget = codegen.CurrentTypeDef.GetGenericParam ((string) $3);

				if (codegen.CurrentCustomAttrTarget == null)
					Report.Error (String.Format ("Type parameter '{0}' undefined.", (string) $3));
			}
			| D_PARAM K_TYPE OPEN_BRACKET int32 CLOSE_BRACKET
			{
				int index = ((int) $4);
				if (codegen.CurrentMethodDef != null)
					codegen.CurrentCustomAttrTarget = codegen.CurrentMethodDef.GetGenericParam (index - 1);
				else
					codegen.CurrentCustomAttrTarget = codegen.CurrentTypeDef.GetGenericParam (index - 1);

				if (codegen.CurrentCustomAttrTarget == null)
					Report.Error (String.Format ("Type parameter '{0}' index out of range.", index));
			}
			;
*/

class_refs		: class_ref
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| class_refs COMMA class_ref
			{
				var class_list = (List<TypeReference>) $1;
				class_list.Add ((TypeReference) $3);
			}
			;

class_ref		: OPEN_BRACKET comp_name CLOSE_BRACKET slashed_name
			{
				var name = (QualifiedName) $2;
				var type = (QualifiedName) $4;
				var scope = codegen.GetScope (name.FullName, false);

				$$ = new TypeReference (type.FullNamespace, type.Name, codegen.CurrentModule, scope);
			}
			| OPEN_BRACKET mdtoken CLOSE_BRACKET slashed_name
			| OPEN_BRACKET STAR CLOSE_BRACKET slashed_name // TODO: How does this work?
			| OPEN_BRACKET D_MODULE comp_name CLOSE_BRACKET slashed_name
			{
				var module = (QualifiedName) $3;
				var type = (QualifiedName) $5;

				if (module.FullName == codegen.CurrentModule.Name)
					$$ = codegen.GetTypeByName (type);
				else {
					var scope = codegen.GetScope (module.FullName, true);
					$$ = new TypeReference (type.FullNamespace,
						type.Name, codegen.CurrentModule, scope);
				}
			}
			| slashed_name
			{
				$$ = codegen.GetTypeByName ((QualifiedName) $1);
			}
			| mdtoken_type
			// TODO: Implement these.
			| D_THIS
			| D_BASE
			| D_NESTER
			;

mdtoken_type		: mdtoken
			{
				$$ = codegen.GetTypeByMetadataToken ((int) $1);
			}
			;

type			: K_CLASS class_ref
			{
				$$ = $2;
			}
			| K_VALUE K_CLASS class_ref
			{
				// TODO: Warn if not a value type?
				$$ = $3;
			}
			| K_VALUETYPE class_ref
			{
				// TODO: Warn if not a value type?
				$$ = $2;
			}
			| type OPEN_BRACKET CLOSE_BRACKET
			{
				$$ = new ArrayType ((TypeReference) $1);
			}
			| type OPEN_BRACKET bounds CLOSE_BRACKET
			{
				var bounds = (List<ArrayDimension>) $3;
				var type = new ArrayType ((TypeReference) $1, bounds.Count);

				for (var i = 0; i < bounds.Count; i++)
					type.Dimensions [i] = bounds [i];

				$$ = type;
			}
			| type AMPERSAND
			{
				$$ = new ByReferenceType ((TypeReference) $1);
			}
			| type STAR
			{
				$$ = new PointerType ((TypeReference) $1);
			}
			| type K_PINNED
			{
				$$ = new PinnedType ((TypeReference) $1);
			}
			| type K_MODREQ OPEN_PARENS type_spec CLOSE_PARENS
			{
				$$ = new RequiredModifierType ((TypeReference) $4, (TypeReference) $1);
			}
			| type K_MODOPT OPEN_PARENS type_spec CLOSE_PARENS
			{
				$$ = new OptionalModifierType ((TypeReference) $4, (TypeReference) $1);
			}
			| K_METHOD call_conv type STAR OPEN_PARENS sig_args CLOSE_PARENS
			{
				var func = new FunctionPointerType {
					CallingConvention = (MethodCallingConvention) $2,
					ReturnType = (TypeReference) $3,
				};

				if (is_instance_call)
					func.HasThis = true;

				if (is_explicit_call)
					func.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<ParameterDefinition>) $6)
					func.Parameters.Add (arg);

				$$ = func;
			}
			| type typars_clause
			{
				var typeArgs = (List<TypeReference>) $2;

				if (typeArgs.Count > 0) {
					var gti = new GenericInstanceType ((TypeReference) $1);

					foreach (var ga in typeArgs)
						gti.GenericArguments.Add (ga);

					$$ = gti;
				} else
					$$ = $1;
			}
			| BANG int32
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.GenericParameterAccessOutsideType,
						"Cannot access a generic parameter outside a type definition.");

				var idx = (int) $2;
				var genParams = codegen.CurrentType.GenericParameters;

				if (idx >= genParams.Count)
					report.WriteError (Error.GenericParameterOrdinalOutOfRange,
						"Generic parameter ordinal '{0}' is invalid.", idx);

				$$ = genParams [idx];
			}
			| BANG id
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.GenericParameterAccessOutsideType,
						"Cannot access a generic parameter outside a type definition.");

				var name = (string) $2;
				GenericParameter param = null;

				foreach (var genParam in codegen.CurrentType.GenericParameters)
					if (genParam.Name == name)
						param = genParam;

				if (param == null)
					report.WriteError (Error.GenericParameterNameInvalid,
						"Generic parameter name '{0}' is invalid.", name);

				$$ = param;
			}
			| BANG BANG int32
			{
				if (codegen.CurrentMethod == null)
					report.WriteError (Error.GenericParameterAccessOutsideMethod,
						"Cannot access a generic parameter outside a method definition.");

				var idx = (int) $3;
				var genParams = codegen.CurrentMethod.GenericParameters;

				if (idx >= genParams.Count)
					report.WriteError (Error.GenericParameterOrdinalOutOfRange,
						"Generic parameter ordinal '{0}' is invalid.", idx);

				$$ = genParams [idx];
			}
			| BANG BANG id
			{
				if (codegen.CurrentMethod == null)
					report.WriteError (Error.GenericParameterAccessOutsideMethod,
						"Cannot access a generic parameter outside a method definition.");

				var name = (string) $3;
				GenericParameter param = null;

				foreach (var genParam in codegen.CurrentMethod.GenericParameters)
					if (genParam.Name == name)
						param = genParam;

				if (param == null)
					report.WriteError (Error.GenericParameterNameInvalid,
						"Generic parameter name '{0}' is invalid.", name);

				$$ = param;
			}
			| K_OBJECT			{ $$ = codegen.Corlib.Object; }
			| K_VOID			{ $$ = codegen.Corlib.Void; }
			| K_TYPEDREF			{ $$ = codegen.Corlib.TypedReference; }
			| K_NATIVE K_INT		{ $$ = codegen.Corlib.IntPtr; }
			| K_NATIVE K_UNSIGNED K_INT	{ $$ = codegen.Corlib.UIntPtr; }
			| K_NATIVE K_UINT		{ $$ = codegen.Corlib.UIntPtr; }
			| K_NATIVE K_FLOAT		{ $$ = codegen.Corlib.Single; } // TODO: Verify this.
			| simple_type
			| ELLIPSIS type
			{
				$$ = new SentinelType ((TypeReference) $2);
			}
			;

unsigned_int8		: K_UINT8
			| K_UNSIGNED K_INT8
			;

unsigned_int16		: K_UINT16
			| K_UNSIGNED K_INT16
			;

unsigned_int32		: K_UINT32
			| K_UNSIGNED K_INT32
			;

unsigned_int64		: K_UINT64
			| K_UNSIGNED K_INT64
			;

int_type		: K_INT8			{ $$ = codegen.Corlib.SByte; }
			| K_INT16			{ $$ = codegen.Corlib.Int16; }
			| K_INT32			{ $$ = codegen.Corlib.Int32; }
			| K_INT64			{ $$ = codegen.Corlib.Int64; }
			| unsigned_int8			{ $$ = codegen.Corlib.Byte; }
			| unsigned_int16		{ $$ = codegen.Corlib.UInt16; }
			| unsigned_int32		{ $$ = codegen.Corlib.UInt32; }
			| unsigned_int64		{ $$ = codegen.Corlib.UInt64; }

simple_type		: K_FLOAT32			{ $$ = codegen.Corlib.Single; }
			| K_FLOAT64			{ $$ = codegen.Corlib.Double; }
			| K_CHAR			{ $$ = codegen.Corlib.Char; }
			| K_BOOL			{ $$ = codegen.Corlib.Boolean; }
			| K_STRING			{ $$ = codegen.Corlib.String; }
			| int_type
			;

typars_clause_opt	:
			| typars_clause
			;

typars_clause		: OPEN_ANGLE_BRACKET typars CLOSE_ANGLE_BRACKET
			{
				$$ = $2;
			}
			;

typars			: type
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| typars COMMA type
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
				$$ = $1;
			}
			;

type_spec		: class_ref
			| OPEN_BRACKET slashed_name CLOSE_BRACKET // TODO: What do we do with this?
			| OPEN_BRACKET D_MODULE slashed_name CLOSE_BRACKET
			{
				var module = (string) $3;

				if (module == codegen.CurrentModule.Name)
					$$ = codegen.CurrentModule.GetModuleType ();
				else {
					var mod = codegen.GetModuleReference (module);

					if (mod == null)
						report.WriteError (Error.UndeclaredModuleReference,
							"Use of undeclared module: {0}", module);

					$$ = new TypeReference (string.Empty, "<Module>",
						codegen.CurrentModule, mod);
				}
			}
			| type
			;

bounds			: bound
			{
				$$ = new List<ArrayDimension> {
					(ArrayDimension) $1,
				};
			}
			| bounds COMMA bound
			{
				((List<ArrayDimension>) $1).Add ((ArrayDimension) $3);
			}
			;

bound			:
			{
				$$ = new ArrayDimension (null, null);
			}
			| ELLIPSIS
			{
				$$ = new ArrayDimension (null, null);
			}
			| int32
			{
				var size = (int) $1;

				if (size < 0) {
					report.WriteWarning (Warning.NegativeArraySize,
						"Negative array size '{0}' set to 0.", size);

					$$ = new ArrayDimension (0, 0);
				} else
					$$ = new ArrayDimension (0, size);
			}
			| int32 ELLIPSIS int32
			{
				var lower = (int) $1;
				var upper = (int) $3;

				$$ = new ArrayDimension (lower, upper);
			}
			| int32 ELLIPSIS
			{
				$$ = new ArrayDimension ((int) $1, null);
			}
			;

call_conv		: K_INSTANCE call_conv { is_instance_call = true; $$ = $2 ?? MethodCallingConvention.Default; }
			| K_EXPLICIT call_conv { is_explicit_call = true; $$ = $2 ?? MethodCallingConvention.Default; }
			| call_kind
			| K_CALLCONV OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (MethodCallingConvention) $3;
			}
			;

call_kind		:
			{
				$$ = MethodCallingConvention.Default;
			}
			| K_DEFAULT			{ $$ = MethodCallingConvention.Default; }
			| K_VARARG			{ $$ = MethodCallingConvention.VarArg; }
			| K_UNMANAGED K_CDECL		{ $$ = MethodCallingConvention.C; }
			| K_UNMANAGED K_STDCALL		{ $$ = MethodCallingConvention.StdCall; }
			| K_UNMANAGED K_THISCALL	{ $$ = MethodCallingConvention.ThisCall; }
			| K_UNMANAGED K_FASTCALL	{ $$ = MethodCallingConvention.FastCall; }
			;

marshal_info		:
			/*
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring CLOSE_PARENS
			{
			}
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring COMMA comp_qstring COMMA comp_qstring CLOSE_PARENS
			{
			}
			*/
			| K_FIXED K_SYSSTRING OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new FixedSysStringMarshalInfo {
					Size = (int) $4,
				};
			}
			| K_FIXED K_ARRAY OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new FixedArrayMarshalInfo {
					Size = (int) $4,
				};
			}
			| marshal_type STAR
			{
				report.WriteWarning (Warning.DeprecatedNativeType,
					"Pointer syntax for native types is deprecated.");

				// Emit an invalid native type. Don't ask me how this works;
				// blame Microsoft's ILAsm.
				$$ = new MarshalInfo ((NativeType) 0);
			}
			| marshal_type OPEN_BRACKET CLOSE_BRACKET
			{
				// This is not Microsoft-compatible. I have no idea how they
				// calculate the values they emit for jagged arrays.
				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
				};
			}
			| marshal_type OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					Size = (int) $3,
				};
			}
			| marshal_type OPEN_BRACKET int32 PLUS int32 CLOSE_BRACKET
			{
				is_parameter_marshal_notation = true;

				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					Size = (int) $3,
					SizeParameterMultiplier = (int) $5,
				};
			}
			| marshal_type OPEN_BRACKET PLUS int32 CLOSE_BRACKET
			{
				is_parameter_marshal_notation = true;

				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					SizeParameterMultiplier = (int) $4,
				};
			}
			| K_SAFEARRAY variant_type
			{
				$$ = new SafeArrayMarshalInfo {
					ElementType = (VariantType) $2,
				};
			}
			| marshal_type
			{
				$$ = new MarshalInfo ((NativeType) $1);
			}
			;

unsigned_int		: K_UINT
			| K_UNSIGNED K_INT
			;

marshal_type		: K_CURRENCY				{ $$ = NativeType.Currency; }
			| K_BOOL				{ $$ = NativeType.Boolean; }
			| K_INT8				{ $$ = NativeType.I1; }
			| K_INT16				{ $$ = NativeType.I2; }
			| K_INT32				{ $$ = NativeType.I4; }
			| K_INT64				{ $$ = NativeType.I8; }
			| K_FLOAT32				{ $$ = NativeType.R4; }
			| K_FLOAT64				{ $$ = NativeType.R8; }
			| K_ERROR				{ $$ = NativeType.Error; }
			| unsigned_int8				{ $$ = NativeType.U1; }
			| unsigned_int16			{ $$ = NativeType.U2; }
			| unsigned_int32			{ $$ = NativeType.U4; }
			| unsigned_int64			{ $$ = NativeType.U8; }
			| K_BSTR				{ $$ = NativeType.BStr; }
			| K_LPSTR				{ $$ = NativeType.LPStr; }
			| K_LPWSTR				{ $$ = NativeType.LPWStr; }
			| K_LPTSTR				{ $$ = NativeType.LPTStr; }
			| K_IUNKNOWN				{ $$ = NativeType.IUnknown; }
			| K_IDISPATCH				{ $$ = NativeType.IDispatch; }
			| K_STRUCT				{ $$ = NativeType.Struct; }
			| K_INTERFACE				{ $$ = NativeType.IntF; }
			| K_INT					{ $$ = NativeType.Int; }
			| unsigned_int				{ $$ = NativeType.UInt; }
			| K_BYVALSTR				{ $$ = NativeType.ByValStr; }
			| K_ANSI K_BSTR				{ $$ = NativeType.ANSIBStr; }
			| K_TBSTR				{ $$ = NativeType.TBStr; }
			| K_VARIANT K_BOOL			{ $$ = NativeType.VariantBool; }
			| K_METHOD				{ $$ = NativeType.Func; }
			| K_AS K_ANY				{ $$ = NativeType.ASAny; }
			| K_LPSTRUCT				{ $$ = NativeType.LPStruct; }
			| native_type
			{
				// The grammar supports these types, but we can't
				// actually use them.
				report.WriteError(Error.UnsupportedNativeType,
					"Unsupported native type used in marshaling signature.");
			}
			;

native_type		: K_VARIANT
			| K_VOID
			| K_SYSCHAR
			| K_DECIMAL
			| K_DATE
			| K_OBJECTREF
			| K_NESTED K_STRUCT
			;

safearray_type		: K_VARIANT		{ $$ = VariantType.Variant; }
			| K_CURRENCY		{ $$ = VariantType.CY; }
			| K_BOOL		{ $$ = VariantType.Bool; }
			| K_INT8		{ $$ = VariantType.I1; }
			| K_INT16		{ $$ = VariantType.I2; }
			| K_INT32		{ $$ = VariantType.I4; }
			| K_FLOAT32		{ $$ = VariantType.R4; }
			| K_FLOAT64		{ $$ = VariantType.R8; }
			| unsigned_int8		{ $$ = VariantType.UI1; }
			| unsigned_int16	{ $$ = VariantType.UI2; }
			| unsigned_int32	{ $$ = VariantType.UI4; }
			| K_DECIMAL		{ $$ = VariantType.Decimal; }
			| K_DATE		{ $$ = VariantType.Date; }
			| K_BSTR		{ $$ = VariantType.BStr; }
			| K_IUNKNOWN		{ $$ = VariantType.Unknown; }
			| K_IDISPATCH		{ $$ = VariantType.Dispatch; }
			| K_INT 		{ $$ = VariantType.Int; }
			| unsigned_int		{ $$ = VariantType.UInt; }
			| K_ERROR		{ $$ = VariantType.Error; }
			| variant_type
			{
				// The grammar supports these types, but we can't
				// actually use them.
				report.WriteError(Error.UnsupportedVariantType,
					"Unsupported variant type used in safe array signature.");
			}
			;

variant_type		: K_NULL
			| K_VOID
			| K_INT64
			| unsigned_int64
			| STAR
			| variant_type OPEN_BRACKET CLOSE_BRACKET
			| variant_type K_VECTOR
			| variant_type AMPERSAND
			| K_LPSTR
			| K_LPWSTR
			| K_SAFEARRAY
			| K_HRESULT
			| K_CARRAY
			| K_USERDEFINED
			| K_RECORD
			| K_FILETIME
			| K_BLOB
			| K_STREAM
			| K_STORAGE
			| K_STREAMED_OBJECT
			| K_STORED_OBJECT
			| K_BLOB_OBJECT
			| K_CF
			| K_CLSID
			;

field_decl		: D_FIELD repeat_opt field_attr marshal_spec type id at_opt init_opt
			{
				var isGlobal = codegen.CurrentType == null;
				var attrs = (FieldAttributes) $3;
				var isStatic = attrs.HasBitFlag(FieldAttributes.Static);

				if (isGlobal && !isStatic)
				{
					attrs |= FieldAttributes.Static;

					report.WriteWarning (Warning.GlobalFieldMadeStatic,
						"Global field made static.");
				}

				var field = new FieldDefinition((string) $6, attrs, (TypeReference) $5);

				if ($2 != null) {
					if (!isGlobal)
						field.Offset = (int) $2;
					else
						report.WriteWarning (Warning.GlobalFieldOffsetIgnored,
							"Offset for global field ignored.");
				}

				if ($4 != null) {
					if (is_parameter_marshal_notation) {
						// TODO: This warning should be emitted more closely to the relevant code.
						report.WriteWarning (Warning.ParameterMarshalNotationOnField,
							"Invalid use of array marshal notation for parameters on a field.");

						is_parameter_marshal_notation = false;
					}

					field.MarshalInfo = (MarshalInfo) $4;
				}

				if ($7 != null) {
					if (!isStatic)
						report.WriteError (Error.InstanceFieldWithDataLocation,
							"Instance fields cannot have an associated data location.");

					var dataLoc = (string) $7;
					var mapping = codegen.GetFieldDataMapping (codegen.CurrentType ?? codegen.CurrentModule.GetModuleType ());
					mapping.Add (field, dataLoc);
				}

				if ($8 != null)
					field.Constant = $8 is Null ? null : $8;

				if (isGlobal)
					codegen.CurrentModule.GetModuleType ().Fields.Add (field);
				else
					codegen.CurrentType.Fields.Add (field);
			}
			;

repeat_opt		:
			| OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = $2;
			}
			;

field_attr		:
			{
				$$ = FieldAttributes.CompilerControlled;
			}
			| field_attr K_PUBLIC		{ $$ = (FieldAttributes) $1 | FieldAttributes.Public; }
			| field_attr K_PRIVATE		{ $$ = (FieldAttributes) $1 | FieldAttributes.Private; }
			| field_attr K_FAMILY		{ $$ = (FieldAttributes) $1 | FieldAttributes.Family; }
			| field_attr K_ASSEMBLY		{ $$ = (FieldAttributes) $1 | FieldAttributes.Assembly; }
			| field_attr K_FAMANDASSEM	{ $$ = (FieldAttributes) $1 | FieldAttributes.FamANDAssem; }
			| field_attr K_FAMORASSEM	{ $$ = (FieldAttributes) $1 | FieldAttributes.FamORAssem; }
			| field_attr K_PRIVATESCOPE
			| field_attr K_STATIC		{ $$ = (FieldAttributes) $1 | FieldAttributes.Static; }
			| field_attr K_INITONLY		{ $$ = (FieldAttributes) $1 | FieldAttributes.InitOnly; }
			| field_attr K_RTSPECIALNAME	{ $$ = (FieldAttributes) $1 | FieldAttributes.RTSpecialName; }
			| field_attr K_SPECIALNAME	{ $$ = (FieldAttributes) $1 | FieldAttributes.SpecialName; }
			| field_attr K_LITERAL		{ $$ = (FieldAttributes) $1 | FieldAttributes.Literal; }
			| field_attr K_NOTSERIALIZED	{ $$ = (FieldAttributes) $1 | FieldAttributes.NotSerialized; }
			;

marshal_spec		:
			| K_MARSHAL OPEN_PARENS marshal_info CLOSE_PARENS
			{
				$$ = $3;
			}
			;

at_opt			:
			| K_AT id
			{
				$$ = $2;
			}
			;

init_opt		:
			| ASSIGN field_init
			{
				$$ = $2;
			}
			;

field_init_primitive	: K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = (float) (double) $3;
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_FLOAT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = BitConverter.ToSingle (BitConverter.GetBytes ((long) $3), BitConverter.IsLittleEndian ? 0 : 4);
			}
			| K_FLOAT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = BitConverter.Int64BitsToDouble ((long) $3);
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = $3;
			}
			| unsigned_int64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (ulong) (long) $3;
			}
			| K_INT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (int) (long) $3;
			}
			| unsigned_int32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (uint) (long) $3;
			}
			| K_INT16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (short) (long) $3;
			}
			| unsigned_int16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (ushort) (long) $3;
			}
			| K_INT8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (sbyte) (long) $3;
			}
			| unsigned_int8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (byte) (long) $3;
			}
			| K_CHAR OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (char) (long) $3;
			}
			| K_BOOL OPEN_PARENS truefalse CLOSE_PARENS
			{
				$$ = $3;
			}
			;

field_init		: field_init_primitive
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			| comp_qstring
			| K_NULLREF
			{
				$$ = new Null ();
			}
			;

data_decl		: data_head data_body
			{
				if ($1 != null)
				{
					foreach (var item in (List<object>) $2)
						codegen.DataConstants.Add ((string) $1, item);

					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Data constants are currently just copied to static fields.");
				}
				else
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Unlabeled data constants currently have no effect.");
			}
			;

data_name		:
			| id ASSIGN
			{
				$$ = $1;
			}
			;

data_head		: D_DATA tls cil data_name
			{
				if ((bool) $2)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"TLS data constants are not currently supported.");

				if ((bool) $3)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"CIL data constants are not currently supported.");

				$$ = $4;
			}
			;

tls			:
			{
				$$ = false;
			}
			| K_TLS
			{
				$$ = true;
			}
			;

cil			:
			{
				$$ = false;
			}
			| K_CIL
			{
				$$ = true;
			}
			;

data_body		: OPEN_BRACE dataitem_list CLOSE_BRACE
			{
				$$ = $2;
			}
			| dataitem
			{
				$$ = new List<object> {
					$1,
				};
			}
			;

dataitem_list		: dataitem
			{
				$$ = new List<object> {
					$1,
				};
			}
			| dataitem_list COMMA dataitem
			{
				((List<object>) $1).Add ($3);
			}
			;

data_repeat_opt		: repeat_opt
			{
				if ($1 != null)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Repeated data constants currently have no effect.");
			}
			;

dataitem		: K_CHAR STAR OPEN_PARENS comp_qstring CLOSE_PARENS
			{
				$$ = $4;
			}
			| AMPERSAND OPEN_PARENS id CLOSE_PARENS
			{
				$$ = IntPtr.Zero;
			}
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			| K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS data_repeat_opt
			{
				$$ = (float) (double) $3;
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_INT32 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_INT16 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = (short) (int) $3;
			}
			| K_INT8 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = (byte) (int) $3;
			}
			| K_FLOAT32 data_repeat_opt
			{
				$$ = 0.0f;
			}
			| K_FLOAT64 data_repeat_opt
			{
				$$ = 0.0d;
			}
			| K_INT64 data_repeat_opt
			{
				$$ = (long) 0;
			}
			| K_INT32 data_repeat_opt
			{
				$$ = (int) 0;
			}
			| K_INT16 data_repeat_opt
			{
				$$ = (short) 0;
			}
			| K_INT8 data_repeat_opt
			{
				$$ = (byte) 0;
			}
			;

/*
method_all		: method_head OPEN_BRACE method_decls CLOSE_BRACE
			{
				codegen.EndMethodDef (tokenizer.Location);
			}
			;

method_head		: D_METHOD meth_attr call_conv param_attr type method_name formal_typars_clause OPEN_PARENS sig_args CLOSE_PARENS impl_attr
			{
				CallConv cc = (CallConv) $3;
				if ($7 != null)
					cc |= CallConv.Generic;

				MethodDef methdef = new MethodDef (codegen, (MethAttr) $2, cc,
					(ImplAttr) $11, (string) $6, (BaseTypeRef) $5, (ArrayList) $9,
					tokenizer.Reader.Location, (GenericParameters) $7,
					codegen.CurrentTypeDef);

				if (pinvoke_info) {
					ExternModule mod = codegen.ExternTable.AddModule (pinvoke_mod);
					methdef.AddPInvokeInfo (pinvoke_attr, mod, pinvoke_meth);
					pinvoke_info = false;
				}
			}
			| D_METHOD meth_attr call_conv param_attr type K_MARSHAL OPEN_PARENS native_type CLOSE_PARENS method_name OPEN_PARENS sig_args CLOSE_PARENS impl_attr
			{
				MethodDef methdef = new MethodDef (codegen, (MethAttr) $2, (CallConv) $3,
					(ImplAttr) $14, (string) $10, (BaseTypeRef) $5, (ArrayList) $12,
					tokenizer.Reader.Location, null, codegen.CurrentTypeDef);

					if (pinvoke_info) {
						ExternModule mod = codegen.ExternTable.AddModule (pinvoke_mod);
						methdef.AddPInvokeInfo (pinvoke_attr, mod, pinvoke_meth);
						pinvoke_info = false;
					}

				methdef.AddRetTypeMarshalInfo ((NativeType) $8);
			}
			;

meth_attr		:
			{
				$$ = new MethAttr ();
			}
			| meth_attr K_STATIC			{ $$ = (MethAttr) $1 | MethAttr.Static; }
			| meth_attr K_PUBLIC			{ $$ = (MethAttr) $1 | MethAttr.Public; }
			| meth_attr K_PRIVATE			{ $$ = (MethAttr) $1 | MethAttr.Private; }
			| meth_attr K_FAMILY			{ $$ = (MethAttr) $1 | MethAttr.Family; }
			| meth_attr K_ASSEMBLY			{ $$ = (MethAttr) $1 | MethAttr.Assembly; }
			| meth_attr K_FAMANDASSEM		{ $$ = (MethAttr) $1 | MethAttr.FamAndAssem; } 
			| meth_attr K_FAMORASSEM		{ $$ = (MethAttr) $1 | MethAttr.FamOrAssem; } 
			| meth_attr K_PRIVATESCOPE
			| meth_attr K_FINAL			{ $$ = (MethAttr) $1 | MethAttr.Final; } 
			| meth_attr K_VIRTUAL			{ $$ = (MethAttr) $1 | MethAttr.Virtual; }
			| meth_attr K_ABSTRACT			{ $$ = (MethAttr) $1 | MethAttr.Abstract; }
			| meth_attr K_HIDEBYSIG			{ $$ = (MethAttr) $1 | MethAttr.HideBySig; }
			| meth_attr K_NEWSLOT			{ $$ = (MethAttr) $1 | MethAttr.NewSlot; }
			| meth_attr K_REQSECOBJ			{ $$ = (MethAttr) $1 | MethAttr.RequireSecObject; }
			| meth_attr K_SPECIALNAME		{ $$ = (MethAttr) $1 | MethAttr.SpecialName; }
			| meth_attr K_RTSPECIALNAME		{ $$ = (MethAttr) $1 | MethAttr.RTSpecialName; }
			| meth_attr K_STRICT			{ $$ = (MethAttr) $1 | MethAttr.Strict; }
			| meth_attr K_COMPILERCONTROLLED
			| meth_attr K_UNMANAGEDEXP
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring K_AS comp_qstring pinv_attr CLOSE_PARENS
			{
				pinvoke_info = true;
				pinvoke_mod = (string) $4;
				pinvoke_meth = (string) $6;
				pinvoke_attr = (PInvokeAttr) $7;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring pinv_attr CLOSE_PARENS
			{
				pinvoke_info = true;
				pinvoke_mod = (string) $4;
				pinvoke_meth = null;
				pinvoke_attr = (PInvokeAttr) $5;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS pinv_attr CLOSE_PARENS
			{
				pinvoke_info = true;
				pinvoke_mod = null;
				pinvoke_meth = null;
				pinvoke_attr = (PInvokeAttr) $4;
			}
			;

pinv_attr		:
			{
				$$ = new PInvokeAttr ();
			}
			| pinv_attr K_NOMANGLE			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.nomangle; }
			| pinv_attr K_ANSI			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.ansi; }
			| pinv_attr K_UNICODE			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.unicode; }
			| pinv_attr K_AUTOCHAR			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.autochar; }
			| pinv_attr K_LASTERR			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.lasterr; }
			| pinv_attr K_WINAPI			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.winapi; }
			| pinv_attr K_PLATFORMAPI		{ $$ = (PInvokeAttr) $1 | PInvokeAttr.winapi; }
			| pinv_attr K_CDECL			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.cdecl; }
			| pinv_attr K_STDCALL			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.stdcall; }
			| pinv_attr K_THISCALL			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.thiscall; }
			| pinv_attr K_FASTCALL			{ $$ = (PInvokeAttr) $1 | PInvokeAttr.fastcall; }
			| pinv_attr K_BESTFIT COLON K_ON	{ $$ = (PInvokeAttr) $1 | PInvokeAttr.bestfit_on; }
			| pinv_attr K_BESTFIT COLON K_OFF	{ $$ = (PInvokeAttr) $1 | PInvokeAttr.bestfit_off; }
			| pinv_attr K_CHARMAPERROR COLON K_ON	{ $$ = (PInvokeAttr) $1 | PInvokeAttr.charmaperror_on; }
			| pinv_attr K_CHARMAPERROR COLON K_OFF	{ $$ = (PInvokeAttr) $1 | PInvokeAttr.charmaperror_off; }
			;
*/

method_name		: D_CTOR
			| D_CCTOR
			| comp_name
			{
				$$ = ((QualifiedName) $1).FullName;
			}
			;

/*
impl_attr		:
			{
				$$ = new ImplAttr ();
			}
			| impl_attr K_NATIVE		{ $$ = (ImplAttr) $1 | ImplAttr.Native; }
			| impl_attr K_CIL		{ $$ = (ImplAttr) $1 | ImplAttr.IL; }
			| impl_attr K_IL		{ $$ = (ImplAttr) $1 | ImplAttr.IL; }
			| impl_attr K_OPTIL		{ $$ = (ImplAttr) $1 | ImplAttr.Optil; }
			| impl_attr K_MANAGED
			| impl_attr K_UNMANAGED		{ $$ = (ImplAttr) $1 | ImplAttr.Unmanaged; }
			| impl_attr K_FORWARDREF	{ $$ = (ImplAttr) $1 | ImplAttr.ForwardRef; }
			| impl_attr K_PRESERVESIG	{ $$ = (ImplAttr) $1 | ImplAttr.PreserveSig; }
			| impl_attr K_RUNTIME		{ $$ = (ImplAttr) $1 | ImplAttr.Runtime; }
			| impl_attr K_INTERNALCALL	{ $$ = (ImplAttr) $1 | ImplAttr.InternalCall; }
			| impl_attr K_SYNCHRONIZED	{ $$ = (ImplAttr) $1 | ImplAttr.Synchronised; }
			| impl_attr K_NOINLINING	{ $$ = (ImplAttr) $1 | ImplAttr.NoInLining; }
			;
*/

param_attr		:
			{
				$$ = ParameterAttributes.None;
			}
			| param_attr OPEN_BRACKET K_IN CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.In; }
			| param_attr OPEN_BRACKET K_OUT CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.Out; }
			| param_attr OPEN_BRACKET K_OPT CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.Optional; }
			| param_attr OPEN_BRACKET int32 CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | (ParameterAttributes) (int) $3; }
			;

sig_args		:
			{
				$$ = new List<ParameterDefinition> ();
			}
			| sig_arg_list
			;

sig_arg_list 		: sig_arg
			{
				$$ = new List<ParameterDefinition> {
					(ParameterDefinition) $1,
				};
			}
			| sig_arg_list COMMA sig_arg
			{
				((List<ParameterDefinition>) $1).Add ((ParameterDefinition) $3);
			}
			;

sig_marshal_clause	:
			| K_MARSHAL OPEN_PARENS marshal_type CLOSE_PARENS
			{
				$$ = new MarshalInfo ((NativeType) $3);
			}
			;

sig_arg			: ELLIPSIS // TODO: Construct the sentinel type...
			| param_attr type sig_marshal_clause
			{
				$$ = new ParameterDefinition ((TypeReference) $2) {
					Attributes = (ParameterAttributes) $1,
					MarshalInfo = $3 != null ? (MarshalInfo) $3 : null,
				};
			}
			| param_attr type sig_marshal_clause id
			{
				$$ = new ParameterDefinition ((string) $4, (ParameterAttributes) $1,
					(TypeReference) $2) {
					MarshalInfo = $3 != null ? (MarshalInfo) $3 : null,
				};
			}
			;

/*
type_list		:
			{
				$$ = new ArrayList ();
			}
			| ELLIPSIS
			{
				ArrayList type_list = new ArrayList ();
				// type_list.Add (TypeRef.Ellipsis);
				type_list.Add (new SentinelTypeRef ());
				$$ = type_list;
			}
			| type_list COMMA ELLIPSIS
			{
				ArrayList type_list = (ArrayList) $1;
				// type_list.Add (TypeRef.Ellipsis);
				type_list.Add (new SentinelTypeRef ());
				$$ = type_list;
			}
			| param_attr type opt_id
			{
				ArrayList type_list = new ArrayList ();
				type_list.Add ($2);
				$$ = type_list;
			}
			| type_list COMMA param_attr type opt_id
			{
				ArrayList type_list = (ArrayList) $1;
				type_list.Add ($4);
			}
			;
*/

opt_id			:
			| id
			;

/*
method_decls		:
			| method_decls method_decl
			;

method_decl		: D_EMITBYTE int32
			{
				codegen.CurrentMethodDef.AddInstr (new EmitByteInstr ((int) $2, tokenizer.Location));
			}
			| D_MAXSTACK int32
			{
				codegen.CurrentMethodDef.SetMaxStack ((int) $2);
			}
			| D_LOCALS OPEN_PARENS local_list CLOSE_PARENS
			{
				if ($3 != null)
					codegen.CurrentMethodDef.AddLocals ((ArrayList) $3);
			}
			| D_LOCALS K_INIT OPEN_PARENS local_list CLOSE_PARENS
			{
				if ($4 != null) {
					codegen.CurrentMethodDef.AddLocals ((ArrayList) $4);
					codegen.CurrentMethodDef.InitLocals ();
				}
			}
			| D_ENTRYPOINT
			{
				codegen.CurrentMethodDef.EntryPoint ();
				codegen.HasEntryPoint = true;
			}
			| D_ZEROINIT
			{
				codegen.CurrentMethodDef.ZeroInit ();
			}
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET K_AS id
			| D_VTENTRY int32 COLON int32 
			| D_OVERRIDE type_spec DOUBLE_COLON method_name
			{
				codegen.CurrentTypeDef.AddOverride (codegen.CurrentMethodDef,
					(BaseTypeRef) $2, (string) $4);
			}
			| D_OVERRIDE K_METHOD method_ref
			{
				codegen.CurrentTypeDef.AddOverride (codegen.CurrentMethodDef.Signature,
					(BaseMethodRef) $3);
			}
			| D_OVERRIDE K_METHOD call_conv type type_spec DOUBLE_COLON method_name OPEN_ANGLE_BRACKET OPEN_BRACKET int32 CLOSE_BRACKET CLOSE_ANGLE_BRACKET OPEN_PARENS type_list CLOSE_PARENS 
			{
				BaseTypeRef owner = (BaseTypeRef) $5;
				ArrayList arg_list = (ArrayList) $14;
				BaseTypeRef[] param_list;
				BaseMethodRef methref;

				if (arg_list != null)
					param_list = (BaseTypeRef[]) arg_list.ToArray (typeof (BaseTypeRef));
				else
					param_list = new BaseTypeRef [0];

				if (owner.UseTypeSpec) {
					methref = new TypeSpecMethodRef (owner, (CallConv) $3, (BaseTypeRef) $4,
						(string) $7, param_list, (int) $10);
				} else {
					methref = owner.GetMethodRef ((BaseTypeRef) $4, (CallConv) $3,
						(string) $7, param_list, (int) $10);
				}

				codegen.CurrentTypeDef.AddOverride (codegen.CurrentMethodDef.Signature,
					methref);
			}
			| scope_block
			| D_PARAM OPEN_BRACKET int32 CLOSE_BRACKET init_opt
			{
				int index = (int) $3;
				ParamDef param = codegen.CurrentMethodDef.GetParam (index);
				codegen.CurrentCustomAttrTarget = param;

				if (param == null) {
					Report.Warning (tokenizer.Location, String.Format ("invalid param index ({0}) with .param",
						index));
				} else if ($5 != null) {
					param.AddDefaultValue ((Constant) $5);
				}
			}
			| param_type_decl
			| id COLON
			{
				codegen.CurrentMethodDef.AddLabel ((string) $1);
			}
			| seh_block
			| instr
			| sec_decl
			{
				AddSecDecl ($1, false);
			}
			| extsource_spec
			| language_decl
			| customattr_decl
			{
				if (codegen.CurrentCustomAttrTarget != null)
					codegen.CurrentCustomAttrTarget.AddCustomAttribute ((CustomAttr) $1);
			}
			| data_decl
			;

local_list		:
			| local
			{
				ArrayList local_list = new ArrayList ();
				local_list.Add ($1);
				$$ = local_list;
			}
			| local_list COMMA local
			{
				ArrayList local_list = (ArrayList) $1;
				local_list.Add ($3);
			}
			;

local			: type
			{
				$$ = new Local (-1, (BaseTypeRef) $1);
			}
			| type id
			{
				$$ = new Local (-1, (string) $2, (BaseTypeRef) $1);
			}
			| slot_num type
			{
				$$ = new Local ((int) $1, (BaseTypeRef) $2);
			}
			| slot_num type id
			{
				$$ = new Local ((int) $1, (string) $3, (BaseTypeRef) $2);
			}
			;

slot_num		: OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = $2;
			}
			;

scope_block		: scope_block_begin method_decls CLOSE_BRACE
			{
				$$ = new HandlerBlock ((LabelInfo) $1,
					codegen.CurrentMethodDef.AddLabel ());
				codegen.CurrentMethodDef.EndLocalsScope ();
			}
			;

scope_block_begin	: OPEN_BRACE
			{
				$$ = codegen.CurrentMethodDef.AddLabel ();
				codegen.CurrentMethodDef.BeginLocalsScope ();
			}
			;
seh_block		: try_block seh_clauses
			{
				TryBlock try_block = (TryBlock) $1;

				ArrayList clause_list = (ArrayList) $2;
				foreach (object clause in clause_list)
					try_block.AddSehClause ((ISehClause) clause);

				codegen.CurrentMethodDef.AddInstr (try_block);
			}
			;

try_block		: D_TRY scope_block
			{
				$$ = new TryBlock ((HandlerBlock) $2, tokenizer.Location);
			}
			| D_TRY id K_TO id
			{
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabelRef ((string) $4);

				$$ = new TryBlock (new HandlerBlock (from, to), tokenizer.Location);
			}
			| D_TRY int32 K_TO int32
			{
				LabelInfo from = codegen.CurrentMethodDef.AddLabel ((int) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabel ((int) $4);

				$$ = new TryBlock (new HandlerBlock (from, to), tokenizer.Location);
			}
			;

seh_clauses		: seh_clause
			{
				ArrayList clause_list = new ArrayList ();
				clause_list.Add ($1);

				$$ = clause_list;
			}
			| seh_clauses seh_clause
			{
				ArrayList clause_list = (ArrayList) $1;
				clause_list.Add ($2);
			}
			;

seh_clause		: K_CATCH type handler_block
			{
				if ($2.GetType () == typeof (PrimitiveTypeRef))
					Report.Error ("Exception not be of a primitive type.");

				BaseTypeRef type = (BaseTypeRef) $2;
				CatchBlock cb = new CatchBlock (type);
				cb.SetHandlerBlock ((HandlerBlock) $3);

				$$ = cb;
			}
			| K_FINALLY handler_block
			{
				FinallyBlock fb = new FinallyBlock ();
				fb.SetHandlerBlock ((HandlerBlock) $2);

				$$ = fb;
			}
			| K_FAULT handler_block
			{
				FaultBlock fb = new FaultBlock ();
				fb.SetHandlerBlock ((HandlerBlock) $2);

				$$ = fb;
			}
			| filter_clause handler_block
			{
				FilterBlock fb = (FilterBlock) $1;
				fb.SetHandlerBlock ((HandlerBlock) $2);
			}
			;

filter_clause		: K_FILTER scope_block
			{
				HandlerBlock block = (HandlerBlock) $2;
				FilterBlock fb = new FilterBlock (block);

				$$ = fb;
			}
			| K_FILTER id
			{
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
					FilterBlock fb = new FilterBlock (new HandlerBlock (from, null));

				$$ = fb;
			}
			| K_FILTER int32
			{
				LabelInfo from = codegen.CurrentMethodDef.AddLabel ((int) $2);
				FilterBlock fb = new FilterBlock (new HandlerBlock (from, null));

				$$ = fb;
			}
			;

handler_block		: scope_block
			| K_HANDLER id K_TO id
			{
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabelRef ((string) $4);

				$$ = new HandlerBlock (from, to);
			}
			| K_HANDLER int32 K_TO int32
			{
				LabelInfo from = codegen.CurrentMethodDef.AddLabel ((int) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabel ((int) $4);

				$$ = new HandlerBlock (from, to);
			}
			;

instr			: INSTR_NONE
			{
				codegen.CurrentMethodDef.AddInstr (new SimpInstr ((Op) $1, tokenizer.Location));
			}
			| INSTR_LOCAL int32
			{
				codegen.CurrentMethodDef.AddInstr (new IntInstr ((IntOp) $1, (int) $2, tokenizer.Location));
			}
			| INSTR_LOCAL id
			{
				int slot = codegen.CurrentMethodDef.GetNamedLocalSlot ((string) $2);
				if (slot < 0)
					Report.Error (String.Format ("Undeclared identifier '{0}'", (string) $2));

				codegen.CurrentMethodDef.AddInstr (new IntInstr ((IntOp) $1, slot, tokenizer.Location));
			}
			| INSTR_PARAM int32
			{
				codegen.CurrentMethodDef.AddInstr (new IntInstr ((IntOp) $1, (int) $2, tokenizer.Location));
			}
			| INSTR_PARAM id
			{
				int pos = codegen.CurrentMethodDef.GetNamedParamPos ((string) $2);
				if (pos < 0)
					Report.Error (String.Format ("Undeclared identifier '{0}'", (string) $2));

				codegen.CurrentMethodDef.AddInstr (new IntInstr ((IntOp) $1, pos, tokenizer.Location));
			}
			| INSTR_I int32
			{
				codegen.CurrentMethodDef.AddInstr (new IntInstr ((IntOp) $1, (int) $2, tokenizer.Location));
			}
			| INSTR_I id
			{
				int slot = codegen.CurrentMethodDef.GetNamedLocalSlot ((string) $2);
				if (slot < 0)
					Report.Error (String.Format ("Undeclared identifier '{0}'", (string) $2));

				codegen.CurrentMethodDef.AddInstr (new IntInstr ((IntOp) $1, slot, tokenizer.Location));
			}
			| INSTR_I8 int64
			{
				if ($1 is MiscInstr) {
					switch ((MiscInstr) $1) {
					case MiscInstr.ldc_i8:
						codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1,
							(long) $2, tokenizer.Location));
						break;
					}
				}
			}
			| INSTR_R float64
			{
				switch ((MiscInstr) $1) {
				case MiscInstr.ldc_r4:
				case MiscInstr.ldc_r8:
					codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1,
						(double) $2, tokenizer.Location));
					break;
				}
			}
			| INSTR_R int64
			{
				long l = (long) $2;

				switch ((MiscInstr) $1) {
				case MiscInstr.ldc_r4:
				case MiscInstr.ldc_r8:
					codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1,
						(double) l, tokenizer.Location));
					break;
				}
			}
			| INSTR_R bytes_list
			{
				byte[] fpdata;

				switch ((MiscInstr) $1) {
				case MiscInstr.ldc_r4:
					fpdata = (byte[]) $2;
					if (!BitConverter.IsLittleEndian)
						System.Array.Reverse (fpdata, 0, 4);

					float s = BitConverter.ToSingle (fpdata, 0);
					codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1,
						s, tokenizer.Location));
					break;
				case MiscInstr.ldc_r8:
					fpdata = (byte[]) $2;
					if (!BitConverter.IsLittleEndian)
						System.Array.Reverse (fpdata, 0, 8);

					double d = BitConverter.ToDouble (fpdata, 0);
					codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1,
						d, tokenizer.Location));
					break;
				}
			}
			| INSTR_BRTARGET int32
			{
				LabelInfo target = codegen.CurrentMethodDef.AddLabel ((int) $2);
					codegen.CurrentMethodDef.AddInstr (new BranchInstr ((BranchOp) $1,
					target, tokenizer.Location));  
			}
			| INSTR_BRTARGET id
			{
				LabelInfo target = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
					codegen.CurrentMethodDef.AddInstr (new BranchInstr ((BranchOp) $1,
					target, tokenizer.Location));
			}
			| INSTR_METHOD method_ref
			{
				codegen.CurrentMethodDef.AddInstr (new MethodInstr ((MethodOp) $1,
					(BaseMethodRef) $2, tokenizer.Location));
			}
			| INSTR_FIELD type type_spec DOUBLE_COLON id
			{
				BaseTypeRef owner = (BaseTypeRef) $3;
				GenericParamRef gpr = $2 as GenericParamRef;

				if (gpr != null && codegen.CurrentMethodDef != null)
					codegen.CurrentMethodDef.ResolveGenParam ((PEAPI.GenParam) gpr.PeapiType);

				IFieldRef fieldref = owner.GetFieldRef ((BaseTypeRef) $2, (string) $5);
				codegen.CurrentMethodDef.AddInstr (new FieldInstr ((FieldOp) $1, fieldref, tokenizer.Location));
			}
			| INSTR_FIELD type id
			{
				GlobalFieldRef fieldref = codegen.GetGlobalFieldRef ((BaseTypeRef) $2, (string) $3);
				codegen.CurrentMethodDef.AddInstr (new FieldInstr ((FieldOp) $1, fieldref, tokenizer.Location));
			}
			| INSTR_TYPE type_spec
			{
				codegen.CurrentMethodDef.AddInstr (new TypeInstr ((TypeOp) $1,
					(BaseTypeRef) $2, tokenizer.Location));
			}
			| INSTR_STRING comp_qstring
			{
				if ((MiscInstr) $1 == MiscInstr.ldstr)
					codegen.CurrentMethodDef.AddInstr (new LdstrInstr ((string) $2, tokenizer.Location));
			}
			| INSTR_STRING K_BYTEARRAY ASSIGN bytes_list
			{
				byte[] bs = (byte[]) $4;
				if ((MiscInstr) $1 == MiscInstr.ldstr)
					codegen.CurrentMethodDef.AddInstr (new LdstrInstr (bs, tokenizer.Location));
			}
			| INSTR_STRING K_BYTEARRAY bytes_list
			{
				byte[] bs = (byte[]) $3;
				if ((MiscInstr) $1 == MiscInstr.ldstr)
					codegen.CurrentMethodDef.AddInstr (new LdstrInstr (bs, tokenizer.Location));
			}
			| INSTR_SIG call_conv type OPEN_PARENS type_list CLOSE_PARENS
			{
				ArrayList arg_list = (ArrayList) $5;
				BaseTypeRef[] arg_array = null;

				if (arg_list != null)
					arg_array = (BaseTypeRef[]) arg_list.ToArray (typeof (BaseTypeRef));

				codegen.CurrentMethodDef.AddInstr (new CalliInstr ((CallConv) $2,
					(BaseTypeRef) $3, arg_array, tokenizer.Location));
			}
			| INSTR_TOK owner_type
			{
				if ((MiscInstr) $1 == MiscInstr.ldtoken) {
					if ($2 is BaseMethodRef) {
						codegen.CurrentMethodDef.AddInstr (new LdtokenInstr ((BaseMethodRef) $2,
							tokenizer.Location));
					} else if ($2 is IFieldRef) {
						codegen.CurrentMethodDef.AddInstr (new LdtokenInstr ((IFieldRef) $2,
							tokenizer.Location));
					} else {
						codegen.CurrentMethodDef.AddInstr (new LdtokenInstr ((BaseTypeRef) $2,
							tokenizer.Location));
					}
				}
			}
			| INSTR_SWITCH OPEN_PARENS labels CLOSE_PARENS
			{
				codegen.CurrentMethodDef.AddInstr (new SwitchInstr ((ArrayList) $3, tokenizer.Location));
			}
			;
*/

method_ref		: call_conv type method_name typars_clause_opt OPEN_PARENS sig_args CLOSE_PARENS
			{
				var method = new MethodReference ((string) $3, (TypeReference) $2) {
					CallingConvention = (MethodCallingConvention) $1,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $6)
					method.Parameters.Add (new ParameterDefinition (arg));

				if ($4 != null) {
					var genMethod = new GenericInstanceMethod (method);

					foreach (var typeArg in (List<TypeReference>) $4)
						genMethod.GenericArguments.Add (typeArg);

					method = genMethod;
				}
			}
			| call_conv type type_spec DOUBLE_COLON method_name typars_clause_opt OPEN_PARENS sig_args CLOSE_PARENS
			{
				var method = new MethodReference ((string) $5, (TypeReference) $2, (TypeReference) $3) {
					CallingConvention = (MethodCallingConvention) $1,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $8)
					method.Parameters.Add (new ParameterDefinition (arg));

				if ($6 != null) {
					var genMethod = new GenericInstanceMethod (method);

					foreach (var typeArg in (List<TypeReference>) $6)
						genMethod.GenericArguments.Add (typeArg);

					method = genMethod;
				}
			}
			| mdtoken
			;

/*
labels			:
			| id
			{
				ArrayList label_list = new ArrayList ();
				label_list.Add (codegen.CurrentMethodDef.AddLabelRef ((string) $1));

				$$ = label_list;
			}
			| int32
			{
				ArrayList label_list = new ArrayList ();
				label_list.Add ($1);

				$$ = label_list;
			}
			| labels COMMA id
			{
				ArrayList label_list = (ArrayList) $1;
				label_list.Add (codegen.CurrentMethodDef.AddLabelRef ((string) $3));
			}
			| labels COMMA int32
			{
				ArrayList label_list = (ArrayList) $1;
				label_list.Add ($3);
			}
			;

owner_type		: type_spec
			| member_ref
			;

member_ref		: K_METHOD method_ref
			{
				$$ = $2;
			}
			| K_FIELD type type_spec DOUBLE_COLON id
			{
				BaseTypeRef owner = (BaseTypeRef) $3;

				$$ = owner.GetFieldRef ((BaseTypeRef) $2, (string) $5);
			}
			| K_FIELD type id
			{
				$$ = codegen.GetGlobalFieldRef ((BaseTypeRef) $2, (string) $3);
			}
			;

event_all		: event_head OPEN_BRACE event_decls CLOSE_BRACE
			{
				codegen.CurrentTypeDef.EndEventDef ();
			}
			;

event_head		: D_EVENT event_attr type_spec comp_name
			{
				EventDef event_def = new EventDef ((FeatureAttr) $2,
					(BaseTypeRef) $3, (string) $4);
				codegen.CurrentTypeDef.BeginEventDef (event_def);
				codegen.CurrentCustomAttrTarget = event_def;
			}
			| D_EVENT event_attr id
			;

event_attr		:
			{
				$$ = new FeatureAttr ();
			}
			| event_attr K_RTSPECIALNAME	{ $$ = (FeatureAttr) $1 & FeatureAttr.Rtspecialname; }
			| event_attr K_SPECIALNAME	{ $$ = (FeatureAttr) $1 & FeatureAttr.Specialname; }
			;

event_decls		:
			| event_decls event_decl
			;

event_decl		: D_ADDON method_ref
			{
				codegen.CurrentTypeDef.CurrentEvent.AddAddon ((MethodRef) $2);
			}
			| D_REMOVEON method_ref
			{
				codegen.CurrentTypeDef.CurrentEvent.AddRemoveon ((MethodRef) $2);
			}
			| D_FIRE method_ref
			{
				codegen.CurrentTypeDef.CurrentEvent.AddFire ((MethodRef) $2);
			}
			| D_OTHER method_ref
			{
				codegen.CurrentTypeDef.CurrentEvent.AddOther ((MethodRef) $2);
			}
			| customattr_decl
			{
				if (codegen.CurrentCustomAttrTarget != null)
					codegen.CurrentCustomAttrTarget.AddCustomAttribute ((CustomAttr) $1);
			}
			| extsource_spec
			| language_decl
			;
*/

prop_all		: prop_head OPEN_BRACE prop_decls CLOSE_BRACE
			{
				codegen.CurrentType.Properties.Add (codegen.CurrentProperty);
				codegen.CurrentProperty = null;
			}
			;

prop_head		: D_PROPERTY prop_attr type comp_name OPEN_PARENS sig_args CLOSE_PARENS init_opt
			{
				codegen.CurrentProperty = new PropertyDefinition (((QualifiedName) $4).FullName,
					(PropertyAttributes) $2, (TypeReference) $3);

				foreach (var param in (List<TypeReference>) $6)
					codegen.CurrentProperty.Parameters.Add (new ParameterDefinition (param));

				if ($8 != null)
					codegen.CurrentProperty.Constant = $8 is Null ? null : $8;
			}
			;

prop_attr 		:
			{
				$$ = PropertyAttributes.None;
			}
			| prop_attr K_RTSPECIALNAME	{ $$ = (PropertyAttributes) $1 | PropertyAttributes.RTSpecialName; }
			| prop_attr K_SPECIALNAME	{ $$ = (PropertyAttributes) $1 | PropertyAttributes.SpecialName; }
			;

prop_decls		:
			| prop_decls prop_decl
			;

prop_decl		: D_SET method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				// TODO: We should also error if the resolved method's type
				// is not the same as codegen.CurrentType.
				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve set method '{0}'.", methodRef);

				codegen.CurrentProperty.SetMethod = method;
			}
			| D_GET method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve get method '{0}'.", methodRef);

				codegen.CurrentProperty.GetMethod = method;
			}
			| D_OTHER method_ref
			{
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve other method '{0}'.", methodRef);

				codegen.CurrentProperty.OtherMethods.Add (method);
			}
			/*
			| customattr_decl
			*/
			| extsource_spec
			| language_decl
			;

/*
customattr_decl		: D_CUSTOM custom_type
			{
				$$ = new CustomAttr ((BaseMethodRef) $2, null);
			}
			| D_CUSTOM custom_type ASSIGN comp_qstring
			| D_CUSTOM custom_type ASSIGN bytes_list
			{
				$$ = new CustomAttr ((BaseMethodRef) $2, (byte[]) $4);
			}
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS custom_type
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS custom_type ASSIGN comp_qstring
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS custom_type ASSIGN bytes_list
			;

custom_type		: call_conv type type_spec DOUBLE_COLON method_name OPEN_PARENS type_list CLOSE_PARENS
			{
				BaseTypeRef owner = (BaseTypeRef) $3;
				ArrayList arg_list = (ArrayList) $7;
				BaseTypeRef[] param_list;

				if (arg_list != null)
					param_list = (BaseTypeRef[]) arg_list.ToArray (typeof (BaseTypeRef));
				else
					param_list = new BaseTypeRef[0];

				$$ = owner.GetMethodRef ((BaseTypeRef) $2,
					(CallConv) $1, (string) $5, param_list, 0);
			}
			| call_conv type method_name OPEN_PARENS type_list CLOSE_PARENS
			{
				ArrayList arg_list = (ArrayList) $5;
				BaseTypeRef[] param_list;

				if (arg_list != null)
					param_list = (BaseTypeRef[]) arg_list.ToArray (typeof (BaseTypeRef));
				else
					param_list = new BaseTypeRef[0];

				$$ = codegen.GetGlobalMethodRef ((BaseTypeRef) $2, (CallConv) $1,
					(string) $3, param_list, 0);
			}
			;

sec_decl		: D_PERMISSION sec_action type_spec OPEN_PARENS nameval_pairs CLOSE_PARENS
			{
				$$ = TypeSpecToPermPair ($2, $3, (ArrayList) $5);
			}
			| D_PERMISSION sec_action type_spec
			{
				$$ = TypeSpecToPermPair ($2, $3, null);
			}
			| D_PERMISSIONSET sec_action ASSIGN bytes_list
			{
				System.Text.UnicodeEncoding ue = new System.Text.UnicodeEncoding ();
				PermissionSetAttribute psa = new PermissionSetAttribute ((System.Security.Permissions.SecurityAction) (short) $2);
				psa.XML = ue.GetString ((byte []) $4);
				$$ = new PermPair ((Mono.Cecil.SecurityAction) $2, psa.CreatePermissionSet ());
			}
			| D_PERMISSIONSET sec_action comp_qstring
			{
				PermissionSetAttribute psa = new PermissionSetAttribute ((System.Security.Permissions.SecurityAction) (short) $2);
				psa.XML = (string) $3;
				$$ = new PermPair ((Mono.Cecil.SecurityAction) $2, psa.CreatePermissionSet ());
			}
			| D_PERMISSIONSET sec_action ASSIGN OPEN_BRACE permissions CLOSE_BRACE
			{
				$$ = new MIPermissionSet ((Mono.Cecil.SecurityAction) $2, (ArrayList) $5);
			}
			;

permissions		: permission
			{
				ArrayList list = new ArrayList ();
				list.Add ($1);
				$$ = list;
			}
			| permissions COMMA permission
			{
				ArrayList list = (ArrayList) $1;
				list.Add ($3);
				$$ = list;
			}
			;

permission		: class_ref ASSIGN OPEN_BRACE permission_members CLOSE_BRACE
			{
				$$ = new MIPermission ((BaseTypeRef) $1, (ArrayList) $4);
			}
			;

permission_members	: permission_member
			{
				ArrayList list = new ArrayList ();
				list.Add ($1);
				$$ = list;
			}
			| permission_members permission_member
			{
				ArrayList list = (ArrayList) $1;
				list.Add ($2);
				$$ = list;
			}
			;

permission_member	: prop_or_field primitive_type perm_mbr_nameval_pair
			{
				NameValuePair pair = (NameValuePair) $3;
				$$ = new PermissionMember ((MemberTypes) $1, (BaseTypeRef) $2, pair.Name, pair.Value);
			}
			| prop_or_field K_ENUM class_ref perm_mbr_nameval_pair
			{
				NameValuePair pair = (NameValuePair) $4;
				$$ = new PermissionMember ((MemberTypes) $1, (BaseTypeRef) $3, pair.Name, pair.Value);
			}
			;

perm_mbr_nameval_pair	: SQSTRING ASSIGN field_init_primitive
			{
				$$ = new NameValuePair ((string) $1, (PEAPI.Constant) $3);
			}
			| SQSTRING ASSIGN K_BYTEARRAY bytes_list
			{
				$$ = new NameValuePair ((string) $1, new ByteArrConst ((byte[]) $4));
			}
			| SQSTRING ASSIGN K_STRING OPEN_PARENS SQSTRING CLOSE_PARENS
			{
				$$ = new NameValuePair ((string) $1, new StringConst ((string) $5));
			}
			;

prop_or_field		: K_PROPERTY
			{
				$$ = MemberTypes.Property;
			}
			| K_FIELD
			{
				$$ = MemberTypes.Field;
			}
			;

nameval_pairs		: nameval_pair 
			{
				ArrayList pairs = new ArrayList ();
				pairs.Add ($1);

				$$ = pairs;
			}
			| nameval_pairs COMMA nameval_pair
			{
				ArrayList pairs = (ArrayList) $1;
				pairs.Add ($3);

				$$ = pairs;
			}
			;

nameval_pair 		: comp_qstring ASSIGN cavalue
			{
				$$ = new NameValuePair ((string) $1, $3);
			}
			;

cavalue 		: truefalse
			| int32
			| int32 OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = $3;
			}
			| comp_qstring 
			| class_ref OPEN_PARENS K_INT8 COLON int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (byte) (int) $5);
			}
			| class_ref OPEN_PARENS K_INT16 COLON int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (short) (int) $5);
			}
			| class_ref OPEN_PARENS K_INT32 COLON int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (int) $5);
			}
			| class_ref OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (int) $3);
			}
			;

sec_action		: K_REQUEST
			{
				$$ = Mono.Cecil.SecurityAction.Request;
			}
			| K_DEMAND
			{
				$$ = Mono.Cecil.SecurityAction.Demand;
			}
			| K_ASSERT
			{
				$$ = Mono.Cecil.SecurityAction.Assert;
			}
			| K_DENY
			{
				$$ = Mono.Cecil.SecurityAction.Deny;
			}
			| K_PERMITONLY
			{
				$$ = Mono.Cecil.SecurityAction.PermitOnly;
			}
			| K_LINKCHECK
			{
				$$ = Mono.Cecil.SecurityAction.LinkDemand;
			}
			| K_INHERITCHECK
			{
				$$ = Mono.Cecil.SecurityAction.InheritDemand;
			}
			| K_REQMIN
			{
				$$ = Mono.Cecil.SecurityAction.RequestMinimum;
			}
			| K_REQOPT
			{
				$$ = Mono.Cecil.SecurityAction.RequestOptional;
			}
			| K_REQREFUSE
			{
				$$ = Mono.Cecil.SecurityAction.RequestRefuse;
			}
			| K_PREJITGRANT
			{
				$$ = Mono.Cecil.SecurityAction.PreJitGrant;
			}
			| K_PREJITDENY
			{
				$$ = Mono.Cecil.SecurityAction.PreJitDeny;
			}
			| K_NONCASDEMAND
			{
				$$ = Mono.Cecil.SecurityAction.NonCasDemand;
			}
			| K_NONCASLINKDEMAND
			{
				$$ = Mono.Cecil.SecurityAction.NonCasLinkDemand;
			}
			| K_NONCASINHERITANCE
			{
				$$ = Mono.Cecil.SecurityAction.NonCasInheritance;
			}
			;
*/

module_head		: D_MODULE
			| D_MODULE comp_name
			{
				var name = ((QualifiedName) $2).FullName;

				if (!codegen.HasModuleDirective) {
					// Microsoft's ILAsm only takes into account the
					// first .module directive
					codegen.CurrentModule.Name = name;
					codegen.HasModuleDirective = true;
				}
				else if (name != codegen.CurrentModule.Name)
					report.WriteWarning (Warning.ModuleDirectiveIgnored,
						".module directive with different name ignored.");
			}
			| D_MODULE K_EXTERN comp_name
			{
				var name = ((QualifiedName) $3).FullName;

				if (codegen.GetModuleReference (name) != null)
					report.WriteWarning (Warning.ModuleReferenceIgnored,
						"Ignoring duplicate module reference: {0}", name);

				var module = new ModuleReference (name);
				codegen.CurrentModule.ModuleReferences.Add (module);
			}
			;

file_decl		: D_FILE file_attr comp_name file_entry D_HASH ASSIGN bytes_list file_entry
			| D_FILE file_attr comp_name file_entry
			;

file_attr 		:
			{
				$$ = true;
			}
			| file_attr K_NOMETADATA
			{
				$$ = false;
			}
			;

file_entry		:
			{
				$$ = false;
			}
			| D_ENTRYPOINT
			{
				$$ = true;
			}
			;

assembly_all		: assembly_head OPEN_BRACE assembly_decls CLOSE_BRACE
			;

assembly_head		: D_ASSEMBLY asm_attr comp_name
			{
				var name = ((QualifiedName) $3).FullName;
				var asmName = codegen.CurrentModule.Assembly.Name;

				if (codegen.HasAssemblyDirective && name != asmName.Name)
					report.WriteError (Error.MultipleAssemblyDirectives,
						"Multiple .assembly directives.");

				asmName.Attributes = (AssemblyAttributes) $2;
				asmName.Name = name;
				codegen.HasAssemblyDirective = true;
			}
			;

asm_attr		:
			{
				$$ = AssemblyAttributes.SideBySideCompatible;
			}
			| asm_attr K_RETARGETABLE
			{
				$$ = ((AssemblyAttributes) $1) | AssemblyAttributes.Retargetable;
			}
			// TODO: What on earth do we do with these?! Some look like corflags, others
			// look more like target architectures... They also aren't documented...
			| asm_attr K_LEGACY K_LIBRARY
			| asm_attr K_CIL
			| asm_attr K_X86
			| asm_attr K_IA64
			| asm_attr K_AMD64
			| asm_attr K_NOAPPDOMAIN
			| asm_attr K_NOPROCESS
			| asm_attr K_NOMACHINE
			;

assembly_decls		:
			| assembly_decls assembly_decl
			;

locale_or_culture	: D_LOCALE
			| D_CULTURE
			;

assembly_decl		: D_PUBLICKEY ASSIGN bytes_list
			{
				codegen.CurrentModule.Assembly.Name.PublicKey = (byte[]) $3;
			}
			| D_VER int32 COLON int32 COLON int32 COLON int32
			{
				codegen.CurrentModule.Assembly.Name.Version =
					new Version ((int) $2, (int) $4, (int) $6, (int) $8);
			}
			| locale_or_culture comp_qstring
			{
				codegen.CurrentModule.Assembly.Name.Culture = (string) $2;
			}
			| locale_or_culture ASSIGN bytes_list
			{
				// I assume this is UTF-16. I really have no clue, though,
				// and it isn't documented...
				var text = Encoding.Unicode.GetString ((byte[]) $3);
				codegen.CurrentModule.Assembly.Name.Culture = text;
			}
			| D_HASH K_ALGORITHM int32
			{
				var algo = (AssemblyHashAlgorithm) (int) $3;

				if (algo != AssemblyHashAlgorithm.SHA1)
					report.WriteWarning (Warning.UnknownHashAlgorithm,
						"Unknown hash algorithm; suggest using {0}.",
						((int) AssemblyHashAlgorithm.SHA1).ToString ("X8"));

				codegen.CurrentModule.Assembly.Name.HashAlgorithm = algo;
			}
			/*
			| customattr_decl
			| sec_decl
			*/
			;
			;

assemblyref_all		: assemblyref_head OPEN_BRACE assemblyref_decls CLOSE_BRACE
			{
				var asmRef = codegen.CurrentAssemblyReference;
				var asmRefAlias = asmRef as AliasedAssemblyNameReference;
				var name = asmRefAlias != null ? asmRefAlias.Alias : asmRef.Name;

				// If we already have a reference with this name, we
				// ignore the one we just built.
				if (codegen.GetAliasedAssemblyReference (name) == null) {
					// If we have a public key and a token, we prefer the
					// token. Cecil prefers the public key, so we have to
					// do this ourselves.
					if (has_public_key && has_public_key_token) {
						var token = asmRef.PublicKeyToken;
						asmRef.PublicKey = null;
						asmRef.PublicKeyToken = token;
					}

					if (asmRefAlias != null)
						codegen.AliasedAssemblyReferences.Add (asmRefAlias.Alias, asmRefAlias);

					codegen.CurrentModule.AssemblyReferences.Add (asmRef);
				}
				else
					report.WriteWarning (Warning.AssemblyReferenceIgnored,
						"Redeclaration of assembly '{0}' ignored.", name);

				codegen.CurrentAssemblyReference = null;
				has_public_key = false;
				has_public_key_token = false;
			}
			;

assemblyref_head	: D_ASSEMBLY K_EXTERN asm_attr comp_name
			{
				codegen.CurrentAssemblyReference = new AssemblyNameReference (((QualifiedName) $4).FullName,
					new Version ()) {
					Attributes = (AssemblyAttributes) $3,
				};
			}
			| D_ASSEMBLY K_EXTERN asm_attr comp_name K_AS comp_name
			{
				var name = (QualifiedName) $6;

				codegen.CurrentAssemblyReference = new AliasedAssemblyNameReference (((QualifiedName) $4).FullName,
					new Version ()) {
					Alias = name.FullName,
					Attributes = (AssemblyAttributes) $3,
				};
			}
			;

assemblyref_decls	:
			| assemblyref_decls assemblyref_decl
			;

assemblyref_decl	: D_VER int32 COLON int32 COLON int32 COLON int32
			{
				codegen.CurrentAssemblyReference.Version =
					new Version ((int) $2, (int) $4, (int) $6, (int) $8);
			}
			| D_PUBLICKEY ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.PublicKey = (byte[]) $3;
				has_public_key = true;
			}
			| D_PUBLICKEYTOKEN ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.PublicKeyToken = (byte[]) $3;
				has_public_key_token = true;
			}
			| locale_or_culture comp_qstring
			{
				codegen.CurrentAssemblyReference.Culture = (string) $2;
			}
			| locale_or_culture ASSIGN bytes_list
			{
				// See the note in assembly_decl -> D_LOCALE.
				var text = Encoding.Unicode.GetString ((byte[]) $3);
				codegen.CurrentAssemblyReference.Culture = text;
			}
			| D_HASH ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.Hash = (byte[]) $3;
			}
			| K_AUTO // TODO: Implement this.
			/*
			| customattr_decl
			*/
			;

exptype_all		: exptype_head OPEN_BRACE exptype_decls CLOSE_BRACE
			{
			}
			;

exptype_directive	: D_CLASS K_EXTERN
			| D_EXPORT
			;

exptype_head		: exptype_directive expt_attr comp_name
			{
				var qn = (QualifiedName) $3;

				$$ = new Tuple<QualifiedName, TypeAttributes> (qn, (TypeAttributes) $2);
			}
			;

expt_attr 		:
			{
				$$ = TypeAttributes.NotPublic;
			}
			| expt_attr K_PRIVATE			{ $$ = (TypeAttributes) $1 | TypeAttributes.NotPublic; }
			| expt_attr K_PUBLIC			{ $$ = (TypeAttributes) $1 | TypeAttributes.Public; }
			| expt_attr K_FORWARDER			{ $$ = (TypeAttributes) $1 | TypeAttributes.Forwarder; }
			| expt_attr K_NESTED K_PUBLIC		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPublic; }
			| expt_attr K_NESTED K_PRIVATE		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPrivate; }
			| expt_attr K_NESTED K_FAMILY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamily; }
			| expt_attr K_NESTED K_ASSEMBLY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedAssembly; }
			| expt_attr K_NESTED K_FAMANDASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamANDAssem; }
			| expt_attr K_NESTED K_FAMORASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamORAssem; }
			;

exptype_decls		:
			| exptype_decls exptype_decl
			{
				// Just use the last declaration.
				$$ = $2;
			}
			;

exptype_decl		: D_FILE comp_name // TODO: Handle this case.
			| D_CLASS K_EXTERN comp_name
			{
				$$ = codegen.GetTypeByName ((QualifiedName) $3);
			}
			| D_ASSEMBLY K_EXTERN comp_name
			{
				var name = ((QualifiedName) $3).FullName;

				$$ = codegen.GetAssemblyReference (name);
			}
			| mdtoken_type
			| D_CLASS int32
			{
				$$ = $2;
			}
			/*
			| customattr_decl
			*/
			;

manifestres_all		: manifestres_head OPEN_BRACE manifestres_decls CLOSE_BRACE
			{
				var head = $1 as Tuple<ManifestResourceAttributes, string>;
				var aliasedHead = $1 as Tuple<ManifestResourceAttributes, string, string>;

				string resName;
				string fileName;
				ManifestResourceAttributes attr;

				if (aliasedHead != null) {
					attr = aliasedHead.X;
					resName = aliasedHead.Y;
					fileName = aliasedHead.Z;
				} else {
					attr = head.X;
					resName = head.Y;
					fileName = head.Y;
				}

				Resource rsc;

				if ($3 != null) {
					var asmDecl = $3 as string;
					var fileDecl = $3 as Tuple<string, int>;

					if (asmDecl != null) {
						var asmRef = codegen.GetAssemblyReference (asmDecl);
						rsc = new AssemblyLinkedResource (resName, attr, asmRef);
					} else {
						// TODO: Propagate nometadata/.entrypoint/offset.
						rsc = new LinkedResource (resName, attr, fileDecl.X);
					}
				} else {
					var bytes = File.ReadAllBytes (fileName);
					rsc = new EmbeddedResource (resName, attr, bytes);
				}

				codegen.CurrentModule.Resources.Add (rsc);
			}
			;

manifestres_head	: D_MRESOURCE manres_attr comp_name
			{
				$$ = new Tuple<ManifestResourceAttributes, string> ((ManifestResourceAttributes) $2,
					(string) $3);
			}
			| D_MRESOURCE manres_attr comp_name K_AS comp_name
			{
				$$ = new Tuple<ManifestResourceAttributes, string, string> ((ManifestResourceAttributes) $2,
					(string) $3, (string) $5);
			}
			;

manres_attr		:
			{
				$$ = (ManifestResourceAttributes) 0;
			}
			| manres_attr K_PUBLIC
			{
				// Blame Microsoft for this madness.
				$$ = ((ManifestResourceAttributes) $1 != (ManifestResourceAttributes) 0 &&
					(ManifestResourceAttributes) $1 != ManifestResourceAttributes.Public) ?
					(ManifestResourceAttributes) 0 : ManifestResourceAttributes.Public;
			}
			| manres_attr K_PRIVATE
			{
				$$ = ((ManifestResourceAttributes) $1 != (ManifestResourceAttributes) 0 &&
					(ManifestResourceAttributes) $1 != ManifestResourceAttributes.Private) ?
					(ManifestResourceAttributes) 0 : ManifestResourceAttributes.Private;
			} 
			;

manifestres_decls	:
			| manifestres_decls manifestres_decl
			{
				// Just use the last declaration.
				$$ = $2;
			}
			;

manifestres_decl	: D_FILE comp_name K_AT int32
			{
				$$ = new Tuple<string, int> ((string) $2, (int) $4);
			}
			| D_ASSEMBLY K_EXTERN slashed_name
			{
				$$ = $3;
			}
			/*
			| customattr_decl
			*/
			;

slashed_name		: comp_name
			| slashed_name SLASH comp_name
			{
				var sl = (QualifiedName) $1;

				var qn = new QualifiedName {
					Name = ((QualifiedName) $3).FullName, // TODO: Verify this.
				};

				foreach (var ns in sl.Namespaces)
					qn.Namespaces.Add (ns);

				foreach (var nesting in sl.Nestings)
					qn.Nestings.Add (nesting);

				qn.Nestings.Add (sl.Name);

				$$ = qn;
			}
			;

mdtoken			: K_MDTOKEN OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = $2;
			}
			;

comp_qstring		: QSTRING
			| comp_qstring PLUS QSTRING
			{
				$$ = string.Format ("{0}{1}", $1, $3);
			}
			;

int32			: INT64
			{
				$$ = BitConverter.ToInt32 (BitConverter.GetBytes ((long) $1), BitConverter.IsLittleEndian ? 0 : 4);
			}
			;

int64			: INT64
			;

float64			: FLOAT64
			| K_FLOAT32 OPEN_PARENS INT32 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((int) $3), 0);
			}
			| K_FLOAT32 OPEN_PARENS INT64 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((long) $3),
					BitConverter.IsLittleEndian ? 0 : 4);
			}
			| K_FLOAT64 OPEN_PARENS INT64 CLOSE_PARENS
			{
				$$ = BitConverter.ToDouble (BitConverter.GetBytes ((long) $3), 0);
			}
			| K_FLOAT64 OPEN_PARENS INT32 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((int) $3), 0);
			}
			;

hexbyte			: HEXBYTE
			;

bytes_list		: OPEN_PARENS
			{
				tokenizer.InByteArray  = true;
			}
			  bytes CLOSE_PARENS
			{
				tokenizer.InByteArray  = false;

				$$ = $3;
			}
			;

bytes			:
			{
				$$ = new byte [0];
			}
			| hexbytes
			{
				$$ = ((List<byte>) $1).ToArray ();
			}
			;

hexbytes		: hexbyte
			{
				$$ = new List<byte> {
					Convert.ToByte ($1),
				};
			}
			| hexbytes hexbyte
			{
				((List<byte>) $1).Add (Convert.ToByte ($2));
			}
			;

truefalse		: K_TRUE
			{
				$$ = true;
			}
			| K_FALSE
			{
				$$ = false;
			}
			;

id			: ID
			| SQSTRING
			;

comp_name		: id
			{
				$$ = new QualifiedName {
					Name = (string) $1,
				};
			}
			| comp_name DOT comp_name
			{
				var n1 = (QualifiedName) $1;
				var n2 = (QualifiedName) $2;

				var qn = new QualifiedName {
					Name = n2.Name,
				};

				foreach (var ns in n1.Namespaces)
					qn.Namespaces.Add (ns);

				qn.Namespaces.Add (n1.Name);

				foreach (var ns in n2.Namespaces)
					qn.Namespaces.Add (ns);

				$$ = qn;
			}
			| COMP_NAME
			{
				var strings = ((string) $1).Split ('.');

				var qn = new QualifiedName {
					Name = strings [1],
				};
				qn.Namespaces.Add (strings [0]);

				$$ = qn;
			}
			;

%%

}
