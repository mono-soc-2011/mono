%{
//
// Mono.ILAsm.ILParser
// 
// (C) Sergey Chaban (serge@wildwestsoftware.com)
// (C) 2003 Jackson Harper, All rights reserved
// (C) 2011 Alex RÃ¸nne Petersen <xtzgzorex@gmail.com>
//

using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Mono.Cecil;

namespace Mono.ILAsm {
	internal class ILParser {
		static readonly int yacc_verbose_flag = 0;
		readonly CodeGenerator codegen;
		readonly ILTokenizer tokenizer;
		readonly Report report;
		readonly Stack<string> namespace_stack = new Stack<string> ();
		readonly Stack<TypeDefinition> typedef_stack = new Stack<TypeDefinition> ();
		bool is_enum_class;
		bool is_value_class;
		bool has_public_key;
		bool has_public_key_token;
		bool is_explicit_call;
		bool is_instance_call;
		bool is_parameter_marshal_notation;
		bool type_attr_visibility_set;
		int custom_attr_blob_seq_length;
		string pinvoke_mod_name;

		public ILParser (Report report, CodeGenerator codegen, ILTokenizer tokenizer)
		{
			this.report = report;
			this.codegen = codegen;
			this.tokenizer = tokenizer;
		}

%}

%token UNKNOWN
%token EOF
%token ID
%token QSTRING
%token SQSTRING
%token COMP_NAME
%token INT32
%token INT64
%token FLOAT64
%token HEXBYTE

%token DOT "."
%token OPEN_BRACE "{"
%token CLOSE_BRACE "}"
%token OPEN_BRACKET "["
%token CLOSE_BRACKET "]"
%token OPEN_PARENS "("
%token CLOSE_PARENS ")"
%token COMMA ","
%token COLON ":"
%token DOUBLE_COLON "::"
%token SEMICOLON ";"
%token ASSIGN "="
%token STAR "*"
%token AMPERSAND "&"
%token PLUS "+"
%token SLASH "/"
%token BANG "!"
%token ELLIPSIS "..."
%token DASH "-"
%token OPEN_ANGLE_BRACKET "<"
%token CLOSE_ANGLE_BRACKET ">"

%token INSTR_NONE
%token INSTR_VAR
%token INSTR_I
%token INSTR_I8
%token INSTR_R
%token INSTR_BRTARGET
%token INSTR_METHOD
%token INSTR_NEWOBJ
%token INSTR_FIELD
%token INSTR_TYPE
%token INSTR_STRING
%token INSTR_SIG
%token INSTR_RVA
%token INSTR_TOK
%token INSTR_SWITCH
%token INSTR_PHI
%token INSTR_LOCAL
%token INSTR_PARAM

%token D_ASSEMBLY
%token D_CCTOR
%token D_CLASS
%token D_IMAGEBASE
%token D_CORFLAGS
%token D_CTOR
%token D_CUSTOM
%token D_DATA
%token D_EMITBYTE
%token D_ENTRYPOINT
%token D_EVENT
%token D_EXPORT
%token D_FIELD
%token D_FILE
%token D_FIRE
%token D_GET
%token D_HASH
%token D_LANGUAGE
%token D_LINE
%token D_XLINE
%token D_LOCALE
%token D_CULTURE
%token D_LOCALIZED
%token D_LOCALS
%token D_MAXSTACK
%token D_METHOD
%token D_MODULE
%token D_MRESOURCE
%token D_MANIFESTRES
%token D_NAMESPACE
%token D_OTHER
%token D_OVERRIDE
%token D_PACK
%token D_PARAM
%token D_PERMISSION
%token D_PERMISSIONSET
%token D_PROPERTY
%token D_PUBLICKEY
%token D_PUBLICKEYTOKEN
%token D_ADDON
%token D_REMOVEON
%token D_SET
%token D_SIZE
%token D_STACKRESERVE
%token D_SUBSYSTEM
%token D_TRY
%token D_VER
%token D_VTABLE
%token D_VTENTRY
%token D_VTFIXUP
%token D_ZEROINIT
%token D_THIS
%token D_BASE
%token D_NESTER
%token D_TYPELIST
%token D_MSCORLIB
%token D_PDIRECT
%token D_TYPEDEF
%token D_XDEFINE
%token D_XUNDEF
%token D_XIFDEF
%token D_XIFNDEF
%token D_XELSE
%token D_XENDIF
%token D_XINCLUDE

%token K_AT
%token K_AS
%token K_IMPLICITCOM
%token K_IMPLICITRES
%token K_EXTERN
%token K_INSTANCE
%token K_EXPLICIT
%token K_DEFAULT
%token K_VARARG
%token K_UNMANAGED
%token K_CDECL
%token K_STDCALL
%token K_THISCALL
%token K_FASTCALL
%token K_MARSHAL
%token K_IN
%token K_OUT
%token K_OPT
%token K_STATIC
%token K_PUBLIC
%token K_PRIVATE
%token K_FAMILY
%token K_INITONLY
%token K_RTSPECIALNAME
%token K_STRICT
%token K_SPECIALNAME
%token K_ASSEMBLY
%token K_FAMANDASSEM
%token K_FAMORASSEM
%token K_PRIVATESCOPE
%token K_LITERAL
%token K_NOTSERIALIZED
%token K_VALUE
%token K_NOT_IN_GC_HEAP
%token K_INTERFACE
%token K_SEALED
%token K_ABSTRACT
%token K_AUTO
%token K_SEQUENTIAL
%token K_ANSI
%token K_UNICODE
%token K_AUTOCHAR
%token K_BESTFIT
%token K_IMPORT
%token K_SERIALIZABLE
%token K_NESTED
%token K_EXTENDS
%token K_IMPLEMENTS
%token K_FINAL
%token K_VIRTUAL
%token K_HIDEBYSIG
%token K_NEWSLOT
%token K_UNMANAGEDEXP
%token K_PINVOKEIMPL
%token K_NOMANGLE
%token K_LASTERR
%token K_WINAPI
%token K_PLATFORMAPI
%token K_NATIVE
%token K_IL
%token K_CIL
%token K_OPTIL
%token K_MANAGED
%token K_FORWARDREF
%token K_RUNTIME
%token K_INTERNALCALL
%token K_SYNCHRONIZED
%token K_NOINLINING
%token K_NOOPTIMIZATION
%token K_CUSTOM
%token K_FIXED
%token K_SYSSTRING
%token K_ARRAY
%token K_VARIANT
%token K_CURRENCY
%token K_SYSCHAR
%token K_VOID
%token K_BOOL
%token K_INT8
%token K_INT16
%token K_INT32
%token K_INT64
%token K_FLOAT
%token K_FLOAT32
%token K_FLOAT64
%token K_ERROR
%token K_UNSIGNED
%token K_UINT
%token K_UINT8
%token K_UINT16
%token K_UINT32
%token K_UINT64
%token K_DECIMAL
%token K_DATE
%token K_BSTR
%token K_LPSTR
%token K_LPWSTR
%token K_LPTSTR
%token K_OBJECTREF
%token K_IUNKNOWN
%token K_IDISPATCH
%token K_STRUCT
%token K_SAFEARRAY
%token K_INT
%token K_BYVALSTR
%token K_TBSTR
%token K_LPVOID
%token K_ANY
%token K_FLOAT
%token K_LPSTRUCT
%token K_NULL
%token K_PTR
%token K_VECTOR
%token K_HRESULT
%token K_CARRAY
%token K_USERDEFINED
%token K_RECORD
%token K_FILETIME
%token K_BLOB
%token K_STREAM
%token K_STORAGE
%token K_STREAMED_OBJECT
%token K_STORED_OBJECT
%token K_BLOB_OBJECT
%token K_CF
%token K_CLSID
%token K_METHOD
%token K_CLASS
%token K_PINNED
%token K_MODREQ
%token K_MODOPT
%token K_TYPEDREF
%token K_TYPE
%token K_CHAR
%token K_WCHAR
%token K_FROMUNMANAGED
%token K_CALLMOSTDERIVED
%token K_RETAINAPPDOMAIN
%token K_BYTEARRAY
%token K_WITH
%token K_INIT
%token K_TO
%token K_CATCH
%token K_FILTER
%token K_FINALLY
%token K_FAULT
%token K_HANDLER
%token K_TLS
%token K_FIELD
%token K_PROPERTY
%token K_REQUEST
%token K_DEMAND
%token K_ASSERT
%token K_DENY
%token K_PERMITONLY
%token K_LINKCHECK
%token K_INHERITCHECK
%token K_REQMIN
%token K_REQOPT
%token K_REQREFUSE
%token K_PREJITGRANT
%token K_PREJITDENY
%token K_NONCASDEMAND
%token K_NONCASLINKDEMAND
%token K_NONCASINHERITANCE
%token K_NOMETADATA
%token K_ALGORITHM
%token K_RETARGETABLE
%token K_LEGACY
%token K_LIBRARY
%token K_X86
%token K_IA64
%token K_AMD64
%token K_PRESERVESIG
%token K_BEFOREFIELDINIT
%token K_ALIGNMENT
%token K_NULLREF
%token K_VALUETYPE
%token K_COMPILERCONTROLLED
%token K_REQSECOBJ
%token K_ENUM
%token K_OBJECT
%token K_STRING
%token K_TRUE
%token K_FALSE
%token K_ON
%token K_OFF
%token K_CHARMAPERROR
%token K_MDTOKEN
%token K_FLAGS
%token K_CALLCONV
%token K_NOAPPDOMAIN
%token K_NOMACHINE
%token K_NOPROCESS
%token K_ILLEGAL
%token K_UNUSED
%token K_WRAPPER
%token K_FORWARDER

%start il_file

%%

il_file			: decls
			;

decls			:
			| decls decl
			;

decl			: class_all
			| namespace_all
			| method_all
			| field_decl
			| data_decl
			| vtable_decl
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtable is currently unimplemented (directive ignored).");
			}
			| vtfixup_decl
			{
				report.WriteWarning (Warning.UnimplementedFeatureUsed,
					".vtfixup is currently unimplemented (directive ignored).");
			}
			| file_decl
			| assembly_all
			| assemblyref_all
			| exptype_all
			| manifestres_all
			| module_head
			/*
			| sec_decl
			*/
			| customattr_decl
			{
				codegen.CurrentModule.CustomAttributes.Add ((CustomAttribute) $1);
				codegen.CurrentCustomAttribute = null;
			}
			| D_SUBSYSTEM int32
			{
				codegen.CurrentModule.Kind = (ModuleKind) $2;
			}
			| D_CORFLAGS int32
			{
				codegen.CurrentModule.Attributes = (ModuleAttributes) $2;
			}
			// TODO: Find a way to set these with Cecil.
			| D_FILE K_ALIGNMENT int32
			{
				var fa = (int) $3;

				if (fa < 0x200 || fa > 0x10000 || (fa & (fa - 1)) != 0) {
					report.WriteError (Error.InvalidFileAlignment,
						"Invalid file alignment; must be a power of two between 0x200 and 0x10000.");
				}
			}
			| D_IMAGEBASE int64
			{
				var ib = (long) $2;

				if ((ib & 0xffff) != 0) {
					report.WriteError (Error.InvalidImageBase,
						"Invalid image base; must be 0x10000-aligned.");
				}
			}
			| D_STACKRESERVE int64
			| D_TYPELIST OPEN_BRACE class_refs CLOSE_BRACE // TODO: How can we sort with Cecil?
			| D_MSCORLIB
			{
				// TODO: We need to set image base to 0x00510000 here.
				codegen.IsCorlib = true;
			}
			| extsource_spec
			| language_decl
			| typedef_decl
			| comp_control
			;

line_directive		: D_LINE
			| D_XLINE
			;

// TODO: Persist these in MDB.
extsource_spec		: line_directive int32 SQSTRING
			| line_directive int32
			| line_directive int32 COLON int32 SQSTRING
			| line_directive int32 COLON int32
			| line_directive int32 COLON int32 COMMA int32 SQSTRING
			| line_directive int32 COLON int32 COMMA int32
			| line_directive int32 COMMA int32 COLON int32 SQSTRING
			| line_directive int32 COMMA int32 COLON int32
			| line_directive int32 COMMA int32 COLON int32 COMMA int32 SQSTRING
			| line_directive int32 COMMA int32 COLON int32 COMMA int32
			| line_directive int32 QSTRING
			;

// TODO: Persist these in MDB.
language_decl		: D_LANGUAGE SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING COMMA SQSTRING
			;

vtable_decl		: D_VTABLE ASSIGN OPEN_PARENS bytes CLOSE_PARENS
			;

vtfixup_decl		: D_VTFIXUP OPEN_BRACKET int32 CLOSE_BRACKET vtfixup_attr K_AT id
			;

vtfixup_attr		:
			| vtfixup_attr K_INT32
			| vtfixup_attr K_INT64
			| vtfixup_attr K_FROMUNMANAGED
			| vtfixup_attr K_CALLMOSTDERIVED
			| vtfixup_attr K_RETAINAPPDOMAIN
			;

typedef_decl		: D_TYPEDEF type K_AS comp_name
			| D_TYPEDEF class_ref K_AS comp_name
			| D_TYPEDEF member_ref K_AS comp_name
			| D_TYPEDEF customattr K_AS comp_name
			| D_TYPEDEF customattr_owner K_AS comp_name
			;

comp_control		:
			| D_XDEFINE comp_name
			| D_XDEFINE comp_name QSTRING
			| D_XUNDEF comp_name
			| D_XIFDEF comp_name
			| D_XIFNDEF comp_name
			| D_XELSE
			| D_XENDIF
			| D_XINCLUDE QSTRING
			| SEMICOLON
			;

namespace_all		: namespace_head OPEN_BRACE decls CLOSE_BRACE
			{
				report.WriteWarning (Warning.LegacyNamespaceSyntax,
					"Use of legacy namespace syntax.");

				codegen.CurrentNamespace = namespace_stack.Pop ();
			}
			;

namespace_head		: D_NAMESPACE comp_name
			{
				namespace_stack.Push (codegen.CurrentNamespace);

				if (codegen.CurrentNamespace != string.Empty)
					codegen.CurrentNamespace += ".";

				codegen.CurrentNamespace += ((QualifiedName) $2).FullName;
			}
			;

class_all		: class_head OPEN_BRACE class_decls CLOSE_BRACE
			{
				codegen.CurrentModule.Types.Add (codegen.CurrentType);

				// We've assembled the System.Object type; register it.
				if (codegen.IsCorlib && codegen.Corlib.Object == null &&
					codegen.CurrentType.FullName == "System.Object")
					codegen.Corlib.Object = codegen.CurrentType;

				codegen.CurrentType = null;

				if (typedef_stack.Count > 0)
					codegen.CurrentType = typedef_stack.Pop ();
			}
			;

class_head		: D_CLASS class_attr comp_name
			{
				var qn = (QualifiedName) $3;
				var attr = (TypeAttributes) $2;
				var nester = codegen.CurrentType;

				if (nester != null) {
					typedef_stack.Push (nester);

					if (!attr.HasAnyBitFlag (TypeAttributes.NestedPublic) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedPrivate) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedFamily) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedAssembly) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedFamANDAssem) &&
						!attr.HasAnyBitFlag (TypeAttributes.NestedFamORAssem)) {
						report.WriteWarning (Warning.NestedTypeMadeNestedVisibility,
							"Nested type set to equivalent nested visibility.");

						if (attr.HasBitFlag (TypeAttributes.Public)) {
							attr &= ~TypeAttributes.Public;
							attr |= TypeAttributes.NestedPublic;
						} else // In the case of NotPublic.
							attr |= TypeAttributes.NestedPrivate;
					}
				}

				codegen.CurrentType = new TypeDefinition (codegen.CurrentNamespace +
					qn.FullNamespace, qn.Name, attr) {
					DeclaringType = nester,
				};

				codegen.CurrentGenericParameterProvider = codegen.CurrentType;
			}
			  formal_typars_clause extends_clause impl_clause
			{
				foreach (var arg in (List<GenericParameter>) $5)
					codegen.CurrentType.GenericParameters.Add (arg);

				codegen.CurrentGenericParameterProvider = null;

				TypeReference baseType;

				// if we're assembling mscorlib and defining System.Object,
				// no base type should be defined.
				var isSysObj = codegen.IsCorlib && codegen.Corlib.Object == null &&
					codegen.CurrentType.FullName == "System.Object";

				if ($6 == null) {
					if (is_value_class)
						baseType = codegen.Corlib.ValueType;
					else if (is_enum_class)
						baseType = codegen.Corlib.Enum;
					else if (isSysObj)
						baseType = null;
					else {
						var obj = codegen.Corlib.Object;

						if (obj == null)
							report.WriteError (Error.SystemObjectUndefined,
								"System.Object has not been defined.");

						baseType = obj;
					}
				} else {
					if (codegen.CurrentType.IsInterface)
						report.WriteError (Error.BaseClassInInterface,
							"Base type specified on an interface.");

					baseType = (TypeReference) $6;
				}

				if (isSysObj && baseType != null) {
					report.WriteWarning (Warning.SystemObjectBaseTypeReset,
						"System.Object should not have a base type; removed.");

					codegen.CurrentType.BaseType = null;
				} else
					codegen.CurrentType.BaseType = baseType;

				foreach (var interf in (List<TypeReference>) $7)
					codegen.CurrentType.Interfaces.Add (interf);
			}
			;

class_attr		:
			{
				is_value_class = false;
				is_enum_class = false;
				type_attr_visibility_set = false;
				$$ = TypeAttributes.NotPublic;
			}
			| class_attr K_PUBLIC
			{
				if (!type_attr_visibility_set) {
					type_attr_visibility_set = true;
					$$ = (TypeAttributes) $1 | TypeAttributes.Public;
				}
			}
			| class_attr K_PRIVATE			{ type_attr_visibility_set = true; }
			// TODO: We may need to use type_attr_visibility_set for these too.
			| class_attr K_NESTED K_PRIVATE		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPrivate; }
			| class_attr K_NESTED K_PUBLIC		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPublic; }
			| class_attr K_NESTED K_FAMILY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamily; }
			| class_attr K_NESTED K_ASSEMBLY	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedAssembly;}
			| class_attr K_NESTED K_FAMANDASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamANDAssem; }
			| class_attr K_NESTED K_FAMORASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamORAssem; }
			| class_attr K_VALUE			{ is_value_class = true; }
			| class_attr K_ENUM			{ is_enum_class = true; }
			| class_attr K_INTERFACE		{ $$ = (TypeAttributes) $1 | TypeAttributes.Interface | TypeAttributes.Abstract; }
			| class_attr K_SEALED			{ $$ = (TypeAttributes) $1 | TypeAttributes.Sealed; }
			| class_attr K_ABSTRACT			{ $$ = (TypeAttributes) $1 | TypeAttributes.Abstract; }
			| class_attr K_AUTO
			| class_attr K_SEQUENTIAL		{ $$ = (TypeAttributes) $1 | TypeAttributes.SequentialLayout; }
			| class_attr K_EXPLICIT			{ $$ = (TypeAttributes) $1 | TypeAttributes.ExplicitLayout; }
			| class_attr K_ANSI
			| class_attr K_UNICODE			{ $$ = (TypeAttributes) $1 | TypeAttributes.UnicodeClass; }
			| class_attr K_AUTOCHAR			{ $$ = (TypeAttributes) $1 | TypeAttributes.AutoClass; }
			| class_attr K_IMPORT			{ $$ = (TypeAttributes) $1 | TypeAttributes.Import; }
			| class_attr K_SERIALIZABLE		{ $$ = (TypeAttributes) $1 | TypeAttributes.Serializable; }
			| class_attr K_BEFOREFIELDINIT		{ $$ = (TypeAttributes) $1 | TypeAttributes.BeforeFieldInit; }
			| class_attr K_SPECIALNAME		{ $$ = (TypeAttributes) $1 | TypeAttributes.SpecialName; }
			| class_attr K_RTSPECIALNAME		{ $$ = (TypeAttributes) $1 | TypeAttributes.RTSpecialName; }
			| class_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (TypeAttributes) $1 | (TypeAttributes) (int) $4;
			}
			;

extends_clause		:
			| K_EXTENDS type_spec
			{
				$$ = $2;
			}
			;

impl_clause		:
			{
				$$ = new List<TypeReference> ();
			}
			| impl_class_refs
			;

impl_class_refs		:
			| K_IMPLEMENTS type_spec
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $2,
				};
			}
			| impl_class_refs COMMA type_spec
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

formal_typars_clause	:
			{
				$$ = new List<GenericParameter> ();
			}
			| OPEN_ANGLE_BRACKET formal_typars CLOSE_ANGLE_BRACKET
			{
				$$ = $2;
			}
			;

formal_typars		: formal_typar_attr constraints_clause formal_typar
			{
				var gp = new GenericParameter (((QualifiedName) $3).FullName,
					codegen.CurrentGenericParameterProvider) {
					Attributes = (GenericParameterAttributes) $1,
				};

				foreach (var constraint in (List<TypeReference>) $2)
					gp.Constraints.Add (constraint);

				$$ = new List<GenericParameter> () {
					gp,
				};
			}
			| formal_typars COMMA formal_typar_attr constraints_clause formal_typar
			{
				var colln = (List<GenericParameter>) $1;

				var gp = new GenericParameter (((QualifiedName) $5).FullName,
					codegen.CurrentGenericParameterProvider) {
					Attributes = (GenericParameterAttributes) $3,
				};

				foreach (var constraint in (List<TypeReference>) $4)
					gp.Constraints.Add (constraint);

				colln.Add (gp);
			}
			;

formal_typar_attr	:
			{
				$$ = GenericParameterAttributes.NonVariant;
			}
			| formal_typar_attr PLUS	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.Covariant; }
			| formal_typar_attr DASH	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.Contravariant; }
			| formal_typar_attr D_CTOR	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.DefaultConstructorConstraint; }
			| formal_typar_attr K_VALUETYPE	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.NotNullableValueTypeConstraint; }
			| formal_typar_attr K_CLASS	{ $$ = (GenericParameterAttributes) $1 | GenericParameterAttributes.ReferenceTypeConstraint; }
			;

formal_typar		: comp_name
			{
				$$ = $1;
			}
			;

constraints_clause	:
			{
				$$ = new List<TypeReference> ();
			}
			| OPEN_PARENS constraints CLOSE_PARENS
			{
				$$ = $2;
			}
			;

constraints		: type_spec
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| constraints COMMA type_spec
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
			}
			;

class_decls		:
			| class_decls class_decl
			;

class_decl		: method_all
			| class_all
			| event_all
			| prop_all
			| field_decl
			| data_decl
			/*
			| sec_decl
			*/
			| extsource_spec
			| customattr_decl
			{
				codegen.CurrentType.CustomAttributes.Add ((CustomAttribute) $1);
				codegen.CurrentCustomAttribute = null;
			}
			/*
			| param_type_decl
			*/
			| D_SIZE int32
			{
				var size = (int) $2;

				if (codegen.CurrentType.IsAutoLayout && size != -1)
					report.WriteWarning (Warning.LayoutInfoInAutoLayoutType,
						"Class layout information specified in auto-layout class.");

				codegen.CurrentType.ClassSize = size;
			}
			| D_PACK int32
			{
				if (codegen.CurrentType.IsAutoLayout)
					report.WriteWarning (Warning.LayoutInfoInAutoLayoutType,
						"Class layout information specified in auto-layout class.");

				var p = (int) $2;

				if (p < 1 || p > 128 || (p & (p - 1)) != 0)
					report.WriteError (Error.InvalidPackSize,
						"Class pack size must be a power of two between 1 and 128.");

				codegen.CurrentType.PackingSize = (short) (int) $2;
			}
			| D_OVERRIDE type_spec DOUBLE_COLON method_name K_WITH call_conv type type_spec DOUBLE_COLON method_name OPEN_PARENS sig_args CLOSE_PARENS
			{
				var conv = (MethodCallingConvention) $6;
				var retType = (TypeReference) $7;

				var overridingMethod = new MethodReference ((string) $10, retType, (TypeReference) $8) {
					CallingConvention = conv,
				};

				var baseMethod = new MethodReference ((string) $4, retType, (TypeReference) $2) {
					CallingConvention = conv,
				};

				if (is_instance_call) {
					overridingMethod.HasThis = true;
					baseMethod.HasThis = true;
				}

				if (is_explicit_call) {
					overridingMethod.ExplicitThis = true;
					baseMethod.ExplicitThis = true;
				}

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $12) {
					overridingMethod.Parameters.Add (new ParameterDefinition (arg));
					baseMethod.Parameters.Add (new ParameterDefinition (arg));
				}

				var resolvedMethod = overridingMethod.Resolve ();

				if (resolvedMethod == null)
					report.WriteError (Error.InvalidOverrideMethod,
						"Could not resolve overriding method: {0}",
						overridingMethod);

				resolvedMethod.Overrides.Add ((MethodReference) $2);
			}
			| D_OVERRIDE generic_method_ref K_WITH generic_method_ref
			{
				var overridingMethod = ((MethodReference) $4).Resolve ();

				if (overridingMethod == null)
					report.WriteError (Error.InvalidOverrideMethod,
						"Could not resolve overriding method: {0}",
						overridingMethod);

				overridingMethod.Overrides.Add ((MethodReference) $2);
			}
			| language_decl
			| comp_control
			;

/*
param_type_decl		: D_PARAM K_TYPE id
			| D_PARAM K_TYPE OPEN_BRACKET int32 CLOSE_BRACKET
			;
*/

class_refs		: class_ref
			{
				$$ = new List<TypeReference> {
					(TypeReference) $1,
				};
			}
			| class_refs COMMA class_ref
			{
				var class_list = (List<TypeReference>) $1;
				class_list.Add ((TypeReference) $3);
			}
			;

class_ref		: OPEN_BRACKET comp_name CLOSE_BRACKET slashed_name
			{
				var name = (QualifiedName) $2;
				var type = (QualifiedName) $4;
				var scope = codegen.GetScope (name.FullName, false);

				$$ = new TypeReference (type.FullNamespace, type.Name, codegen.CurrentModule, scope);
			}
			| OPEN_BRACKET mdtoken CLOSE_BRACKET slashed_name
			| OPEN_BRACKET STAR CLOSE_BRACKET slashed_name // TODO: How does this work?
			| OPEN_BRACKET D_MODULE comp_name CLOSE_BRACKET slashed_name
			{
				var module = (QualifiedName) $3;
				var type = (QualifiedName) $5;

				if (module.FullName == codegen.CurrentModule.Name)
					$$ = codegen.GetTypeByName (type);
				else {
					var scope = codegen.GetScope (module.FullName, true);
					$$ = new TypeReference (type.FullNamespace,
						type.Name, codegen.CurrentModule, scope);
				}
			}
			| slashed_name
			{
				$$ = codegen.GetTypeByName ((QualifiedName) $1);
			}
			| mdtoken_type
			| D_THIS
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.RelativeTypeReferenceOutsideTypeDefinition,
						".this directive used outside type definition scope.");

				$$ = codegen.CurrentType;
			}
			| D_BASE
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.RelativeTypeReferenceOutsideTypeDefinition,
						".base directive used outside type definition scope.");

				var baseType = codegen.CurrentType.BaseType;

				if (baseType == null)
					report.WriteError (Error.NoBaseType,
						"Type has no base type.");

				$$ = baseType;
			}
			| D_NESTER
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.RelativeTypeReferenceOutsideTypeDefinition,
						".nester directive used outside type definition scope.");

				var nester = codegen.CurrentType.DeclaringType;

				if (nester == null)
					report.WriteError (Error.NoDeclaringType,
						"Type has no declaring type.");

				$$ = nester;
			}
			;

mdtoken_type		: mdtoken
			{
				$$ = codegen.GetTypeByMetadataToken ((int) $1);
			}
			;

type			: K_CLASS class_ref
			{
				$$ = $2;
			}
			| K_VALUE K_CLASS class_ref
			{
				$$ = $3;
			}
			| K_VALUETYPE class_ref
			{
				$$ = $2;
			}
			| type OPEN_BRACKET CLOSE_BRACKET
			{
				$$ = new ArrayType ((TypeReference) $1);
			}
			| type OPEN_BRACKET bounds CLOSE_BRACKET
			{
				var bounds = (List<ArrayDimension>) $3;
				var type = new ArrayType ((TypeReference) $1, bounds.Count);

				for (var i = 0; i < bounds.Count; i++)
					type.Dimensions [i] = bounds [i];

				$$ = type;
			}
			| type AMPERSAND
			{
				$$ = new ByReferenceType ((TypeReference) $1);
			}
			| type STAR
			{
				$$ = new PointerType ((TypeReference) $1);
			}
			| type K_PINNED
			{
				$$ = new PinnedType ((TypeReference) $1);
			}
			| type K_MODREQ OPEN_PARENS type_spec CLOSE_PARENS
			{
				$$ = new RequiredModifierType ((TypeReference) $4, (TypeReference) $1);
			}
			| type K_MODOPT OPEN_PARENS type_spec CLOSE_PARENS
			{
				$$ = new OptionalModifierType ((TypeReference) $4, (TypeReference) $1);
			}
			| K_METHOD call_conv type STAR OPEN_PARENS sig_args CLOSE_PARENS
			{
				var func = new FunctionPointerType {
					CallingConvention = (MethodCallingConvention) $2,
					ReturnType = (TypeReference) $3,
				};

				if (is_instance_call)
					func.HasThis = true;

				if (is_explicit_call)
					func.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<ParameterDefinition>) $6)
					func.Parameters.Add (arg);

				$$ = func;
			}
			| type typars_clause
			{
				var typeArgs = (List<TypeReference>) $2;

				if (typeArgs.Count > 0) {
					var gti = new GenericInstanceType ((TypeReference) $1);

					foreach (var ga in typeArgs)
						gti.GenericArguments.Add (ga);

					$$ = gti;
				} else
					$$ = $1;
			}
			| BANG int32
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.GenericParameterAccessOutsideType,
						"Cannot access a generic parameter outside a type definition.");

				var idx = (int) $2;
				var genParams = codegen.CurrentType.GenericParameters;

				if (idx >= genParams.Count)
					report.WriteError (Error.GenericParameterOrdinalOutOfRange,
						"Generic parameter ordinal '{0}' is invalid.", idx);

				$$ = genParams [idx];
			}
			| BANG id
			{
				if (codegen.CurrentType == null)
					report.WriteError (Error.GenericParameterAccessOutsideType,
						"Cannot access a generic parameter outside a type definition.");

				var name = (string) $2;
				GenericParameter param = null;

				foreach (var genParam in codegen.CurrentType.GenericParameters)
					if (genParam.Name == name)
						param = genParam;

				if (param == null)
					report.WriteError (Error.GenericParameterNameInvalid,
						"Generic parameter name '{0}' is invalid.", name);

				$$ = param;
			}
			| BANG BANG int32
			{
				if (codegen.CurrentMethod == null)
					report.WriteError (Error.GenericParameterAccessOutsideMethod,
						"Cannot access a generic parameter outside a method definition.");

				var idx = (int) $3;
				var genParams = codegen.CurrentMethod.GenericParameters;

				if (idx >= genParams.Count)
					report.WriteError (Error.GenericParameterOrdinalOutOfRange,
						"Generic parameter ordinal '{0}' is invalid.", idx);

				$$ = genParams [idx];
			}
			| BANG BANG id
			{
				if (codegen.CurrentMethod == null)
					report.WriteError (Error.GenericParameterAccessOutsideMethod,
						"Cannot access a generic parameter outside a method definition.");

				var name = (string) $3;
				GenericParameter param = null;

				foreach (var genParam in codegen.CurrentMethod.GenericParameters)
					if (genParam.Name == name)
						param = genParam;

				if (param == null)
					report.WriteError (Error.GenericParameterNameInvalid,
						"Generic parameter name '{0}' is invalid.", name);

				$$ = param;
			}
			| K_OBJECT
			{
				var obj = codegen.Corlib.Object;

				if (obj == null)
					report.WriteError (Error.SystemObjectUndefined,
						"System.Object has not been defined.");

				$$ = obj;
			}
			| K_VOID			{ $$ = codegen.Corlib.Void; }
			| K_TYPEDREF			{ $$ = codegen.Corlib.TypedReference; }
			| K_NATIVE K_INT		{ $$ = codegen.Corlib.IntPtr; }
			| K_NATIVE K_UNSIGNED K_INT	{ $$ = codegen.Corlib.UIntPtr; }
			| K_NATIVE K_UINT		{ $$ = codegen.Corlib.UIntPtr; }
			| K_NATIVE K_FLOAT		{ $$ = codegen.Corlib.Single; } // TODO: Verify this.
			| simple_type
			| ELLIPSIS type
			{
				$$ = new SentinelType ((TypeReference) $2);
			}
			;

unsigned_int8		: K_UINT8
			| K_UNSIGNED K_INT8
			;

unsigned_int16		: K_UINT16
			| K_UNSIGNED K_INT16
			;

unsigned_int32		: K_UINT32
			| K_UNSIGNED K_INT32
			;

unsigned_int64		: K_UINT64
			| K_UNSIGNED K_INT64
			;

int_type		: K_INT8			{ $$ = codegen.Corlib.SByte; }
			| K_INT16			{ $$ = codegen.Corlib.Int16; }
			| K_INT32			{ $$ = codegen.Corlib.Int32; }
			| K_INT64			{ $$ = codegen.Corlib.Int64; }
			| unsigned_int8			{ $$ = codegen.Corlib.Byte; }
			| unsigned_int16		{ $$ = codegen.Corlib.UInt16; }
			| unsigned_int32		{ $$ = codegen.Corlib.UInt32; }
			| unsigned_int64		{ $$ = codegen.Corlib.UInt64; }

simple_type		: K_FLOAT32			{ $$ = codegen.Corlib.Single; }
			| K_FLOAT64			{ $$ = codegen.Corlib.Double; }
			| K_CHAR			{ $$ = codegen.Corlib.Char; }
			| K_BOOL			{ $$ = codegen.Corlib.Boolean; }
			| K_STRING			{ $$ = codegen.Corlib.String; }
			| int_type
			;

typars_clause_opt	:
			| typars_clause
			;

typars_clause		: OPEN_ANGLE_BRACKET typars CLOSE_ANGLE_BRACKET
			{
				$$ = $2;
			}
			;

typars			: type
			{
				$$ = new List<TypeReference> () {
					(TypeReference) $1,
				};
			}
			| typars COMMA type
			{
				((List<TypeReference>) $1).Add ((TypeReference) $3);
				$$ = $1;
			}
			;

type_spec		: class_ref
			| OPEN_BRACKET slashed_name CLOSE_BRACKET // TODO: What do we do with this?
			| OPEN_BRACKET D_MODULE slashed_name CLOSE_BRACKET
			{
				var module = (string) $3;

				if (module == codegen.CurrentModule.Name)
					$$ = codegen.CurrentModule.GetModuleType ();
				else {
					var mod = codegen.GetModuleReference (module);

					if (mod == null)
						report.WriteError (Error.UndeclaredModuleReference,
							"Use of undeclared module: {0}", module);

					$$ = new TypeReference (string.Empty, "<Module>",
						codegen.CurrentModule, mod);
				}
			}
			| type
			;

bounds			: bound
			{
				$$ = new List<ArrayDimension> {
					(ArrayDimension) $1,
				};
			}
			| bounds COMMA bound
			{
				((List<ArrayDimension>) $1).Add ((ArrayDimension) $3);
			}
			;

bound			:
			{
				$$ = new ArrayDimension (null, null);
			}
			| ELLIPSIS
			{
				$$ = new ArrayDimension (null, null);
			}
			| int32
			{
				var size = (int) $1;

				if (size < 0) {
					report.WriteWarning (Warning.NegativeArraySize,
						"Negative array size '{0}' set to 0.", size);

					$$ = new ArrayDimension (0, 0);
				} else
					$$ = new ArrayDimension (0, size);
			}
			| int32 ELLIPSIS int32
			{
				var lower = (int) $1;
				var upper = (int) $3;

				$$ = new ArrayDimension (lower, upper);
			}
			| int32 ELLIPSIS
			{
				$$ = new ArrayDimension ((int) $1, null);
			}
			;

call_conv		: K_INSTANCE call_conv { is_instance_call = true; $$ = $2 ?? MethodCallingConvention.Default; }
			| K_EXPLICIT call_conv { is_explicit_call = true; $$ = $2 ?? MethodCallingConvention.Default; }
			| call_kind
			| K_CALLCONV OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (MethodCallingConvention) $3;
			}
			;

call_kind		:
			{
				$$ = MethodCallingConvention.Default;
			}
			| K_DEFAULT			{ $$ = MethodCallingConvention.Default; }
			| K_VARARG			{ $$ = MethodCallingConvention.VarArg; }
			| K_UNMANAGED K_CDECL		{ $$ = MethodCallingConvention.C; }
			| K_UNMANAGED K_STDCALL		{ $$ = MethodCallingConvention.StdCall; }
			| K_UNMANAGED K_THISCALL	{ $$ = MethodCallingConvention.ThisCall; }
			| K_UNMANAGED K_FASTCALL	{ $$ = MethodCallingConvention.FastCall; }
			;

marshal_info		:
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring CLOSE_PARENS
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring COMMA comp_qstring COMMA comp_qstring CLOSE_PARENS
			| K_FIXED K_SYSSTRING OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new FixedSysStringMarshalInfo {
					Size = (int) $4,
				};
			}
			| K_FIXED K_ARRAY OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new FixedArrayMarshalInfo {
					Size = (int) $4,
				};
			}
			| marshal_type STAR
			{
				report.WriteWarning (Warning.DeprecatedNativeType,
					"Pointer syntax for native types is deprecated.");

				// Emit an invalid native type. Don't ask me how this works;
				// blame Microsoft's ILAsm.
				$$ = new MarshalInfo ((NativeType) 0);
			}
			| marshal_type OPEN_BRACKET CLOSE_BRACKET
			{
				// This is not Microsoft-compatible. I have no idea how they
				// calculate the values they emit for jagged arrays.
				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
				};
			}
			| marshal_type OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					Size = (int) $3,
				};
			}
			| marshal_type OPEN_BRACKET int32 PLUS int32 CLOSE_BRACKET
			{
				is_parameter_marshal_notation = true;

				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					Size = (int) $3,
					SizeParameterMultiplier = (int) $5,
				};
			}
			| marshal_type OPEN_BRACKET PLUS int32 CLOSE_BRACKET
			{
				is_parameter_marshal_notation = true;

				$$ = new ArrayMarshalInfo {
					ElementType = (NativeType) $1,
					SizeParameterMultiplier = (int) $4,
				};
			}
			| K_SAFEARRAY variant_type
			{
				$$ = new SafeArrayMarshalInfo {
					ElementType = (VariantType) $2,
				};
			}
			| marshal_type
			{
				$$ = new MarshalInfo ((NativeType) $1);
			}
			;

unsigned_int		: K_UINT
			| K_UNSIGNED K_INT
			;

marshal_type		: K_CURRENCY				{ $$ = NativeType.Currency; }
			| K_BOOL				{ $$ = NativeType.Boolean; }
			| K_INT8				{ $$ = NativeType.I1; }
			| K_INT16				{ $$ = NativeType.I2; }
			| K_INT32				{ $$ = NativeType.I4; }
			| K_INT64				{ $$ = NativeType.I8; }
			| K_FLOAT32				{ $$ = NativeType.R4; }
			| K_FLOAT64				{ $$ = NativeType.R8; }
			| K_ERROR				{ $$ = NativeType.Error; }
			| unsigned_int8				{ $$ = NativeType.U1; }
			| unsigned_int16			{ $$ = NativeType.U2; }
			| unsigned_int32			{ $$ = NativeType.U4; }
			| unsigned_int64			{ $$ = NativeType.U8; }
			| K_BSTR				{ $$ = NativeType.BStr; }
			| K_LPSTR				{ $$ = NativeType.LPStr; }
			| K_LPWSTR				{ $$ = NativeType.LPWStr; }
			| K_LPTSTR				{ $$ = NativeType.LPTStr; }
			| K_IUNKNOWN				{ $$ = NativeType.IUnknown; }
			| K_IDISPATCH				{ $$ = NativeType.IDispatch; }
			| K_STRUCT				{ $$ = NativeType.Struct; }
			| K_INTERFACE				{ $$ = NativeType.IntF; }
			| K_INT					{ $$ = NativeType.Int; }
			| unsigned_int				{ $$ = NativeType.UInt; }
			| K_BYVALSTR				{ $$ = NativeType.ByValStr; }
			| K_ANSI K_BSTR				{ $$ = NativeType.ANSIBStr; }
			| K_TBSTR				{ $$ = NativeType.TBStr; }
			| K_VARIANT K_BOOL			{ $$ = NativeType.VariantBool; }
			| K_METHOD				{ $$ = NativeType.Func; }
			| K_AS K_ANY				{ $$ = NativeType.ASAny; }
			| K_LPSTRUCT				{ $$ = NativeType.LPStruct; }
			| native_type
			{
				// The grammar supports these types, but we can't
				// actually use them.
				report.WriteError(Error.UnsupportedNativeType,
					"Unsupported native type used in marshaling signature.");
			}
			;

native_type		: K_VARIANT
			| K_VOID
			| K_SYSCHAR
			| K_DECIMAL
			| K_DATE
			| K_OBJECTREF
			| K_NESTED K_STRUCT
			;

safearray_type		: K_VARIANT		{ $$ = VariantType.Variant; }
			| K_CURRENCY		{ $$ = VariantType.CY; }
			| K_BOOL		{ $$ = VariantType.Bool; }
			| K_INT8		{ $$ = VariantType.I1; }
			| K_INT16		{ $$ = VariantType.I2; }
			| K_INT32		{ $$ = VariantType.I4; }
			| K_FLOAT32		{ $$ = VariantType.R4; }
			| K_FLOAT64		{ $$ = VariantType.R8; }
			| unsigned_int8		{ $$ = VariantType.UI1; }
			| unsigned_int16	{ $$ = VariantType.UI2; }
			| unsigned_int32	{ $$ = VariantType.UI4; }
			| K_DECIMAL		{ $$ = VariantType.Decimal; }
			| K_DATE		{ $$ = VariantType.Date; }
			| K_BSTR		{ $$ = VariantType.BStr; }
			| K_IUNKNOWN		{ $$ = VariantType.Unknown; }
			| K_IDISPATCH		{ $$ = VariantType.Dispatch; }
			| K_INT 		{ $$ = VariantType.Int; }
			| unsigned_int		{ $$ = VariantType.UInt; }
			| K_ERROR		{ $$ = VariantType.Error; }
			| variant_type
			{
				// The grammar supports these types, but we can't
				// actually use them.
				report.WriteError(Error.UnsupportedVariantType,
					"Unsupported variant type used in safe array signature.");
			}
			;

variant_type		: K_NULL
			| K_VOID
			| K_INT64
			| unsigned_int64
			| STAR
			| variant_type OPEN_BRACKET CLOSE_BRACKET
			| variant_type K_VECTOR
			| variant_type AMPERSAND
			| K_LPSTR
			| K_LPWSTR
			| K_SAFEARRAY
			| K_HRESULT
			| K_CARRAY
			| K_USERDEFINED
			| K_RECORD
			| K_FILETIME
			| K_BLOB
			| K_STREAM
			| K_STORAGE
			| K_STREAMED_OBJECT
			| K_STORED_OBJECT
			| K_BLOB_OBJECT
			| K_CF
			| K_CLSID
			;

field_decl		: D_FIELD repeat_opt field_attr marshal_spec type id at_opt init_opt
			{
				var isGlobal = codegen.CurrentType == null;
				var attrs = (FieldAttributes) $3;
				var isStatic = attrs.HasBitFlag(FieldAttributes.Static);

				if (isGlobal && !isStatic)
				{
					attrs |= FieldAttributes.Static;

					report.WriteWarning (Warning.GlobalFieldMadeStatic,
						"Global field made static.");
				}

				var field = new FieldDefinition((string) $6, attrs, (TypeReference) $5);

				if ($2 != null) {
					if (!isGlobal)
						field.Offset = (int) $2;
					else
						report.WriteWarning (Warning.GlobalFieldOffsetIgnored,
							"Offset for global field ignored.");
				}

				if ($4 != null) {
					if (is_parameter_marshal_notation) {
						// TODO: This warning should be emitted more closely to the relevant code.
						report.WriteWarning (Warning.ParameterMarshalNotationOnField,
							"Invalid use of array marshal notation for parameters on a field.");

						is_parameter_marshal_notation = false;
					}

					field.MarshalInfo = (MarshalInfo) $4;
				}

				if ($7 != null) {
					if (!isStatic)
						report.WriteError (Error.InstanceFieldWithDataLocation,
							"Instance fields cannot have an associated data location.");

					var dataLoc = (string) $7;
					var mapping = codegen.GetFieldDataMapping (codegen.CurrentType ?? codegen.CurrentModule.GetModuleType ());
					mapping.Add (field, dataLoc);
				}

				if ($8 != null)
					field.Constant = $8 is Null ? null : $8;

				if (isGlobal)
					codegen.CurrentModule.GetModuleType ().Fields.Add (field);
				else
					codegen.CurrentType.Fields.Add (field);
			}
			;

repeat_opt		:
			| OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = $2;
			}
			;

field_attr		:
			{
				$$ = FieldAttributes.CompilerControlled;
			}
			| field_attr K_PUBLIC		{ $$ = (FieldAttributes) $1 | FieldAttributes.Public; }
			| field_attr K_PRIVATE		{ $$ = (FieldAttributes) $1 | FieldAttributes.Private; }
			| field_attr K_FAMILY		{ $$ = (FieldAttributes) $1 | FieldAttributes.Family; }
			| field_attr K_ASSEMBLY		{ $$ = (FieldAttributes) $1 | FieldAttributes.Assembly; }
			| field_attr K_FAMANDASSEM	{ $$ = (FieldAttributes) $1 | FieldAttributes.FamANDAssem; }
			| field_attr K_FAMORASSEM	{ $$ = (FieldAttributes) $1 | FieldAttributes.FamORAssem; }
			| field_attr K_PRIVATESCOPE
			| field_attr K_STATIC		{ $$ = (FieldAttributes) $1 | FieldAttributes.Static; }
			| field_attr K_INITONLY		{ $$ = (FieldAttributes) $1 | FieldAttributes.InitOnly; }
			| field_attr K_RTSPECIALNAME	{ $$ = (FieldAttributes) $1 | FieldAttributes.RTSpecialName; }
			| field_attr K_SPECIALNAME	{ $$ = (FieldAttributes) $1 | FieldAttributes.SpecialName; }
			| field_attr K_LITERAL		{ $$ = (FieldAttributes) $1 | FieldAttributes.Literal; }
			| field_attr K_NOTSERIALIZED	{ $$ = (FieldAttributes) $1 | FieldAttributes.NotSerialized; }
			;

marshal_spec		:
			| K_MARSHAL OPEN_PARENS marshal_info CLOSE_PARENS
			{
				$$ = $3;
			}
			;

at_opt			:
			| K_AT id
			{
				$$ = $2;
			}
			;

init_opt		:
			| ASSIGN field_init
			{
				$$ = $2;
			}
			;

field_init_primitive	: K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = (float) (double) $3;
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_FLOAT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = BitConverter.ToSingle (BitConverter.GetBytes ((long) $3), BitConverter.IsLittleEndian ? 0 : 4);
			}
			| K_FLOAT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = BitConverter.Int64BitsToDouble ((long) $3);
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = $3;
			}
			| unsigned_int64 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (ulong) (long) $3;
			}
			| K_INT32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (int) (long) $3;
			}
			| unsigned_int32 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (uint) (long) $3;
			}
			| K_INT16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (short) (long) $3;
			}
			| unsigned_int16 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (ushort) (long) $3;
			}
			| K_INT8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (sbyte) (long) $3;
			}
			| unsigned_int8 OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (byte) (long) $3;
			}
			| K_CHAR OPEN_PARENS int64 CLOSE_PARENS
			{
				$$ = (char) (long) $3;
			}
			| K_BOOL OPEN_PARENS truefalse CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			;

field_init		: field_init_primitive
			| comp_qstring
			| K_NULLREF
			{
				$$ = new Null ();
			}
			;

data_decl		: data_head data_body
			{
				if ($1 != null)
				{
					foreach (var item in (List<object>) $2)
						codegen.DataConstants.Add ((string) $1, item);

					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Data constants are currently just copied to static fields.");
				}
				else
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Unlabeled data constants currently have no effect.");
			}
			;

data_name		:
			| id ASSIGN
			{
				$$ = $1;
			}
			;

data_head		: D_DATA tls cil data_name
			{
				if ((bool) $2)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"TLS data constants are not currently supported.");

				if ((bool) $3)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"CIL data constants are not currently supported.");

				$$ = $4;
			}
			;

tls			:
			{
				$$ = false;
			}
			| K_TLS
			{
				$$ = true;
			}
			;

cil			:
			{
				$$ = false;
			}
			| K_CIL
			{
				$$ = true;
			}
			;

data_body		: OPEN_BRACE dataitem_list CLOSE_BRACE
			{
				$$ = $2;
			}
			| dataitem
			{
				$$ = new List<object> {
					$1,
				};
			}
			;

dataitem_list		: dataitem
			{
				$$ = new List<object> {
					$1,
				};
			}
			| dataitem_list COMMA dataitem
			{
				((List<object>) $1).Add ($3);
			}
			;

data_repeat_opt		: repeat_opt
			{
				if ($1 != null)
					report.WriteWarning (Warning.UnimplementedFeatureUsed,
						"Repeated data constants currently have no effect.");
			}
			;

dataitem		: K_CHAR STAR OPEN_PARENS comp_qstring CLOSE_PARENS
			{
				$$ = $4;
			}
			| AMPERSAND OPEN_PARENS id CLOSE_PARENS
			{
				$$ = IntPtr.Zero;
			}
			| K_BYTEARRAY bytes_list
			{
				$$ = $2;
			}
			| K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS data_repeat_opt
			{
				$$ = (float) (double) $3;
			}
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_INT32 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = $3;
			}
			| K_INT16 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = (short) (int) $3;
			}
			| K_INT8 OPEN_PARENS int32 CLOSE_PARENS data_repeat_opt
			{
				$$ = (byte) (int) $3;
			}
			| K_FLOAT32 data_repeat_opt
			{
				$$ = 0.0f;
			}
			| K_FLOAT64 data_repeat_opt
			{
				$$ = 0.0d;
			}
			| K_INT64 data_repeat_opt
			{
				$$ = (long) 0;
			}
			| K_INT32 data_repeat_opt
			{
				$$ = (int) 0;
			}
			| K_INT16 data_repeat_opt
			{
				$$ = (short) 0;
			}
			| K_INT8 data_repeat_opt
			{
				$$ = (byte) 0;
			}
			;

method_all		: method_head OPEN_BRACE method_decls CLOSE_BRACE
			{
				if (codegen.CurrentType != null)
					codegen.CurrentType.Methods.Add (codegen.CurrentMethod);
				else
					codegen.CurrentModule.GetModuleType ().Methods.Add (codegen.CurrentMethod);

				codegen.CurrentMethod = null;
			}
			;

method_head		: D_METHOD meth_attr call_conv param_attr type sig_marshal_clause method_name formal_typars_clause OPEN_PARENS sig_args CLOSE_PARENS impl_attr
			{
				var name = (string) $7;

				var method = new MethodDefinition (name, (MethodAttributes) $2,
					(TypeReference) $5) {
					CallingConvention = (MethodCallingConvention) $1,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				if (codegen.CurrentType != null)
					method.DeclaringType = codegen.CurrentType;

				if (codegen.CurrentPInvokeInfo != null) {
					if (codegen.GetModuleReference (pinvoke_mod_name) != null) {
						var module = new ModuleReference (pinvoke_mod_name);

						codegen.CurrentModule.ModuleReferences.Add (module);
						codegen.CurrentPInvokeInfo.Module = module;
						pinvoke_mod_name = null;
					}

					if (codegen.CurrentPInvokeInfo.EntryPoint == null)
						codegen.CurrentPInvokeInfo.EntryPoint = name;

					method.PInvokeInfo = codegen.CurrentPInvokeInfo;
					codegen.CurrentPInvokeInfo = null;
				}

				// TODO: We can't do this with Cecil currently.
				//method.MethodReturnType.Attributes = (ParameterAttributes) $4;

				method.MethodReturnType.MarshalInfo = $6 != null ? (MarshalInfo) $6 : null;

				foreach (var arg in (List<GenericParameter>) $8)
					method.GenericParameters.Add (arg);

				foreach (var arg in (List<TypeReference>) $10)
					method.Parameters.Add (new ParameterDefinition (arg));

				method.ImplAttributes = (MethodImplAttributes) $12;

				codegen.CurrentMethod = method;
				codegen.CurrentGenericParameterProvider = method;
			}
			;

meth_attr		:
			{
				$$ = MethodAttributes.CompilerControlled;
			}
			| meth_attr K_STATIC			{ $$ = (MethodAttributes) $1 | MethodAttributes.Static; }
			| meth_attr K_PUBLIC			{ $$ = (MethodAttributes) $1 | MethodAttributes.Public; }
			| meth_attr K_PRIVATE			{ $$ = (MethodAttributes) $1 | MethodAttributes.Private; }
			| meth_attr K_FAMILY			{ $$ = (MethodAttributes) $1 | MethodAttributes.Family; }
			| meth_attr K_ASSEMBLY			{ $$ = (MethodAttributes) $1 | MethodAttributes.Assembly; }
			| meth_attr K_FAMANDASSEM		{ $$ = (MethodAttributes) $1 | MethodAttributes.FamANDAssem; } 
			| meth_attr K_FAMORASSEM		{ $$ = (MethodAttributes) $1 | MethodAttributes.FamORAssem; } 
			| meth_attr K_PRIVATESCOPE
			| meth_attr K_FINAL			{ $$ = (MethodAttributes) $1 | MethodAttributes.Final; } 
			| meth_attr K_VIRTUAL			{ $$ = (MethodAttributes) $1 | MethodAttributes.Virtual; }
			| meth_attr K_ABSTRACT			{ $$ = (MethodAttributes) $1 | MethodAttributes.Abstract; }
			| meth_attr K_HIDEBYSIG			{ $$ = (MethodAttributes) $1 | MethodAttributes.HideBySig; }
			| meth_attr K_NEWSLOT			{ $$ = (MethodAttributes) $1 | MethodAttributes.NewSlot; }
			| meth_attr K_REQSECOBJ			{ $$ = (MethodAttributes) $1 | MethodAttributes.RequireSecObject; }
			| meth_attr K_SPECIALNAME		{ $$ = (MethodAttributes) $1 | MethodAttributes.SpecialName; }
			| meth_attr K_RTSPECIALNAME		{ $$ = (MethodAttributes) $1 | MethodAttributes.RTSpecialName; }
			| meth_attr K_STRICT			{ $$ = (MethodAttributes) $1 | MethodAttributes.CheckAccessOnOverride; }
			| meth_attr K_COMPILERCONTROLLED
			| meth_attr K_UNMANAGEDEXP
			| meth_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (MethodAttributes) $1 | (MethodAttributes) (int) $4;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring K_AS comp_qstring pinv_attr CLOSE_PARENS
			{
				codegen.CurrentPInvokeInfo = new PInvokeInfo ((PInvokeAttributes) $7, (string) $6, null);
				pinvoke_mod_name = (string) $4;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring pinv_attr CLOSE_PARENS
			{
				codegen.CurrentPInvokeInfo = new PInvokeInfo ((PInvokeAttributes) $5, null, null);
				pinvoke_mod_name = (string) $4;
			}
			| meth_attr K_PINVOKEIMPL OPEN_PARENS pinv_attr CLOSE_PARENS
			{
				report.WriteError (Error.NativeCodeUnsupported,
					"Cannot compile embedded native code.");
			}
			;

pinv_attr		:
			{
				$$ = PInvokeAttributes.CharSetNotSpec;
			}
			| pinv_attr K_NOMANGLE			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.NoMangle; }
			| pinv_attr K_ANSI			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CharSetAnsi; }
			| pinv_attr K_UNICODE			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CharSetUnicode; }
			| pinv_attr K_AUTOCHAR			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CharSetAuto; }
			| pinv_attr K_LASTERR			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.SupportsLastError; }
			| pinv_attr K_WINAPI			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvWinapi; }
			| pinv_attr K_PLATFORMAPI		{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvWinapi; }
			| pinv_attr K_CDECL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvCdecl; }
			| pinv_attr K_STDCALL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvStdCall; }
			| pinv_attr K_THISCALL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvThiscall; }
			| pinv_attr K_FASTCALL			{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.CallConvFastcall; }
			| pinv_attr K_BESTFIT COLON K_ON	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.BestFitEnabled; }
			| pinv_attr K_BESTFIT COLON K_OFF	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.BestFitDisabled; }
			| pinv_attr K_CHARMAPERROR COLON K_ON	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.ThrowOnUnmappableCharEnabled; }
			| pinv_attr K_CHARMAPERROR COLON K_OFF	{ $$ = (PInvokeAttributes) $1 | PInvokeAttributes.ThrowOnUnmappableCharDisabled; }
			| pinv_attr K_FLAGS OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = (PInvokeAttributes) $1 | (PInvokeAttributes) (int) $4;
			}
			;

impl_attr		:
			{
				$$ = MethodImplAttributes.Managed;
			}
			| impl_attr K_NATIVE
			{
				report.WriteError (Error.NativeCodeUnsupported,
					"Cannot compile native code.");
			}
			| impl_attr K_CIL		{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.IL; }
			| impl_attr K_IL		{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.IL; }
			| impl_attr K_OPTIL		{ /*$$ = (MethodImplAttributes) $1 | MethodImplAttributes.OPTIL;*/ }
			| impl_attr K_MANAGED
			| impl_attr K_UNMANAGED
			{
				report.WriteError (Error.NativeCodeUnsupported,
					"Cannot compile unmanaged code.");
			}
			| impl_attr K_FORWARDREF	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.ForwardRef; }
			| impl_attr K_PRESERVESIG	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.PreserveSig; }
			| impl_attr K_RUNTIME		{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.Runtime; }
			| impl_attr K_INTERNALCALL	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.InternalCall; }
			| impl_attr K_SYNCHRONIZED	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.Synchronized; }
			| impl_attr K_NOINLINING	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.NoInlining; }
			| impl_attr K_NOOPTIMIZATION	{ $$ = (MethodImplAttributes) $1 | MethodImplAttributes.NoOptimization; }
			;

param_attr		:
			{
				$$ = ParameterAttributes.None;
			}
			| param_attr OPEN_BRACKET K_IN CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.In; }
			| param_attr OPEN_BRACKET K_OUT CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.Out; }
			| param_attr OPEN_BRACKET K_OPT CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | ParameterAttributes.Optional; }
			| param_attr OPEN_BRACKET int32 CLOSE_BRACKET	{ $$ = (ParameterAttributes) $1 | (ParameterAttributes) (int) $3; }
			;

sig_args		:
			{
				$$ = new List<ParameterDefinition> ();
			}
			| sig_arg_list
			;

sig_arg_list 		: sig_arg
			{
				$$ = new List<ParameterDefinition> {
					(ParameterDefinition) $1,
				};
			}
			| sig_arg_list COMMA sig_arg
			{
				((List<ParameterDefinition>) $1).Add ((ParameterDefinition) $3);
			}
			;

sig_marshal_clause	:
			| K_MARSHAL OPEN_PARENS marshal_type CLOSE_PARENS
			{
				$$ = new MarshalInfo ((NativeType) $3);
			}
			;

sig_arg			: ELLIPSIS // TODO: Construct the sentinel type...
			| param_attr type sig_marshal_clause
			{
				$$ = new ParameterDefinition ((TypeReference) $2) {
					Attributes = (ParameterAttributes) $1,
					MarshalInfo = $3 != null ? (MarshalInfo) $3 : null,
				};
			}
			| param_attr type sig_marshal_clause id
			{
				$$ = new ParameterDefinition ((string) $4, (ParameterAttributes) $1,
					(TypeReference) $2) {
					MarshalInfo = $3 != null ? (MarshalInfo) $3 : null,
				};
			}
			;

method_decls		:
			| method_decls method_decl
			;

method_decl		: D_EMITBYTE int32 // TODO: Cecil doesn't support this.
			| D_MAXSTACK int32
			{
				codegen.CurrentMethod.Body.MaxStackSize = (int) $2;
			}
			| D_LOCALS OPEN_PARENS sig_args CLOSE_PARENS
			| D_LOCALS K_INIT OPEN_PARENS sig_args CLOSE_PARENS
			{
				codegen.CurrentMethod.Body.InitLocals = true;
			}
			| D_ENTRYPOINT
			{
				codegen.CurrentModule.EntryPoint = codegen.CurrentMethod;
			}
			| D_ZEROINIT
			{
				codegen.CurrentMethod.Body.InitLocals = true;
			}
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET K_AS id
			| D_VTENTRY int32 COLON int32 
			| D_OVERRIDE type_spec DOUBLE_COLON method_name
			{
				var overridenMethod = new MethodReference ((string) $4,
					codegen.CurrentMethod.ReturnType, (TypeReference) $2);
				codegen.CurrentMethod.Overrides.Add (overridenMethod);
			}
			| D_OVERRIDE generic_method_ref
			{
				codegen.CurrentMethod.Overrides.Add ((MethodReference) $2);
			}
			| scope_block
			| D_PARAM OPEN_BRACKET int32 CLOSE_BRACKET init_opt
			/*
			| param_type_decl
			*/
			| id COLON
			| seh_block
			| instr
			/*
			| sec_decl
			*/
			| extsource_spec
			| language_decl
			| customattr_decl
			{
				codegen.CurrentMethod.CustomAttributes.Add ((CustomAttribute) $1);
				codegen.CurrentCustomAttribute = null;
			}
			| data_decl
			| comp_control
			;

slot_num		: OPEN_BRACKET int32 CLOSE_BRACKET
			{
				$$ = $2;
			}
			;

scope_block		: OPEN_BRACE method_decls CLOSE_BRACE
			;

seh_block		: try_block seh_clauses
			;

try_block		: D_TRY scope_block
			| D_TRY id K_TO id
			| D_TRY int32 K_TO int32
			;

seh_clauses		: seh_clause
			| seh_clauses seh_clause
			;

seh_clause		: K_CATCH type_spec handler_block
			| K_FINALLY handler_block
			| K_FAULT handler_block
			| filter_clause handler_block
			;

filter_clause		: K_FILTER scope_block
			| K_FILTER id
			| K_FILTER int32
			;

handler_block		: scope_block
			| K_HANDLER id K_TO id
			| K_HANDLER int32 K_TO int32
			;

instr			: INSTR_NONE
			| INSTR_LOCAL int32
			| INSTR_LOCAL id
			| INSTR_PARAM int32
			| INSTR_PARAM id
			| INSTR_I int32
			| INSTR_I8 int64
			| INSTR_R float64
			| INSTR_R int64
			| INSTR_R bytes_list
			| INSTR_BRTARGET int32
			| INSTR_BRTARGET id
			| INSTR_METHOD method_ref
			| INSTR_FIELD field_ref
			| INSTR_TYPE type_spec
			| INSTR_STRING comp_qstring
			| INSTR_STRING K_ANSI comp_qstring
			| INSTR_STRING K_BYTEARRAY ASSIGN bytes_list
			| INSTR_SIG call_conv type OPEN_PARENS sig_args CLOSE_PARENS
			| INSTR_TOK owner_type
			| INSTR_SWITCH OPEN_PARENS labels CLOSE_PARENS
			| INSTR_PHI int16_seq
			;

labels			:
			| id
			| int32
			| id COMMA labels
			| int32 COMMA labels
			;

member_ref		: K_METHOD method_ref
			{
				$$ = $2;
			}
			| K_FIELD field_ref
			{
				$$ = $2;
			}
			;

field_ref		: type type_spec DOUBLE_COLON comp_name
			{
				$$ = new FieldReference (((QualifiedName) $4).FullName,
					(TypeReference) $1, (TypeReference) $2);
			}
			| type comp_name
			{
				$$ = new FieldReference (((QualifiedName) $2).FullName,
					(TypeReference) $1);
			}
			| mdtoken
			;

method_ref		: call_conv type method_name typars_clause_opt OPEN_PARENS sig_args CLOSE_PARENS
			{
				var method = new MethodReference ((string) $3, (TypeReference) $2) {
					CallingConvention = (MethodCallingConvention) $1,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $6)
					method.Parameters.Add (new ParameterDefinition (arg));

				if ($4 != null) {
					var genMethod = new GenericInstanceMethod (method);

					foreach (var typeArg in (List<TypeReference>) $4)
						genMethod.GenericArguments.Add (typeArg);

					method = genMethod;
				}
			}
			| call_conv type type_spec DOUBLE_COLON method_name typars_clause_opt OPEN_PARENS sig_args CLOSE_PARENS
			{
				var method = new MethodReference ((string) $5, (TypeReference) $2, (TypeReference) $3) {
					CallingConvention = (MethodCallingConvention) $1,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $8)
					method.Parameters.Add (new ParameterDefinition (arg));

				if ($6 != null) {
					var genMethod = new GenericInstanceMethod (method);

					foreach (var typeArg in (List<TypeReference>) $6)
						genMethod.GenericArguments.Add (typeArg);

					method = genMethod;
				}
			}
			| mdtoken
			;

method_name		: D_CTOR
			| D_CCTOR
			| comp_name
			{
				$$ = ((QualifiedName) $1).FullName;
			}
			;

generic_method_ref	: K_METHOD call_conv type type_spec DOUBLE_COLON method_name generic_arity OPEN_PARENS sig_args CLOSE_PARENS
			{
				var method = new MethodReference ((string) $6, (TypeReference) $3, (TypeReference) $4) {
					CallingConvention = (MethodCallingConvention) $2,
				};

				if (is_instance_call)
					method.HasThis = true;

				if (is_explicit_call)
					method.ExplicitThis = true;

				is_instance_call = false;
				is_explicit_call = false;

				foreach (var arg in (List<TypeReference>) $9)
					method.Parameters.Add (new ParameterDefinition (arg));

				if ($7 != null)
					for (var i = 0; i < (int) $7; i++)
						method.GenericParameters.Add (new GenericParameter (method));

				$$ = method;
			}
			;

generic_arity		:
			| OPEN_BRACKET OPEN_ANGLE_BRACKET int32 CLOSE_ANGLE_BRACKET CLOSE_BRACKET
			{
				$$ = $3;
			}
			;

owner_type		: type_spec
			| member_ref
			;

event_all		: event_head OPEN_BRACE event_decls CLOSE_BRACE
			{
				codegen.CurrentType.Events.Add (codegen.CurrentEvent);
				codegen.CurrentEvent = null;
			}
			;

event_head		: D_EVENT event_attr type_spec comp_name
			{
				codegen.CurrentEvent = new EventDefinition (((QualifiedName) $4).FullName,
					(EventAttributes) $2, (TypeReference) $3);
			}
			| D_EVENT event_attr id // TODO: What do we do here? Infer some type?
			;

event_attr		:
			{
				$$ = EventAttributes.None;
			}
			| event_attr K_RTSPECIALNAME	{ $$ = (EventAttributes) $1 & EventAttributes.RTSpecialName; }
			| event_attr K_SPECIALNAME	{ $$ = (EventAttributes) $1 & EventAttributes.SpecialName; }
			;

event_decls		:
			| event_decls event_decl
			;

event_decl		: D_ADDON method_ref
			{
				var methodRef = (MethodReference) $2;

				if (methodRef.DeclaringType == null)
					methodRef.DeclaringType = codegen.CurrentType;

				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve add method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.AddMethod = method;
			}
			| D_REMOVEON method_ref
			{
				var methodRef = (MethodReference) $2;

				if (methodRef.DeclaringType == null)
					methodRef.DeclaringType = codegen.CurrentType;

				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve remove method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.RemoveMethod = method;
			}
			| D_FIRE method_ref
			{
				var methodRef = (MethodReference) $2;

				if (methodRef.DeclaringType == null)
					methodRef.DeclaringType = codegen.CurrentType;

				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve fire method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.InvokeMethod = method;
			}
			| D_OTHER method_ref
			{
				// Other methods don't get a default type spec.
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidEventMethod,
						"Could not resolve other method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidEventMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentEvent.OtherMethods.Add (method);
			}
			| customattr_decl
			{
				codegen.CurrentEvent.CustomAttributes.Add ((CustomAttribute) $1);
				codegen.CurrentCustomAttribute = null;
			}
			| extsource_spec
			| language_decl
			| comp_control
			;

prop_all		: prop_head OPEN_BRACE prop_decls CLOSE_BRACE
			{
				codegen.CurrentType.Properties.Add (codegen.CurrentProperty);
				codegen.CurrentProperty = null;
			}
			;

prop_head		: D_PROPERTY prop_attr type comp_name OPEN_PARENS sig_args CLOSE_PARENS init_opt
			{
				codegen.CurrentProperty = new PropertyDefinition (((QualifiedName) $4).FullName,
					(PropertyAttributes) $2, (TypeReference) $3);

				foreach (var param in (List<TypeReference>) $6)
					codegen.CurrentProperty.Parameters.Add (new ParameterDefinition (param));

				if ($8 != null)
					codegen.CurrentProperty.Constant = $8 is Null ? null : $8;
			}
			;

prop_attr 		:
			{
				$$ = PropertyAttributes.None;
			}
			| prop_attr K_RTSPECIALNAME	{ $$ = (PropertyAttributes) $1 | PropertyAttributes.RTSpecialName; }
			| prop_attr K_SPECIALNAME	{ $$ = (PropertyAttributes) $1 | PropertyAttributes.SpecialName; }
			;

prop_decls		:
			| prop_decls prop_decl
			;

prop_decl		: D_SET method_ref
			{
				var methodRef = (MethodReference) $2;

				if (methodRef.DeclaringType == null)
					methodRef.DeclaringType = codegen.CurrentType;

				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve set method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidPropertyMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentProperty.SetMethod = method;
			}
			| D_GET method_ref
			{
				var methodRef = (MethodReference) $2;

				if (methodRef.DeclaringType == null)
					methodRef.DeclaringType = codegen.CurrentType;

				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve get method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidPropertyMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentProperty.GetMethod = method;
			}
			| D_OTHER method_ref
			{
				// Other methods don't get a default type spec.
				var methodRef = (MethodReference) $2;
				var method = methodRef.Resolve ();

				if (method == null)
					report.WriteError (Error.InvalidPropertyMethod,
						"Could not resolve other method '{0}'.", methodRef);

				if (method.Module.FullyQualifiedName != codegen.CurrentModule.FullyQualifiedName)
					report.WriteError (Error.InvalidPropertyMethod,
						"Method '{0}' is not within the current module.", method);

				codegen.CurrentProperty.OtherMethods.Add (method);
			}
			| customattr_decl
			{
				codegen.CurrentProperty.CustomAttributes.Add ((CustomAttribute) $1);
				codegen.CurrentCustomAttribute = null;
			}
			| extsource_spec
			| language_decl
			| comp_control
			;

customattr_decl		: customattr
			| customattr_owner
			;

customattr		: D_CUSTOM method_ref
			{
				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2);
			}
			| D_CUSTOM method_ref ASSIGN comp_qstring
			{
				var bytes = Encoding.Unicode.GetBytes ((string) $4);

				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2, bytes);
			}
			| D_CUSTOM method_ref ASSIGN OPEN_BRACE customattr_blob CLOSE_BRACE
			{
				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2);
			}
			| D_CUSTOM method_ref ASSIGN bytes_list
			{
				$$ = codegen.CurrentCustomAttribute = new CustomAttribute ((MethodReference) $2, (byte[]) $4);
			}
			;

customattr_owner	: D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref ASSIGN comp_qstring
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref ASSIGN OPEN_BRACE customattr_blob CLOSE_BRACE
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS method_ref ASSIGN bytes_list
			;

customattr_blob		: customattr_blob_args customattr_blob_nvp
			;

customattr_blob_args	:
			| customattr_blob_args customattr_blob_init
			{
				var value = $2;

				if (value is TypedNull<string>)
					value = null;
				else if (value is TypedNull<TypeReference>)
					value = null;

				// TODO: Should we try to figure out the type?
				var arg = new CustomAttributeArgument (null, value);

				codegen.CurrentCustomAttribute.ConstructorArguments.Add (arg);
			}
			| customattr_blob_args comp_control
			;

customattr_blob_nvp	:
			| customattr_blob_nvp prop_or_field customattr_blob_type comp_name ASSIGN customattr_blob_init
			{
				TypeReference type = null;
				var value = $6;

				if (value is TypedNull<string>) {
					type = codegen.Corlib.String;
					value = null;
				} else if (value is TypedNull<TypeReference>) {
					type = codegen.Corlib.Type;
					value = null;
				}

				var arg = new CustomAttributeArgument (type ?? (TypeReference) $3, value);
				var namedArg = new CustomAttributeNamedArgument (((QualifiedName) $4).FullName, arg);

				if ((TokenType) $2 == TokenType.Field)
					codegen.CurrentCustomAttribute.Fields.Add (namedArg);
				else
					codegen.CurrentCustomAttribute.Properties.Add (namedArg);
			}
			| customattr_blob_nvp comp_control
			;

customattr_blob_type	: simple_type
			| K_TYPE
			{
				$$ = codegen.Corlib.Type;
			}
			| K_OBJECT
			{
				$$ = codegen.Corlib.Object;
			}
			| K_ENUM K_CLASS SQSTRING
			| K_ENUM class_ref
			{
				$$ = $2;
			}
			| customattr_blob_type OPEN_BRACKET CLOSE_BRACKET
			{
				$$ = new ArrayType ((TypeReference) $1);
			}
			;

customattr_blob_init	: field_init_primitive
			| K_STRING OPEN_PARENS K_NULLREF CLOSE_PARENS
			{
				$$ = new TypedNull<string> ();
			}
			| K_STRING OPEN_PARENS SQSTRING CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_TYPE OPEN_PARENS K_CLASS SQSTRING CLOSE_PARENS
			| K_TYPE OPEN_PARENS class_ref CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_TYPE OPEN_PARENS K_NULLREF CLOSE_PARENS
			{
				$$ = new TypedNull<TypeReference> ();
			}
			| K_OBJECT OPEN_PARENS customattr_blob_init CLOSE_PARENS
			{
				$$ = $3;
			}
			| K_FLOAT32 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS float32_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_FLOAT64 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS float64_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_INT8 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int8_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_INT16 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int16_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_INT32 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int32_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_INT64 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int64_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| unsigned_int8 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int8_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| unsigned_int16 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int16_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| unsigned_int32 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int32_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| unsigned_int64 OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int64_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_CHAR OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS int16_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_BOOL OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS bool_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_STRING OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS string_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_TYPE OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS class_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			| K_OBJECT OPEN_BRACKET int32 CLOSE_BRACKET OPEN_PARENS obj_seq CLOSE_PARENS
			{
				custom_attr_blob_seq_length = System.Math.Max (0, (int) $3);

				$$ = $6;
			}
			;

float32_seq		:
			{
				$$ = new float [0];
			}
			| float32_seq float64
			{
				var arr = (float[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (float) $2;
				}
			}
			| float32_seq int32
			{
				var arr = (float[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = BitConverter.ToSingle (BitConverter.GetBytes ((int) $2),
						BitConverter.IsLittleEndian ? 0 : 4);
				}
			}
			;

float64_seq		:
			{
				$$ = new double [0];
			}
			| float64_seq float64
			{
				var arr = (double[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (double) $2;
				}
			}
			| float64_seq int64
			{
				var arr = (double[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = BitConverter.Int64BitsToDouble ((long) $2);
				}
			}
			;

int8_seq		:
			{
				$$ = new byte [0];
			}
			| int8_seq int32
			{
				var arr = (byte[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (byte) $2;
				}
			}
			;

int16_seq		:
			{
				$$ = new short [0];
			}
			| int16_seq int32
			{
				var arr = (short[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (short) $2;
				}
			}
			;

int32_seq		:
			{
				$$ = new int [0];
			}
			| int32_seq int32
			{
				var arr = (int[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (int) $2;
				}
			}
			;

int64_seq		:
			{
				$$ = new long [0];
			}
			| int64_seq int64
			{
				var arr = (long[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (long) $2;
				}
			}
			;

bool_seq		:
			{
				$$ = new bool [0];
			}
			| bool_seq truefalse
			{
				var arr = (bool[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (bool) $2;
				}
			}
			;

string_seq		:
			{
				$$ = new string [0];
			}
			| string_seq K_NULLREF
			{
				var arr = (string[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = null;
				}
			}
			| string_seq SQSTRING
			{
				var arr = (string[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (string) $2;
				}
			}
			;

class_seq		:
			{
				$$ = new TypeReference [0];
			}
			| class_seq K_NULLREF
			{
				var arr = (TypeReference[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = null;
				}
			}
			| class_seq K_CLASS SQSTRING
			| class_seq class_ref
			{
				var arr = (TypeReference[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = (TypeReference) $2;
				}
			}
			;

obj_seq			:
			{
				$$ = new object [0];
			}
			| obj_seq customattr_blob_init
			{
				var arr = (object[]) $1;

				if (arr.Length != custom_attr_blob_seq_length) {
					arr = arr.Inflate (1);
					arr [arr.Length - 1] = $2;
				}
			}
			;

/*
sec_decl		: D_PERMISSION sec_action type_spec OPEN_PARENS nameval_pairs CLOSE_PARENS
			{
				$$ = TypeSpecToPermPair ($2, $3, (ArrayList) $5);
			}
			| D_PERMISSION sec_action type_spec
			{
				$$ = TypeSpecToPermPair ($2, $3, null);
			}
			| D_PERMISSIONSET sec_action ASSIGN bytes_list
			{
				System.Text.UnicodeEncoding ue = new System.Text.UnicodeEncoding ();
				PermissionSetAttribute psa = new PermissionSetAttribute ((System.Security.Permissions.SecurityAction) (short) $2);
				psa.XML = ue.GetString ((byte []) $4);
				$$ = new PermPair ((Mono.Cecil.SecurityAction) $2, psa.CreatePermissionSet ());
			}
			| D_PERMISSIONSET sec_action comp_qstring
			{
				PermissionSetAttribute psa = new PermissionSetAttribute ((System.Security.Permissions.SecurityAction) (short) $2);
				psa.XML = (string) $3;
				$$ = new PermPair ((Mono.Cecil.SecurityAction) $2, psa.CreatePermissionSet ());
			}
			| D_PERMISSIONSET sec_action ASSIGN OPEN_BRACE permissions CLOSE_BRACE
			{
				$$ = new MIPermissionSet ((Mono.Cecil.SecurityAction) $2, (ArrayList) $5);
			}
			;

permissions		: permission
			{
				ArrayList list = new ArrayList ();
				list.Add ($1);
				$$ = list;
			}
			| permissions COMMA permission
			{
				ArrayList list = (ArrayList) $1;
				list.Add ($3);
				$$ = list;
			}
			;

permission		: class_ref ASSIGN OPEN_BRACE permission_members CLOSE_BRACE
			{
				$$ = new MIPermission ((BaseTypeRef) $1, (ArrayList) $4);
			}
			;

permission_members	: permission_member
			{
				ArrayList list = new ArrayList ();
				list.Add ($1);
				$$ = list;
			}
			| permission_members permission_member
			{
				ArrayList list = (ArrayList) $1;
				list.Add ($2);
				$$ = list;
			}
			;

permission_member	: prop_or_field primitive_type perm_mbr_nameval_pair
			{
				NameValuePair pair = (NameValuePair) $3;
				$$ = new PermissionMember ((MemberTypes) $1, (BaseTypeRef) $2, pair.Name, pair.Value);
			}
			| prop_or_field K_ENUM class_ref perm_mbr_nameval_pair
			{
				NameValuePair pair = (NameValuePair) $4;
				$$ = new PermissionMember ((MemberTypes) $1, (BaseTypeRef) $3, pair.Name, pair.Value);
			}
			;

perm_mbr_nameval_pair	: SQSTRING ASSIGN field_init_primitive
			{
				$$ = new NameValuePair ((string) $1, (PEAPI.Constant) $3);
			}
			| SQSTRING ASSIGN K_BYTEARRAY bytes_list
			{
				$$ = new NameValuePair ((string) $1, new ByteArrConst ((byte[]) $4));
			}
			| SQSTRING ASSIGN K_STRING OPEN_PARENS SQSTRING CLOSE_PARENS
			{
				$$ = new NameValuePair ((string) $1, new StringConst ((string) $5));
			}
			;

nameval_pairs		: nameval_pair 
			{
				ArrayList pairs = new ArrayList ();
				pairs.Add ($1);

				$$ = pairs;
			}
			| nameval_pairs COMMA nameval_pair
			{
				ArrayList pairs = (ArrayList) $1;
				pairs.Add ($3);

				$$ = pairs;
			}
			;

nameval_pair 		: comp_qstring ASSIGN cavalue
			{
				$$ = new NameValuePair ((string) $1, $3);
			}
			;

cavalue 		: truefalse
			| int32
			| int32 OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = $3;
			}
			| comp_qstring 
			| class_ref OPEN_PARENS K_INT8 COLON int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (byte) (int) $5);
			}
			| class_ref OPEN_PARENS K_INT16 COLON int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (short) (int) $5);
			}
			| class_ref OPEN_PARENS K_INT32 COLON int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (int) $5);
			}
			| class_ref OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = ClassRefToObject ($1, (int) $3);
			}
			;

sec_action		: K_REQUEST
			{
				$$ = Mono.Cecil.SecurityAction.Request;
			}
			| K_DEMAND
			{
				$$ = Mono.Cecil.SecurityAction.Demand;
			}
			| K_ASSERT
			{
				$$ = Mono.Cecil.SecurityAction.Assert;
			}
			| K_DENY
			{
				$$ = Mono.Cecil.SecurityAction.Deny;
			}
			| K_PERMITONLY
			{
				$$ = Mono.Cecil.SecurityAction.PermitOnly;
			}
			| K_LINKCHECK
			{
				$$ = Mono.Cecil.SecurityAction.LinkDemand;
			}
			| K_INHERITCHECK
			{
				$$ = Mono.Cecil.SecurityAction.InheritDemand;
			}
			| K_REQMIN
			{
				$$ = Mono.Cecil.SecurityAction.RequestMinimum;
			}
			| K_REQOPT
			{
				$$ = Mono.Cecil.SecurityAction.RequestOptional;
			}
			| K_REQREFUSE
			{
				$$ = Mono.Cecil.SecurityAction.RequestRefuse;
			}
			| K_PREJITGRANT
			{
				$$ = Mono.Cecil.SecurityAction.PreJitGrant;
			}
			| K_PREJITDENY
			{
				$$ = Mono.Cecil.SecurityAction.PreJitDeny;
			}
			| K_NONCASDEMAND
			{
				$$ = Mono.Cecil.SecurityAction.NonCasDemand;
			}
			| K_NONCASLINKDEMAND
			{
				$$ = Mono.Cecil.SecurityAction.NonCasLinkDemand;
			}
			| K_NONCASINHERITANCE
			{
				$$ = Mono.Cecil.SecurityAction.NonCasInheritance;
			}
			;
*/

prop_or_field		: K_PROPERTY
			{
				$$ = TokenType.Property;
			}
			| K_FIELD
			{
				$$ = TokenType.Field;
			}
			;

module_head		: D_MODULE
			| D_MODULE comp_name
			{
				var name = ((QualifiedName) $2).FullName;

				if (!codegen.HasModuleDirective) {
					// Microsoft's ILAsm only takes into account the
					// first .module directive
					codegen.CurrentModule.Name = name;
					codegen.HasModuleDirective = true;
				}
				else if (name != codegen.CurrentModule.Name)
					report.WriteWarning (Warning.ModuleDirectiveIgnored,
						".module directive with different name ignored.");
			}
			| D_MODULE K_EXTERN comp_name
			{
				var name = ((QualifiedName) $3).FullName;

				if (codegen.GetModuleReference (name) != null)
					report.WriteWarning (Warning.ModuleReferenceIgnored,
						"Ignoring duplicate module reference: {0}", name);

				var module = new ModuleReference (name);
				codegen.CurrentModule.ModuleReferences.Add (module);
			}
			;

file_decl		: D_FILE file_attr comp_name file_entry D_HASH ASSIGN bytes_list file_entry
			| D_FILE file_attr comp_name file_entry
			;

file_attr 		:
			{
				$$ = true;
			}
			| file_attr K_NOMETADATA
			{
				$$ = false;
			}
			;

file_entry		:
			{
				$$ = false;
			}
			| D_ENTRYPOINT
			{
				$$ = true;
			}
			;

assembly_all		: assembly_head OPEN_BRACE assembly_decls CLOSE_BRACE
			;

assembly_head		: D_ASSEMBLY asm_attr comp_name
			{
				var name = ((QualifiedName) $3).FullName;
				var asmName = codegen.CurrentModule.Assembly.Name;

				if (codegen.HasAssemblyDirective && name != asmName.Name)
					report.WriteError (Error.MultipleAssemblyDirectives,
						"Multiple .assembly directives.");

				asmName.Attributes = (AssemblyAttributes) $2;
				asmName.Name = name;
				codegen.HasAssemblyDirective = true;
			}
			;

asm_attr		:
			{
				$$ = AssemblyAttributes.SideBySideCompatible;
			}
			| asm_attr K_RETARGETABLE
			{
				$$ = ((AssemblyAttributes) $1) | AssemblyAttributes.Retargetable;
			}
			// TODO: What on earth do we do with these?! Some look like corflags, others
			// look more like target architectures... They also aren't documented...
			| asm_attr K_LEGACY K_LIBRARY
			| asm_attr K_CIL
			| asm_attr K_X86
			| asm_attr K_IA64
			| asm_attr K_AMD64
			| asm_attr K_NOAPPDOMAIN
			| asm_attr K_NOPROCESS
			| asm_attr K_NOMACHINE
			;

assembly_decls		:
			| assembly_decls assembly_decl
			;

locale_or_culture	: D_LOCALE
			| D_CULTURE
			;

assembly_decl		: D_PUBLICKEY ASSIGN bytes_list
			{
				codegen.CurrentModule.Assembly.Name.PublicKey = (byte[]) $3;
			}
			| D_VER int32 COLON int32 COLON int32 COLON int32
			{
				codegen.CurrentModule.Assembly.Name.Version =
					new Version ((int) $2, (int) $4, (int) $6, (int) $8);
			}
			| locale_or_culture comp_qstring
			{
				codegen.CurrentModule.Assembly.Name.Culture = (string) $2;
			}
			| locale_or_culture ASSIGN bytes_list
			{
				// I assume this is UTF-16. I really have no clue, though,
				// and it isn't documented...
				var text = Encoding.Unicode.GetString ((byte[]) $3);
				codegen.CurrentModule.Assembly.Name.Culture = text;
			}
			| D_HASH K_ALGORITHM int32
			{
				var algo = (AssemblyHashAlgorithm) (int) $3;

				if (algo != AssemblyHashAlgorithm.SHA1)
					report.WriteWarning (Warning.UnknownHashAlgorithm,
						"Unknown hash algorithm; suggest using {0}.",
						((int) AssemblyHashAlgorithm.SHA1).ToString ("X8"));

				codegen.CurrentModule.Assembly.Name.HashAlgorithm = algo;
			}
			| customattr_decl
			{
				codegen.CurrentModule.Assembly.CustomAttributes.Add ((CustomAttribute) $1);
				codegen.CurrentCustomAttribute = null;
			}
			/*
			| sec_decl
			*/
			| comp_control
			;

assemblyref_all		: assemblyref_head OPEN_BRACE assemblyref_decls CLOSE_BRACE
			{
				var asmRef = codegen.CurrentAssemblyReference;
				var asmRefAlias = asmRef as AliasedAssemblyNameReference;
				var name = asmRefAlias != null ? asmRefAlias.Alias : asmRef.Name;

				// If we already have a reference with this name, we
				// ignore the one we just built.
				if (codegen.GetAliasedAssemblyReference (name) == null) {
					// If we have a public key and a token, we prefer the
					// token. Cecil prefers the public key, so we have to
					// do this ourselves.
					if (has_public_key && has_public_key_token) {
						var token = asmRef.PublicKeyToken;
						asmRef.PublicKey = null;
						asmRef.PublicKeyToken = token;
					}

					if (asmRefAlias != null)
						codegen.AliasedAssemblyReferences.Add (asmRefAlias.Alias, asmRefAlias);

					codegen.CurrentModule.AssemblyReferences.Add (asmRef);
				}
				else
					report.WriteWarning (Warning.AssemblyReferenceIgnored,
						"Redeclaration of assembly '{0}' ignored.", name);

				codegen.CurrentAssemblyReference = null;
				has_public_key = false;
				has_public_key_token = false;
			}
			;

assemblyref_head	: D_ASSEMBLY K_EXTERN asm_attr comp_name
			{
				codegen.CurrentAssemblyReference = new AssemblyNameReference (((QualifiedName) $4).FullName,
					new Version ()) {
					Attributes = (AssemblyAttributes) $3,
				};
			}
			| D_ASSEMBLY K_EXTERN asm_attr comp_name K_AS comp_name
			{
				var name = (QualifiedName) $6;

				codegen.CurrentAssemblyReference = new AliasedAssemblyNameReference (((QualifiedName) $4).FullName,
					new Version ()) {
					Alias = name.FullName,
					Attributes = (AssemblyAttributes) $3,
				};
			}
			;

assemblyref_decls	:
			| assemblyref_decls assemblyref_decl
			;

assemblyref_decl	: D_VER int32 COLON int32 COLON int32 COLON int32
			{
				codegen.CurrentAssemblyReference.Version =
					new Version ((int) $2, (int) $4, (int) $6, (int) $8);
			}
			| D_PUBLICKEY ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.PublicKey = (byte[]) $3;
				has_public_key = true;
			}
			| D_PUBLICKEYTOKEN ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.PublicKeyToken = (byte[]) $3;
				has_public_key_token = true;
			}
			| locale_or_culture comp_qstring
			{
				codegen.CurrentAssemblyReference.Culture = (string) $2;
			}
			| locale_or_culture ASSIGN bytes_list
			{
				// See the note in assembly_decl -> D_LOCALE.
				var text = Encoding.Unicode.GetString ((byte[]) $3);
				codegen.CurrentAssemblyReference.Culture = text;
			}
			| D_HASH ASSIGN bytes_list
			{
				codegen.CurrentAssemblyReference.Hash = (byte[]) $3;
			}
			| K_AUTO // TODO: Implement this.
			| customattr_decl // TODO: How do we set CAs on assembly name refs?
			| comp_control
			;

exptype_all		: exptype_head OPEN_BRACE exptype_decls CLOSE_BRACE
			{
			}
			;

exptype_directive	: D_CLASS K_EXTERN
			| D_EXPORT
			;

exptype_head		: exptype_directive expt_attr comp_name
			{
				var qn = (QualifiedName) $3;

				$$ = new Tuple<QualifiedName, TypeAttributes> (qn, (TypeAttributes) $2);
			}
			;

expt_attr 		:
			{
				$$ = TypeAttributes.NotPublic;
			}
			| expt_attr K_PRIVATE			{ $$ = (TypeAttributes) $1 | TypeAttributes.NotPublic; }
			| expt_attr K_PUBLIC			{ $$ = (TypeAttributes) $1 | TypeAttributes.Public; }
			| expt_attr K_FORWARDER			{ $$ = (TypeAttributes) $1 | TypeAttributes.Forwarder; }
			| expt_attr K_NESTED K_PUBLIC		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPublic; }
			| expt_attr K_NESTED K_PRIVATE		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedPrivate; }
			| expt_attr K_NESTED K_FAMILY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamily; }
			| expt_attr K_NESTED K_ASSEMBLY		{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedAssembly; }
			| expt_attr K_NESTED K_FAMANDASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamANDAssem; }
			| expt_attr K_NESTED K_FAMORASSEM	{ $$ = (TypeAttributes) $1 | TypeAttributes.NestedFamORAssem; }
			;

exptype_decls		:
			| exptype_decls exptype_decl
			{
				// Just use the last declaration.
				$$ = $2;
			}
			;

exptype_decl		: D_FILE comp_name // TODO: Handle this case.
			| D_CLASS K_EXTERN comp_name
			{
				$$ = codegen.GetTypeByName ((QualifiedName) $3);
			}
			| D_ASSEMBLY K_EXTERN comp_name
			{
				var name = ((QualifiedName) $3).FullName;

				$$ = codegen.GetAssemblyReference (name);
			}
			| mdtoken_type
			| D_CLASS int32
			{
				$$ = $2;
			}
			| customattr_decl
			| comp_control
			;

manifestres_all		: manifestres_head OPEN_BRACE manifestres_decls CLOSE_BRACE
			{
				var head = $1 as Tuple<ManifestResourceAttributes, string>;
				var aliasedHead = $1 as Tuple<ManifestResourceAttributes, string, string>;

				string resName;
				string fileName;
				ManifestResourceAttributes attr;

				if (aliasedHead != null) {
					attr = aliasedHead.X;
					resName = aliasedHead.Y;
					fileName = aliasedHead.Z;
				} else {
					attr = head.X;
					resName = head.Y;
					fileName = head.Y;
				}

				Resource rsc;

				object resourceArg = null;
				var decls = (List<object>) $3;

				for (var i = 0; i < decls.Count; i++) {
					var decl = decls [i];

					if (!(decl is CustomAttribute)) {
						decls.Remove (decl);
						resourceArg = decl;
					}
				}

				if (resourceArg != null) {
					var asmDecl = resourceArg as string;

					if (asmDecl != null) {
						var asmRef = codegen.GetAssemblyReference (asmDecl);
						rsc = new AssemblyLinkedResource (resName, attr, asmRef);
					} else {
						// TODO: Propagate nometadata/.entrypoint/offset.
						// TODO: Error if the file was not declared with .file.
						var fileDecl = resourceArg as Tuple<string, int>;
						rsc = new LinkedResource (resName, attr, fileDecl.X);
					}
				} else {
					byte[] bytes = null;

					try
					{
						bytes = File.ReadAllBytes (fileName);
					}
					catch (IOException ex)
					{
						report.WriteError (Error.ResourceFileError,
							"Could not read embedded resource file '{0}': {1}",
								fileName, ex.Message);
					}

					rsc = new EmbeddedResource (resName, attr, bytes);
				}

				// TODO: Cecil doesn't support CAs on resources yet.
				//foreach (var cattr in decls)
				//	rsc.CustomAttributes.Add ((CustomAttribute) cattr);

				codegen.CurrentModule.Resources.Add (rsc);
			}
			;

manifestres_head	: D_MRESOURCE manres_attr comp_name
			{
				$$ = new Tuple<ManifestResourceAttributes, string> ((ManifestResourceAttributes) $2,
					((QualifiedName) $3).FullName);
			}
			| D_MRESOURCE manres_attr comp_name K_AS comp_name
			{
				$$ = new Tuple<ManifestResourceAttributes, string, string> ((ManifestResourceAttributes) $2,
					((QualifiedName) $3).FullName, ((QualifiedName) $5).FullName);
			}
			;

manres_attr		:
			{
				$$ = (ManifestResourceAttributes) 0;
			}
			| manres_attr K_PUBLIC
			{
				// Blame Microsoft for this madness.
				$$ = ((ManifestResourceAttributes) $1 != 0 && (ManifestResourceAttributes) $1 !=
					ManifestResourceAttributes.Public) ? 0 : ManifestResourceAttributes.Public;
			}
			| manres_attr K_PRIVATE
			{
				$$ = ((ManifestResourceAttributes) $1 != 0 && (ManifestResourceAttributes) $1 !=
					ManifestResourceAttributes.Private) ? 0 : ManifestResourceAttributes.Private;
			} 
			;

manifestres_decls	:
			{
				$$ = new List<object> ();
			}
			| manifestres_decl
			{
				$$ = new List<object> {
					$1,
				};
			}
			| manifestres_decls manifestres_decl
			{
				((List<object>) $1).Add ($2);
			}
			;

manifestres_decl	: D_FILE comp_name K_AT int32
			{
				$$ = new Tuple<string, int> (((QualifiedName) $2).FullName,
					(int) $4);
			}
			| D_ASSEMBLY K_EXTERN comp_name
			{
				$$ = ((QualifiedName) $3).FullName;
			}
			| customattr_decl
			{
				$$ = $1;
			}
			| comp_control
			;

slashed_name		: comp_name
			| slashed_name SLASH comp_name
			{
				var sl = (QualifiedName) $1;

				var qn = new QualifiedName {
					Name = ((QualifiedName) $3).FullName, // TODO: Verify this.
				};

				foreach (var ns in sl.Namespaces)
					qn.Namespaces.Add (ns);

				foreach (var nesting in sl.Nestings)
					qn.Nestings.Add (nesting);

				qn.Nestings.Add (sl.Name);

				$$ = qn;
			}
			;

mdtoken			: K_MDTOKEN OPEN_PARENS int32 CLOSE_PARENS
			{
				$$ = $2;
			}
			;

comp_qstring		: QSTRING
			| comp_qstring PLUS QSTRING
			{
				$$ = string.Format ("{0}{1}", $1, $3);
			}
			;

int32			: INT64
			{
				$$ = BitConverter.ToInt32 (BitConverter.GetBytes ((long) $1),
					BitConverter.IsLittleEndian ? 0 : 4);
			}
			;

int64			: INT64
			;

float64			: FLOAT64
			| K_FLOAT32 OPEN_PARENS INT32 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((int) $3), 0);
			}
			| K_FLOAT32 OPEN_PARENS INT64 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((long) $3),
					BitConverter.IsLittleEndian ? 0 : 4);
			}
			| K_FLOAT64 OPEN_PARENS INT64 CLOSE_PARENS
			{
				$$ = BitConverter.ToDouble (BitConverter.GetBytes ((long) $3), 0);
			}
			| K_FLOAT64 OPEN_PARENS INT32 CLOSE_PARENS
			{
				$$ = (double) BitConverter.ToSingle (BitConverter.GetBytes ((int) $3), 0);
			}
			;

hexbyte			: HEXBYTE
			;

bytes_list		: OPEN_PARENS
			{
				tokenizer.InByteArray  = true;
			}
			  bytes CLOSE_PARENS
			{
				tokenizer.InByteArray  = false;

				$$ = $3;
			}
			;

bytes			:
			{
				$$ = new byte [0];
			}
			| hexbytes
			{
				$$ = ((List<byte>) $1).ToArray ();
			}
			;

hexbytes		: hexbyte
			{
				$$ = new List<byte> {
					Convert.ToByte ($1),
				};
			}
			| hexbytes hexbyte
			{
				((List<byte>) $1).Add (Convert.ToByte ($2));
			}
			;

truefalse		: K_TRUE
			{
				$$ = true;
			}
			| K_FALSE
			{
				$$ = false;
			}
			;

opt_id			:
			| id
			;

id			: ID
			| SQSTRING
			;

comp_name_str		: comp_name
			{
				$$ = ((QualifiedName) $1).FullName;
			}
			;

comp_name		: id
			{
				// HACK: A bug exists in the tokenizer, which causes it
				// to feed us an ID token with dots. We work around this
				// for now.
				var str = (string) $1;
				var nspaces = str.Split ('.');

				var qn = new QualifiedName {
					Name = nspaces [nspaces.Length - 1],
				};

				for (var i = 0; i < nspaces.Length; i++)
					if (i != nspaces.Length - 1)
						qn.Namespaces.Add (nspaces [i]);

				$$ = qn;
			}
			| COMP_NAME
			{
				var strings = ((string) $1).Split ('.');

				var qn = new QualifiedName {
					Name = strings [1],
				};
				qn.Namespaces.Add (strings [0]);

				$$ = qn;
			}
			| comp_name DOT comp_name
			{
				var n1 = (QualifiedName) $1;
				var n2 = (QualifiedName) $2;

				var qn = new QualifiedName {
					Name = n2.Name,
				};

				foreach (var ns in n1.Namespaces)
					qn.Namespaces.Add (ns);

				qn.Namespaces.Add (n1.Name);

				foreach (var ns in n2.Namespaces)
					qn.Namespaces.Add (ns);

				$$ = qn;
			}
			;

%%

}
